'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link RepairAction} that the service accepts. */
exports.KnownRepairAction = void 0;
(function (KnownRepairAction) {
    /** Replace */
    KnownRepairAction["Replace"] = "Replace";
    /** Restart */
    KnownRepairAction["Restart"] = "Restart";
    /** Reimage */
    KnownRepairAction["Reimage"] = "Reimage";
})(exports.KnownRepairAction || (exports.KnownRepairAction = {}));
/** Known values of {@link WindowsVMGuestPatchMode} that the service accepts. */
exports.KnownWindowsVMGuestPatchMode = void 0;
(function (KnownWindowsVMGuestPatchMode) {
    /** Manual */
    KnownWindowsVMGuestPatchMode["Manual"] = "Manual";
    /** AutomaticByOS */
    KnownWindowsVMGuestPatchMode["AutomaticByOS"] = "AutomaticByOS";
    /** AutomaticByPlatform */
    KnownWindowsVMGuestPatchMode["AutomaticByPlatform"] = "AutomaticByPlatform";
})(exports.KnownWindowsVMGuestPatchMode || (exports.KnownWindowsVMGuestPatchMode = {}));
/** Known values of {@link WindowsPatchAssessmentMode} that the service accepts. */
exports.KnownWindowsPatchAssessmentMode = void 0;
(function (KnownWindowsPatchAssessmentMode) {
    /** ImageDefault */
    KnownWindowsPatchAssessmentMode["ImageDefault"] = "ImageDefault";
    /** AutomaticByPlatform */
    KnownWindowsPatchAssessmentMode["AutomaticByPlatform"] = "AutomaticByPlatform";
})(exports.KnownWindowsPatchAssessmentMode || (exports.KnownWindowsPatchAssessmentMode = {}));
/** Known values of {@link WindowsVMGuestPatchAutomaticByPlatformRebootSetting} that the service accepts. */
exports.KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting = void 0;
(function (KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting) {
    /** Unknown */
    KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting["Unknown"] = "Unknown";
    /** IfRequired */
    KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting["IfRequired"] = "IfRequired";
    /** Never */
    KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting["Never"] = "Never";
    /** Always */
    KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting["Always"] = "Always";
})(exports.KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting || (exports.KnownWindowsVMGuestPatchAutomaticByPlatformRebootSetting = {}));
/** Known values of {@link LinuxVMGuestPatchMode} that the service accepts. */
exports.KnownLinuxVMGuestPatchMode = void 0;
(function (KnownLinuxVMGuestPatchMode) {
    /** ImageDefault */
    KnownLinuxVMGuestPatchMode["ImageDefault"] = "ImageDefault";
    /** AutomaticByPlatform */
    KnownLinuxVMGuestPatchMode["AutomaticByPlatform"] = "AutomaticByPlatform";
})(exports.KnownLinuxVMGuestPatchMode || (exports.KnownLinuxVMGuestPatchMode = {}));
/** Known values of {@link LinuxPatchAssessmentMode} that the service accepts. */
exports.KnownLinuxPatchAssessmentMode = void 0;
(function (KnownLinuxPatchAssessmentMode) {
    /** ImageDefault */
    KnownLinuxPatchAssessmentMode["ImageDefault"] = "ImageDefault";
    /** AutomaticByPlatform */
    KnownLinuxPatchAssessmentMode["AutomaticByPlatform"] = "AutomaticByPlatform";
})(exports.KnownLinuxPatchAssessmentMode || (exports.KnownLinuxPatchAssessmentMode = {}));
/** Known values of {@link LinuxVMGuestPatchAutomaticByPlatformRebootSetting} that the service accepts. */
exports.KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting = void 0;
(function (KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting) {
    /** Unknown */
    KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting["Unknown"] = "Unknown";
    /** IfRequired */
    KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting["IfRequired"] = "IfRequired";
    /** Never */
    KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting["Never"] = "Never";
    /** Always */
    KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting["Always"] = "Always";
})(exports.KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting || (exports.KnownLinuxVMGuestPatchAutomaticByPlatformRebootSetting = {}));
/** Known values of {@link DiskCreateOptionTypes} that the service accepts. */
exports.KnownDiskCreateOptionTypes = void 0;
(function (KnownDiskCreateOptionTypes) {
    /** FromImage */
    KnownDiskCreateOptionTypes["FromImage"] = "FromImage";
    /** Empty */
    KnownDiskCreateOptionTypes["Empty"] = "Empty";
    /** Attach */
    KnownDiskCreateOptionTypes["Attach"] = "Attach";
})(exports.KnownDiskCreateOptionTypes || (exports.KnownDiskCreateOptionTypes = {}));
/** Known values of {@link DiffDiskOptions} that the service accepts. */
exports.KnownDiffDiskOptions = void 0;
(function (KnownDiffDiskOptions) {
    /** Local */
    KnownDiffDiskOptions["Local"] = "Local";
})(exports.KnownDiffDiskOptions || (exports.KnownDiffDiskOptions = {}));
/** Known values of {@link DiffDiskPlacement} that the service accepts. */
exports.KnownDiffDiskPlacement = void 0;
(function (KnownDiffDiskPlacement) {
    /** CacheDisk */
    KnownDiffDiskPlacement["CacheDisk"] = "CacheDisk";
    /** ResourceDisk */
    KnownDiffDiskPlacement["ResourceDisk"] = "ResourceDisk";
})(exports.KnownDiffDiskPlacement || (exports.KnownDiffDiskPlacement = {}));
/** Known values of {@link StorageAccountTypes} that the service accepts. */
exports.KnownStorageAccountTypes = void 0;
(function (KnownStorageAccountTypes) {
    /** StandardLRS */
    KnownStorageAccountTypes["StandardLRS"] = "Standard_LRS";
    /** PremiumLRS */
    KnownStorageAccountTypes["PremiumLRS"] = "Premium_LRS";
    /** StandardSSDLRS */
    KnownStorageAccountTypes["StandardSSDLRS"] = "StandardSSD_LRS";
    /** UltraSSDLRS */
    KnownStorageAccountTypes["UltraSSDLRS"] = "UltraSSD_LRS";
    /** PremiumZRS */
    KnownStorageAccountTypes["PremiumZRS"] = "Premium_ZRS";
    /** StandardSSDZRS */
    KnownStorageAccountTypes["StandardSSDZRS"] = "StandardSSD_ZRS";
    /** PremiumV2LRS */
    KnownStorageAccountTypes["PremiumV2LRS"] = "PremiumV2_LRS";
})(exports.KnownStorageAccountTypes || (exports.KnownStorageAccountTypes = {}));
/** Known values of {@link SecurityEncryptionTypes} that the service accepts. */
exports.KnownSecurityEncryptionTypes = void 0;
(function (KnownSecurityEncryptionTypes) {
    /** VMGuestStateOnly */
    KnownSecurityEncryptionTypes["VMGuestStateOnly"] = "VMGuestStateOnly";
    /** DiskWithVMGuestState */
    KnownSecurityEncryptionTypes["DiskWithVMGuestState"] = "DiskWithVMGuestState";
})(exports.KnownSecurityEncryptionTypes || (exports.KnownSecurityEncryptionTypes = {}));
/** Known values of {@link DiskDeleteOptionTypes} that the service accepts. */
exports.KnownDiskDeleteOptionTypes = void 0;
(function (KnownDiskDeleteOptionTypes) {
    /** Delete */
    KnownDiskDeleteOptionTypes["Delete"] = "Delete";
    /** Detach */
    KnownDiskDeleteOptionTypes["Detach"] = "Detach";
})(exports.KnownDiskDeleteOptionTypes || (exports.KnownDiskDeleteOptionTypes = {}));
/** Known values of {@link IPVersion} that the service accepts. */
exports.KnownIPVersion = void 0;
(function (KnownIPVersion) {
    /** IPv4 */
    KnownIPVersion["IPv4"] = "IPv4";
    /** IPv6 */
    KnownIPVersion["IPv6"] = "IPv6";
})(exports.KnownIPVersion || (exports.KnownIPVersion = {}));
/** Known values of {@link DeleteOptions} that the service accepts. */
exports.KnownDeleteOptions = void 0;
(function (KnownDeleteOptions) {
    /** Delete */
    KnownDeleteOptions["Delete"] = "Delete";
    /** Detach */
    KnownDeleteOptions["Detach"] = "Detach";
})(exports.KnownDeleteOptions || (exports.KnownDeleteOptions = {}));
/** Known values of {@link PublicIPAddressSkuName} that the service accepts. */
exports.KnownPublicIPAddressSkuName = void 0;
(function (KnownPublicIPAddressSkuName) {
    /** Basic */
    KnownPublicIPAddressSkuName["Basic"] = "Basic";
    /** Standard */
    KnownPublicIPAddressSkuName["Standard"] = "Standard";
})(exports.KnownPublicIPAddressSkuName || (exports.KnownPublicIPAddressSkuName = {}));
/** Known values of {@link PublicIPAddressSkuTier} that the service accepts. */
exports.KnownPublicIPAddressSkuTier = void 0;
(function (KnownPublicIPAddressSkuTier) {
    /** Regional */
    KnownPublicIPAddressSkuTier["Regional"] = "Regional";
    /** Global */
    KnownPublicIPAddressSkuTier["Global"] = "Global";
})(exports.KnownPublicIPAddressSkuTier || (exports.KnownPublicIPAddressSkuTier = {}));
/** Known values of {@link NetworkApiVersion} that the service accepts. */
exports.KnownNetworkApiVersion = void 0;
(function (KnownNetworkApiVersion) {
    /** TwoThousandTwenty1101 */
    KnownNetworkApiVersion["TwoThousandTwenty1101"] = "2020-11-01";
})(exports.KnownNetworkApiVersion || (exports.KnownNetworkApiVersion = {}));
/** Known values of {@link SecurityTypes} that the service accepts. */
exports.KnownSecurityTypes = void 0;
(function (KnownSecurityTypes) {
    /** TrustedLaunch */
    KnownSecurityTypes["TrustedLaunch"] = "TrustedLaunch";
    /** ConfidentialVM */
    KnownSecurityTypes["ConfidentialVM"] = "ConfidentialVM";
})(exports.KnownSecurityTypes || (exports.KnownSecurityTypes = {}));
/** Known values of {@link VirtualMachinePriorityTypes} that the service accepts. */
exports.KnownVirtualMachinePriorityTypes = void 0;
(function (KnownVirtualMachinePriorityTypes) {
    /** Regular */
    KnownVirtualMachinePriorityTypes["Regular"] = "Regular";
    /** Low */
    KnownVirtualMachinePriorityTypes["Low"] = "Low";
    /** Spot */
    KnownVirtualMachinePriorityTypes["Spot"] = "Spot";
})(exports.KnownVirtualMachinePriorityTypes || (exports.KnownVirtualMachinePriorityTypes = {}));
/** Known values of {@link VirtualMachineEvictionPolicyTypes} that the service accepts. */
exports.KnownVirtualMachineEvictionPolicyTypes = void 0;
(function (KnownVirtualMachineEvictionPolicyTypes) {
    /** Deallocate */
    KnownVirtualMachineEvictionPolicyTypes["Deallocate"] = "Deallocate";
    /** Delete */
    KnownVirtualMachineEvictionPolicyTypes["Delete"] = "Delete";
})(exports.KnownVirtualMachineEvictionPolicyTypes || (exports.KnownVirtualMachineEvictionPolicyTypes = {}));
/** Known values of {@link VirtualMachineScaleSetScaleInRules} that the service accepts. */
exports.KnownVirtualMachineScaleSetScaleInRules = void 0;
(function (KnownVirtualMachineScaleSetScaleInRules) {
    /** Default */
    KnownVirtualMachineScaleSetScaleInRules["Default"] = "Default";
    /** OldestVM */
    KnownVirtualMachineScaleSetScaleInRules["OldestVM"] = "OldestVM";
    /** NewestVM */
    KnownVirtualMachineScaleSetScaleInRules["NewestVM"] = "NewestVM";
})(exports.KnownVirtualMachineScaleSetScaleInRules || (exports.KnownVirtualMachineScaleSetScaleInRules = {}));
/** Known values of {@link OrchestrationMode} that the service accepts. */
exports.KnownOrchestrationMode = void 0;
(function (KnownOrchestrationMode) {
    /** Uniform */
    KnownOrchestrationMode["Uniform"] = "Uniform";
    /** Flexible */
    KnownOrchestrationMode["Flexible"] = "Flexible";
})(exports.KnownOrchestrationMode || (exports.KnownOrchestrationMode = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
exports.KnownExtendedLocationTypes = void 0;
(function (KnownExtendedLocationTypes) {
    /** EdgeZone */
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
/** Known values of {@link ExpandTypesForGetVMScaleSets} that the service accepts. */
exports.KnownExpandTypesForGetVMScaleSets = void 0;
(function (KnownExpandTypesForGetVMScaleSets) {
    /** UserData */
    KnownExpandTypesForGetVMScaleSets["UserData"] = "userData";
})(exports.KnownExpandTypesForGetVMScaleSets || (exports.KnownExpandTypesForGetVMScaleSets = {}));
/** Known values of {@link OrchestrationServiceNames} that the service accepts. */
exports.KnownOrchestrationServiceNames = void 0;
(function (KnownOrchestrationServiceNames) {
    /** AutomaticRepairs */
    KnownOrchestrationServiceNames["AutomaticRepairs"] = "AutomaticRepairs";
    /** DummyOrchestrationServiceName */
    KnownOrchestrationServiceNames["DummyOrchestrationServiceName"] = "DummyOrchestrationServiceName";
})(exports.KnownOrchestrationServiceNames || (exports.KnownOrchestrationServiceNames = {}));
/** Known values of {@link OrchestrationServiceState} that the service accepts. */
exports.KnownOrchestrationServiceState = void 0;
(function (KnownOrchestrationServiceState) {
    /** NotRunning */
    KnownOrchestrationServiceState["NotRunning"] = "NotRunning";
    /** Running */
    KnownOrchestrationServiceState["Running"] = "Running";
    /** Suspended */
    KnownOrchestrationServiceState["Suspended"] = "Suspended";
})(exports.KnownOrchestrationServiceState || (exports.KnownOrchestrationServiceState = {}));
/** Known values of {@link OrchestrationServiceStateAction} that the service accepts. */
exports.KnownOrchestrationServiceStateAction = void 0;
(function (KnownOrchestrationServiceStateAction) {
    /** Resume */
    KnownOrchestrationServiceStateAction["Resume"] = "Resume";
    /** Suspend */
    KnownOrchestrationServiceStateAction["Suspend"] = "Suspend";
})(exports.KnownOrchestrationServiceStateAction || (exports.KnownOrchestrationServiceStateAction = {}));
/** Known values of {@link VirtualMachineSizeTypes} that the service accepts. */
exports.KnownVirtualMachineSizeTypes = void 0;
(function (KnownVirtualMachineSizeTypes) {
    /** BasicA0 */
    KnownVirtualMachineSizeTypes["BasicA0"] = "Basic_A0";
    /** BasicA1 */
    KnownVirtualMachineSizeTypes["BasicA1"] = "Basic_A1";
    /** BasicA2 */
    KnownVirtualMachineSizeTypes["BasicA2"] = "Basic_A2";
    /** BasicA3 */
    KnownVirtualMachineSizeTypes["BasicA3"] = "Basic_A3";
    /** BasicA4 */
    KnownVirtualMachineSizeTypes["BasicA4"] = "Basic_A4";
    /** StandardA0 */
    KnownVirtualMachineSizeTypes["StandardA0"] = "Standard_A0";
    /** StandardA1 */
    KnownVirtualMachineSizeTypes["StandardA1"] = "Standard_A1";
    /** StandardA2 */
    KnownVirtualMachineSizeTypes["StandardA2"] = "Standard_A2";
    /** StandardA3 */
    KnownVirtualMachineSizeTypes["StandardA3"] = "Standard_A3";
    /** StandardA4 */
    KnownVirtualMachineSizeTypes["StandardA4"] = "Standard_A4";
    /** StandardA5 */
    KnownVirtualMachineSizeTypes["StandardA5"] = "Standard_A5";
    /** StandardA6 */
    KnownVirtualMachineSizeTypes["StandardA6"] = "Standard_A6";
    /** StandardA7 */
    KnownVirtualMachineSizeTypes["StandardA7"] = "Standard_A7";
    /** StandardA8 */
    KnownVirtualMachineSizeTypes["StandardA8"] = "Standard_A8";
    /** StandardA9 */
    KnownVirtualMachineSizeTypes["StandardA9"] = "Standard_A9";
    /** StandardA10 */
    KnownVirtualMachineSizeTypes["StandardA10"] = "Standard_A10";
    /** StandardA11 */
    KnownVirtualMachineSizeTypes["StandardA11"] = "Standard_A11";
    /** StandardA1V2 */
    KnownVirtualMachineSizeTypes["StandardA1V2"] = "Standard_A1_v2";
    /** StandardA2V2 */
    KnownVirtualMachineSizeTypes["StandardA2V2"] = "Standard_A2_v2";
    /** StandardA4V2 */
    KnownVirtualMachineSizeTypes["StandardA4V2"] = "Standard_A4_v2";
    /** StandardA8V2 */
    KnownVirtualMachineSizeTypes["StandardA8V2"] = "Standard_A8_v2";
    /** StandardA2MV2 */
    KnownVirtualMachineSizeTypes["StandardA2MV2"] = "Standard_A2m_v2";
    /** StandardA4MV2 */
    KnownVirtualMachineSizeTypes["StandardA4MV2"] = "Standard_A4m_v2";
    /** StandardA8MV2 */
    KnownVirtualMachineSizeTypes["StandardA8MV2"] = "Standard_A8m_v2";
    /** StandardB1S */
    KnownVirtualMachineSizeTypes["StandardB1S"] = "Standard_B1s";
    /** StandardB1Ms */
    KnownVirtualMachineSizeTypes["StandardB1Ms"] = "Standard_B1ms";
    /** StandardB2S */
    KnownVirtualMachineSizeTypes["StandardB2S"] = "Standard_B2s";
    /** StandardB2Ms */
    KnownVirtualMachineSizeTypes["StandardB2Ms"] = "Standard_B2ms";
    /** StandardB4Ms */
    KnownVirtualMachineSizeTypes["StandardB4Ms"] = "Standard_B4ms";
    /** StandardB8Ms */
    KnownVirtualMachineSizeTypes["StandardB8Ms"] = "Standard_B8ms";
    /** StandardD1 */
    KnownVirtualMachineSizeTypes["StandardD1"] = "Standard_D1";
    /** StandardD2 */
    KnownVirtualMachineSizeTypes["StandardD2"] = "Standard_D2";
    /** StandardD3 */
    KnownVirtualMachineSizeTypes["StandardD3"] = "Standard_D3";
    /** StandardD4 */
    KnownVirtualMachineSizeTypes["StandardD4"] = "Standard_D4";
    /** StandardD11 */
    KnownVirtualMachineSizeTypes["StandardD11"] = "Standard_D11";
    /** StandardD12 */
    KnownVirtualMachineSizeTypes["StandardD12"] = "Standard_D12";
    /** StandardD13 */
    KnownVirtualMachineSizeTypes["StandardD13"] = "Standard_D13";
    /** StandardD14 */
    KnownVirtualMachineSizeTypes["StandardD14"] = "Standard_D14";
    /** StandardD1V2 */
    KnownVirtualMachineSizeTypes["StandardD1V2"] = "Standard_D1_v2";
    /** StandardD2V2 */
    KnownVirtualMachineSizeTypes["StandardD2V2"] = "Standard_D2_v2";
    /** StandardD3V2 */
    KnownVirtualMachineSizeTypes["StandardD3V2"] = "Standard_D3_v2";
    /** StandardD4V2 */
    KnownVirtualMachineSizeTypes["StandardD4V2"] = "Standard_D4_v2";
    /** StandardD5V2 */
    KnownVirtualMachineSizeTypes["StandardD5V2"] = "Standard_D5_v2";
    /** StandardD2V3 */
    KnownVirtualMachineSizeTypes["StandardD2V3"] = "Standard_D2_v3";
    /** StandardD4V3 */
    KnownVirtualMachineSizeTypes["StandardD4V3"] = "Standard_D4_v3";
    /** StandardD8V3 */
    KnownVirtualMachineSizeTypes["StandardD8V3"] = "Standard_D8_v3";
    /** StandardD16V3 */
    KnownVirtualMachineSizeTypes["StandardD16V3"] = "Standard_D16_v3";
    /** StandardD32V3 */
    KnownVirtualMachineSizeTypes["StandardD32V3"] = "Standard_D32_v3";
    /** StandardD64V3 */
    KnownVirtualMachineSizeTypes["StandardD64V3"] = "Standard_D64_v3";
    /** StandardD2SV3 */
    KnownVirtualMachineSizeTypes["StandardD2SV3"] = "Standard_D2s_v3";
    /** StandardD4SV3 */
    KnownVirtualMachineSizeTypes["StandardD4SV3"] = "Standard_D4s_v3";
    /** StandardD8SV3 */
    KnownVirtualMachineSizeTypes["StandardD8SV3"] = "Standard_D8s_v3";
    /** StandardD16SV3 */
    KnownVirtualMachineSizeTypes["StandardD16SV3"] = "Standard_D16s_v3";
    /** StandardD32SV3 */
    KnownVirtualMachineSizeTypes["StandardD32SV3"] = "Standard_D32s_v3";
    /** StandardD64SV3 */
    KnownVirtualMachineSizeTypes["StandardD64SV3"] = "Standard_D64s_v3";
    /** StandardD11V2 */
    KnownVirtualMachineSizeTypes["StandardD11V2"] = "Standard_D11_v2";
    /** StandardD12V2 */
    KnownVirtualMachineSizeTypes["StandardD12V2"] = "Standard_D12_v2";
    /** StandardD13V2 */
    KnownVirtualMachineSizeTypes["StandardD13V2"] = "Standard_D13_v2";
    /** StandardD14V2 */
    KnownVirtualMachineSizeTypes["StandardD14V2"] = "Standard_D14_v2";
    /** StandardD15V2 */
    KnownVirtualMachineSizeTypes["StandardD15V2"] = "Standard_D15_v2";
    /** StandardDS1 */
    KnownVirtualMachineSizeTypes["StandardDS1"] = "Standard_DS1";
    /** StandardDS2 */
    KnownVirtualMachineSizeTypes["StandardDS2"] = "Standard_DS2";
    /** StandardDS3 */
    KnownVirtualMachineSizeTypes["StandardDS3"] = "Standard_DS3";
    /** StandardDS4 */
    KnownVirtualMachineSizeTypes["StandardDS4"] = "Standard_DS4";
    /** StandardDS11 */
    KnownVirtualMachineSizeTypes["StandardDS11"] = "Standard_DS11";
    /** StandardDS12 */
    KnownVirtualMachineSizeTypes["StandardDS12"] = "Standard_DS12";
    /** StandardDS13 */
    KnownVirtualMachineSizeTypes["StandardDS13"] = "Standard_DS13";
    /** StandardDS14 */
    KnownVirtualMachineSizeTypes["StandardDS14"] = "Standard_DS14";
    /** StandardDS1V2 */
    KnownVirtualMachineSizeTypes["StandardDS1V2"] = "Standard_DS1_v2";
    /** StandardDS2V2 */
    KnownVirtualMachineSizeTypes["StandardDS2V2"] = "Standard_DS2_v2";
    /** StandardDS3V2 */
    KnownVirtualMachineSizeTypes["StandardDS3V2"] = "Standard_DS3_v2";
    /** StandardDS4V2 */
    KnownVirtualMachineSizeTypes["StandardDS4V2"] = "Standard_DS4_v2";
    /** StandardDS5V2 */
    KnownVirtualMachineSizeTypes["StandardDS5V2"] = "Standard_DS5_v2";
    /** StandardDS11V2 */
    KnownVirtualMachineSizeTypes["StandardDS11V2"] = "Standard_DS11_v2";
    /** StandardDS12V2 */
    KnownVirtualMachineSizeTypes["StandardDS12V2"] = "Standard_DS12_v2";
    /** StandardDS13V2 */
    KnownVirtualMachineSizeTypes["StandardDS13V2"] = "Standard_DS13_v2";
    /** StandardDS14V2 */
    KnownVirtualMachineSizeTypes["StandardDS14V2"] = "Standard_DS14_v2";
    /** StandardDS15V2 */
    KnownVirtualMachineSizeTypes["StandardDS15V2"] = "Standard_DS15_v2";
    /** StandardDS134V2 */
    KnownVirtualMachineSizeTypes["StandardDS134V2"] = "Standard_DS13-4_v2";
    /** StandardDS132V2 */
    KnownVirtualMachineSizeTypes["StandardDS132V2"] = "Standard_DS13-2_v2";
    /** StandardDS148V2 */
    KnownVirtualMachineSizeTypes["StandardDS148V2"] = "Standard_DS14-8_v2";
    /** StandardDS144V2 */
    KnownVirtualMachineSizeTypes["StandardDS144V2"] = "Standard_DS14-4_v2";
    /** StandardE2V3 */
    KnownVirtualMachineSizeTypes["StandardE2V3"] = "Standard_E2_v3";
    /** StandardE4V3 */
    KnownVirtualMachineSizeTypes["StandardE4V3"] = "Standard_E4_v3";
    /** StandardE8V3 */
    KnownVirtualMachineSizeTypes["StandardE8V3"] = "Standard_E8_v3";
    /** StandardE16V3 */
    KnownVirtualMachineSizeTypes["StandardE16V3"] = "Standard_E16_v3";
    /** StandardE32V3 */
    KnownVirtualMachineSizeTypes["StandardE32V3"] = "Standard_E32_v3";
    /** StandardE64V3 */
    KnownVirtualMachineSizeTypes["StandardE64V3"] = "Standard_E64_v3";
    /** StandardE2SV3 */
    KnownVirtualMachineSizeTypes["StandardE2SV3"] = "Standard_E2s_v3";
    /** StandardE4SV3 */
    KnownVirtualMachineSizeTypes["StandardE4SV3"] = "Standard_E4s_v3";
    /** StandardE8SV3 */
    KnownVirtualMachineSizeTypes["StandardE8SV3"] = "Standard_E8s_v3";
    /** StandardE16SV3 */
    KnownVirtualMachineSizeTypes["StandardE16SV3"] = "Standard_E16s_v3";
    /** StandardE32SV3 */
    KnownVirtualMachineSizeTypes["StandardE32SV3"] = "Standard_E32s_v3";
    /** StandardE64SV3 */
    KnownVirtualMachineSizeTypes["StandardE64SV3"] = "Standard_E64s_v3";
    /** StandardE3216V3 */
    KnownVirtualMachineSizeTypes["StandardE3216V3"] = "Standard_E32-16_v3";
    /** StandardE328SV3 */
    KnownVirtualMachineSizeTypes["StandardE328SV3"] = "Standard_E32-8s_v3";
    /** StandardE6432SV3 */
    KnownVirtualMachineSizeTypes["StandardE6432SV3"] = "Standard_E64-32s_v3";
    /** StandardE6416SV3 */
    KnownVirtualMachineSizeTypes["StandardE6416SV3"] = "Standard_E64-16s_v3";
    /** StandardF1 */
    KnownVirtualMachineSizeTypes["StandardF1"] = "Standard_F1";
    /** StandardF2 */
    KnownVirtualMachineSizeTypes["StandardF2"] = "Standard_F2";
    /** StandardF4 */
    KnownVirtualMachineSizeTypes["StandardF4"] = "Standard_F4";
    /** StandardF8 */
    KnownVirtualMachineSizeTypes["StandardF8"] = "Standard_F8";
    /** StandardF16 */
    KnownVirtualMachineSizeTypes["StandardF16"] = "Standard_F16";
    /** StandardF1S */
    KnownVirtualMachineSizeTypes["StandardF1S"] = "Standard_F1s";
    /** StandardF2S */
    KnownVirtualMachineSizeTypes["StandardF2S"] = "Standard_F2s";
    /** StandardF4S */
    KnownVirtualMachineSizeTypes["StandardF4S"] = "Standard_F4s";
    /** StandardF8S */
    KnownVirtualMachineSizeTypes["StandardF8S"] = "Standard_F8s";
    /** StandardF16S */
    KnownVirtualMachineSizeTypes["StandardF16S"] = "Standard_F16s";
    /** StandardF2SV2 */
    KnownVirtualMachineSizeTypes["StandardF2SV2"] = "Standard_F2s_v2";
    /** StandardF4SV2 */
    KnownVirtualMachineSizeTypes["StandardF4SV2"] = "Standard_F4s_v2";
    /** StandardF8SV2 */
    KnownVirtualMachineSizeTypes["StandardF8SV2"] = "Standard_F8s_v2";
    /** StandardF16SV2 */
    KnownVirtualMachineSizeTypes["StandardF16SV2"] = "Standard_F16s_v2";
    /** StandardF32SV2 */
    KnownVirtualMachineSizeTypes["StandardF32SV2"] = "Standard_F32s_v2";
    /** StandardF64SV2 */
    KnownVirtualMachineSizeTypes["StandardF64SV2"] = "Standard_F64s_v2";
    /** StandardF72SV2 */
    KnownVirtualMachineSizeTypes["StandardF72SV2"] = "Standard_F72s_v2";
    /** StandardG1 */
    KnownVirtualMachineSizeTypes["StandardG1"] = "Standard_G1";
    /** StandardG2 */
    KnownVirtualMachineSizeTypes["StandardG2"] = "Standard_G2";
    /** StandardG3 */
    KnownVirtualMachineSizeTypes["StandardG3"] = "Standard_G3";
    /** StandardG4 */
    KnownVirtualMachineSizeTypes["StandardG4"] = "Standard_G4";
    /** StandardG5 */
    KnownVirtualMachineSizeTypes["StandardG5"] = "Standard_G5";
    /** StandardGS1 */
    KnownVirtualMachineSizeTypes["StandardGS1"] = "Standard_GS1";
    /** StandardGS2 */
    KnownVirtualMachineSizeTypes["StandardGS2"] = "Standard_GS2";
    /** StandardGS3 */
    KnownVirtualMachineSizeTypes["StandardGS3"] = "Standard_GS3";
    /** StandardGS4 */
    KnownVirtualMachineSizeTypes["StandardGS4"] = "Standard_GS4";
    /** StandardGS5 */
    KnownVirtualMachineSizeTypes["StandardGS5"] = "Standard_GS5";
    /** StandardGS48 */
    KnownVirtualMachineSizeTypes["StandardGS48"] = "Standard_GS4-8";
    /** StandardGS44 */
    KnownVirtualMachineSizeTypes["StandardGS44"] = "Standard_GS4-4";
    /** StandardGS516 */
    KnownVirtualMachineSizeTypes["StandardGS516"] = "Standard_GS5-16";
    /** StandardGS58 */
    KnownVirtualMachineSizeTypes["StandardGS58"] = "Standard_GS5-8";
    /** StandardH8 */
    KnownVirtualMachineSizeTypes["StandardH8"] = "Standard_H8";
    /** StandardH16 */
    KnownVirtualMachineSizeTypes["StandardH16"] = "Standard_H16";
    /** StandardH8M */
    KnownVirtualMachineSizeTypes["StandardH8M"] = "Standard_H8m";
    /** StandardH16M */
    KnownVirtualMachineSizeTypes["StandardH16M"] = "Standard_H16m";
    /** StandardH16R */
    KnownVirtualMachineSizeTypes["StandardH16R"] = "Standard_H16r";
    /** StandardH16Mr */
    KnownVirtualMachineSizeTypes["StandardH16Mr"] = "Standard_H16mr";
    /** StandardL4S */
    KnownVirtualMachineSizeTypes["StandardL4S"] = "Standard_L4s";
    /** StandardL8S */
    KnownVirtualMachineSizeTypes["StandardL8S"] = "Standard_L8s";
    /** StandardL16S */
    KnownVirtualMachineSizeTypes["StandardL16S"] = "Standard_L16s";
    /** StandardL32S */
    KnownVirtualMachineSizeTypes["StandardL32S"] = "Standard_L32s";
    /** StandardM64S */
    KnownVirtualMachineSizeTypes["StandardM64S"] = "Standard_M64s";
    /** StandardM64Ms */
    KnownVirtualMachineSizeTypes["StandardM64Ms"] = "Standard_M64ms";
    /** StandardM128S */
    KnownVirtualMachineSizeTypes["StandardM128S"] = "Standard_M128s";
    /** StandardM128Ms */
    KnownVirtualMachineSizeTypes["StandardM128Ms"] = "Standard_M128ms";
    /** StandardM6432Ms */
    KnownVirtualMachineSizeTypes["StandardM6432Ms"] = "Standard_M64-32ms";
    /** StandardM6416Ms */
    KnownVirtualMachineSizeTypes["StandardM6416Ms"] = "Standard_M64-16ms";
    /** StandardM12864Ms */
    KnownVirtualMachineSizeTypes["StandardM12864Ms"] = "Standard_M128-64ms";
    /** StandardM12832Ms */
    KnownVirtualMachineSizeTypes["StandardM12832Ms"] = "Standard_M128-32ms";
    /** StandardNC6 */
    KnownVirtualMachineSizeTypes["StandardNC6"] = "Standard_NC6";
    /** StandardNC12 */
    KnownVirtualMachineSizeTypes["StandardNC12"] = "Standard_NC12";
    /** StandardNC24 */
    KnownVirtualMachineSizeTypes["StandardNC24"] = "Standard_NC24";
    /** StandardNC24R */
    KnownVirtualMachineSizeTypes["StandardNC24R"] = "Standard_NC24r";
    /** StandardNC6SV2 */
    KnownVirtualMachineSizeTypes["StandardNC6SV2"] = "Standard_NC6s_v2";
    /** StandardNC12SV2 */
    KnownVirtualMachineSizeTypes["StandardNC12SV2"] = "Standard_NC12s_v2";
    /** StandardNC24SV2 */
    KnownVirtualMachineSizeTypes["StandardNC24SV2"] = "Standard_NC24s_v2";
    /** StandardNC24RsV2 */
    KnownVirtualMachineSizeTypes["StandardNC24RsV2"] = "Standard_NC24rs_v2";
    /** StandardNC6SV3 */
    KnownVirtualMachineSizeTypes["StandardNC6SV3"] = "Standard_NC6s_v3";
    /** StandardNC12SV3 */
    KnownVirtualMachineSizeTypes["StandardNC12SV3"] = "Standard_NC12s_v3";
    /** StandardNC24SV3 */
    KnownVirtualMachineSizeTypes["StandardNC24SV3"] = "Standard_NC24s_v3";
    /** StandardNC24RsV3 */
    KnownVirtualMachineSizeTypes["StandardNC24RsV3"] = "Standard_NC24rs_v3";
    /** StandardND6S */
    KnownVirtualMachineSizeTypes["StandardND6S"] = "Standard_ND6s";
    /** StandardND12S */
    KnownVirtualMachineSizeTypes["StandardND12S"] = "Standard_ND12s";
    /** StandardND24S */
    KnownVirtualMachineSizeTypes["StandardND24S"] = "Standard_ND24s";
    /** StandardND24Rs */
    KnownVirtualMachineSizeTypes["StandardND24Rs"] = "Standard_ND24rs";
    /** StandardNV6 */
    KnownVirtualMachineSizeTypes["StandardNV6"] = "Standard_NV6";
    /** StandardNV12 */
    KnownVirtualMachineSizeTypes["StandardNV12"] = "Standard_NV12";
    /** StandardNV24 */
    KnownVirtualMachineSizeTypes["StandardNV24"] = "Standard_NV24";
})(exports.KnownVirtualMachineSizeTypes || (exports.KnownVirtualMachineSizeTypes = {}));
/** Known values of {@link DiskDetachOptionTypes} that the service accepts. */
exports.KnownDiskDetachOptionTypes = void 0;
(function (KnownDiskDetachOptionTypes) {
    /** ForceDetach */
    KnownDiskDetachOptionTypes["ForceDetach"] = "ForceDetach";
})(exports.KnownDiskDetachOptionTypes || (exports.KnownDiskDetachOptionTypes = {}));
/** Known values of {@link DiskControllerTypes} that the service accepts. */
exports.KnownDiskControllerTypes = void 0;
(function (KnownDiskControllerTypes) {
    /** Scsi */
    KnownDiskControllerTypes["Scsi"] = "SCSI";
    /** NVMe */
    KnownDiskControllerTypes["NVMe"] = "NVMe";
})(exports.KnownDiskControllerTypes || (exports.KnownDiskControllerTypes = {}));
/** Known values of {@link IPVersions} that the service accepts. */
exports.KnownIPVersions = void 0;
(function (KnownIPVersions) {
    /** IPv4 */
    KnownIPVersions["IPv4"] = "IPv4";
    /** IPv6 */
    KnownIPVersions["IPv6"] = "IPv6";
})(exports.KnownIPVersions || (exports.KnownIPVersions = {}));
/** Known values of {@link PublicIPAllocationMethod} that the service accepts. */
exports.KnownPublicIPAllocationMethod = void 0;
(function (KnownPublicIPAllocationMethod) {
    /** Dynamic */
    KnownPublicIPAllocationMethod["Dynamic"] = "Dynamic";
    /** Static */
    KnownPublicIPAllocationMethod["Static"] = "Static";
})(exports.KnownPublicIPAllocationMethod || (exports.KnownPublicIPAllocationMethod = {}));
/** Known values of {@link HyperVGenerationType} that the service accepts. */
exports.KnownHyperVGenerationType = void 0;
(function (KnownHyperVGenerationType) {
    /** V1 */
    KnownHyperVGenerationType["V1"] = "V1";
    /** V2 */
    KnownHyperVGenerationType["V2"] = "V2";
})(exports.KnownHyperVGenerationType || (exports.KnownHyperVGenerationType = {}));
/** Known values of {@link PatchOperationStatus} that the service accepts. */
exports.KnownPatchOperationStatus = void 0;
(function (KnownPatchOperationStatus) {
    /** Unknown */
    KnownPatchOperationStatus["Unknown"] = "Unknown";
    /** InProgress */
    KnownPatchOperationStatus["InProgress"] = "InProgress";
    /** Failed */
    KnownPatchOperationStatus["Failed"] = "Failed";
    /** Succeeded */
    KnownPatchOperationStatus["Succeeded"] = "Succeeded";
    /** CompletedWithWarnings */
    KnownPatchOperationStatus["CompletedWithWarnings"] = "CompletedWithWarnings";
})(exports.KnownPatchOperationStatus || (exports.KnownPatchOperationStatus = {}));
/** Known values of {@link VMGuestPatchRebootBehavior} that the service accepts. */
exports.KnownVMGuestPatchRebootBehavior = void 0;
(function (KnownVMGuestPatchRebootBehavior) {
    /** Unknown */
    KnownVMGuestPatchRebootBehavior["Unknown"] = "Unknown";
    /** NeverReboots */
    KnownVMGuestPatchRebootBehavior["NeverReboots"] = "NeverReboots";
    /** AlwaysRequiresReboot */
    KnownVMGuestPatchRebootBehavior["AlwaysRequiresReboot"] = "AlwaysRequiresReboot";
    /** CanRequestReboot */
    KnownVMGuestPatchRebootBehavior["CanRequestReboot"] = "CanRequestReboot";
})(exports.KnownVMGuestPatchRebootBehavior || (exports.KnownVMGuestPatchRebootBehavior = {}));
/** Known values of {@link PatchAssessmentState} that the service accepts. */
exports.KnownPatchAssessmentState = void 0;
(function (KnownPatchAssessmentState) {
    /** Unknown */
    KnownPatchAssessmentState["Unknown"] = "Unknown";
    /** Available */
    KnownPatchAssessmentState["Available"] = "Available";
})(exports.KnownPatchAssessmentState || (exports.KnownPatchAssessmentState = {}));
/** Known values of {@link VMGuestPatchRebootSetting} that the service accepts. */
exports.KnownVMGuestPatchRebootSetting = void 0;
(function (KnownVMGuestPatchRebootSetting) {
    /** IfRequired */
    KnownVMGuestPatchRebootSetting["IfRequired"] = "IfRequired";
    /** Never */
    KnownVMGuestPatchRebootSetting["Never"] = "Never";
    /** Always */
    KnownVMGuestPatchRebootSetting["Always"] = "Always";
})(exports.KnownVMGuestPatchRebootSetting || (exports.KnownVMGuestPatchRebootSetting = {}));
/** Known values of {@link VMGuestPatchClassificationWindows} that the service accepts. */
exports.KnownVMGuestPatchClassificationWindows = void 0;
(function (KnownVMGuestPatchClassificationWindows) {
    /** Critical */
    KnownVMGuestPatchClassificationWindows["Critical"] = "Critical";
    /** Security */
    KnownVMGuestPatchClassificationWindows["Security"] = "Security";
    /** UpdateRollUp */
    KnownVMGuestPatchClassificationWindows["UpdateRollUp"] = "UpdateRollUp";
    /** FeaturePack */
    KnownVMGuestPatchClassificationWindows["FeaturePack"] = "FeaturePack";
    /** ServicePack */
    KnownVMGuestPatchClassificationWindows["ServicePack"] = "ServicePack";
    /** Definition */
    KnownVMGuestPatchClassificationWindows["Definition"] = "Definition";
    /** Tools */
    KnownVMGuestPatchClassificationWindows["Tools"] = "Tools";
    /** Updates */
    KnownVMGuestPatchClassificationWindows["Updates"] = "Updates";
})(exports.KnownVMGuestPatchClassificationWindows || (exports.KnownVMGuestPatchClassificationWindows = {}));
/** Known values of {@link VMGuestPatchClassificationLinux} that the service accepts. */
exports.KnownVMGuestPatchClassificationLinux = void 0;
(function (KnownVMGuestPatchClassificationLinux) {
    /** Critical */
    KnownVMGuestPatchClassificationLinux["Critical"] = "Critical";
    /** Security */
    KnownVMGuestPatchClassificationLinux["Security"] = "Security";
    /** Other */
    KnownVMGuestPatchClassificationLinux["Other"] = "Other";
})(exports.KnownVMGuestPatchClassificationLinux || (exports.KnownVMGuestPatchClassificationLinux = {}));
/** Known values of {@link VMGuestPatchRebootStatus} that the service accepts. */
exports.KnownVMGuestPatchRebootStatus = void 0;
(function (KnownVMGuestPatchRebootStatus) {
    /** Unknown */
    KnownVMGuestPatchRebootStatus["Unknown"] = "Unknown";
    /** NotNeeded */
    KnownVMGuestPatchRebootStatus["NotNeeded"] = "NotNeeded";
    /** Required */
    KnownVMGuestPatchRebootStatus["Required"] = "Required";
    /** Started */
    KnownVMGuestPatchRebootStatus["Started"] = "Started";
    /** Failed */
    KnownVMGuestPatchRebootStatus["Failed"] = "Failed";
    /** Completed */
    KnownVMGuestPatchRebootStatus["Completed"] = "Completed";
})(exports.KnownVMGuestPatchRebootStatus || (exports.KnownVMGuestPatchRebootStatus = {}));
/** Known values of {@link PatchInstallationState} that the service accepts. */
exports.KnownPatchInstallationState = void 0;
(function (KnownPatchInstallationState) {
    /** Unknown */
    KnownPatchInstallationState["Unknown"] = "Unknown";
    /** Installed */
    KnownPatchInstallationState["Installed"] = "Installed";
    /** Failed */
    KnownPatchInstallationState["Failed"] = "Failed";
    /** Excluded */
    KnownPatchInstallationState["Excluded"] = "Excluded";
    /** NotSelected */
    KnownPatchInstallationState["NotSelected"] = "NotSelected";
    /** Pending */
    KnownPatchInstallationState["Pending"] = "Pending";
})(exports.KnownPatchInstallationState || (exports.KnownPatchInstallationState = {}));
/** Known values of {@link HyperVGenerationTypes} that the service accepts. */
exports.KnownHyperVGenerationTypes = void 0;
(function (KnownHyperVGenerationTypes) {
    /** V1 */
    KnownHyperVGenerationTypes["V1"] = "V1";
    /** V2 */
    KnownHyperVGenerationTypes["V2"] = "V2";
})(exports.KnownHyperVGenerationTypes || (exports.KnownHyperVGenerationTypes = {}));
/** Known values of {@link VmDiskTypes} that the service accepts. */
exports.KnownVmDiskTypes = void 0;
(function (KnownVmDiskTypes) {
    /** None */
    KnownVmDiskTypes["None"] = "None";
    /** Unmanaged */
    KnownVmDiskTypes["Unmanaged"] = "Unmanaged";
})(exports.KnownVmDiskTypes || (exports.KnownVmDiskTypes = {}));
/** Known values of {@link ArchitectureTypes} that the service accepts. */
exports.KnownArchitectureTypes = void 0;
(function (KnownArchitectureTypes) {
    /** X64 */
    KnownArchitectureTypes["X64"] = "x64";
    /** Arm64 */
    KnownArchitectureTypes["Arm64"] = "Arm64";
})(exports.KnownArchitectureTypes || (exports.KnownArchitectureTypes = {}));
/** Known values of {@link ProximityPlacementGroupType} that the service accepts. */
exports.KnownProximityPlacementGroupType = void 0;
(function (KnownProximityPlacementGroupType) {
    /** Standard */
    KnownProximityPlacementGroupType["Standard"] = "Standard";
    /** Ultra */
    KnownProximityPlacementGroupType["Ultra"] = "Ultra";
})(exports.KnownProximityPlacementGroupType || (exports.KnownProximityPlacementGroupType = {}));
/** Known values of {@link OperatingSystemType} that the service accepts. */
exports.KnownOperatingSystemType = void 0;
(function (KnownOperatingSystemType) {
    /** Windows */
    KnownOperatingSystemType["Windows"] = "Windows";
    /** Linux */
    KnownOperatingSystemType["Linux"] = "Linux";
})(exports.KnownOperatingSystemType || (exports.KnownOperatingSystemType = {}));
/** Known values of {@link ConsistencyModeTypes} that the service accepts. */
exports.KnownConsistencyModeTypes = void 0;
(function (KnownConsistencyModeTypes) {
    /** CrashConsistent */
    KnownConsistencyModeTypes["CrashConsistent"] = "CrashConsistent";
    /** FileSystemConsistent */
    KnownConsistencyModeTypes["FileSystemConsistent"] = "FileSystemConsistent";
    /** ApplicationConsistent */
    KnownConsistencyModeTypes["ApplicationConsistent"] = "ApplicationConsistent";
})(exports.KnownConsistencyModeTypes || (exports.KnownConsistencyModeTypes = {}));
/** Known values of {@link RestorePointCollectionExpandOptions} that the service accepts. */
exports.KnownRestorePointCollectionExpandOptions = void 0;
(function (KnownRestorePointCollectionExpandOptions) {
    /** RestorePoints */
    KnownRestorePointCollectionExpandOptions["RestorePoints"] = "restorePoints";
})(exports.KnownRestorePointCollectionExpandOptions || (exports.KnownRestorePointCollectionExpandOptions = {}));
/** Known values of {@link RestorePointExpandOptions} that the service accepts. */
exports.KnownRestorePointExpandOptions = void 0;
(function (KnownRestorePointExpandOptions) {
    /** InstanceView */
    KnownRestorePointExpandOptions["InstanceView"] = "instanceView";
})(exports.KnownRestorePointExpandOptions || (exports.KnownRestorePointExpandOptions = {}));
/** Known values of {@link CapacityReservationGroupInstanceViewTypes} that the service accepts. */
exports.KnownCapacityReservationGroupInstanceViewTypes = void 0;
(function (KnownCapacityReservationGroupInstanceViewTypes) {
    /** InstanceView */
    KnownCapacityReservationGroupInstanceViewTypes["InstanceView"] = "instanceView";
})(exports.KnownCapacityReservationGroupInstanceViewTypes || (exports.KnownCapacityReservationGroupInstanceViewTypes = {}));
/** Known values of {@link ExpandTypesForGetCapacityReservationGroups} that the service accepts. */
exports.KnownExpandTypesForGetCapacityReservationGroups = void 0;
(function (KnownExpandTypesForGetCapacityReservationGroups) {
    /** VirtualMachineScaleSetVMsRef */
    KnownExpandTypesForGetCapacityReservationGroups["VirtualMachineScaleSetVMsRef"] = "virtualMachineScaleSetVMs/$ref";
    /** VirtualMachinesRef */
    KnownExpandTypesForGetCapacityReservationGroups["VirtualMachinesRef"] = "virtualMachines/$ref";
})(exports.KnownExpandTypesForGetCapacityReservationGroups || (exports.KnownExpandTypesForGetCapacityReservationGroups = {}));
/** Known values of {@link CapacityReservationInstanceViewTypes} that the service accepts. */
exports.KnownCapacityReservationInstanceViewTypes = void 0;
(function (KnownCapacityReservationInstanceViewTypes) {
    /** InstanceView */
    KnownCapacityReservationInstanceViewTypes["InstanceView"] = "instanceView";
})(exports.KnownCapacityReservationInstanceViewTypes || (exports.KnownCapacityReservationInstanceViewTypes = {}));
/** Known values of {@link ExecutionState} that the service accepts. */
exports.KnownExecutionState = void 0;
(function (KnownExecutionState) {
    /** Unknown */
    KnownExecutionState["Unknown"] = "Unknown";
    /** Pending */
    KnownExecutionState["Pending"] = "Pending";
    /** Running */
    KnownExecutionState["Running"] = "Running";
    /** Failed */
    KnownExecutionState["Failed"] = "Failed";
    /** Succeeded */
    KnownExecutionState["Succeeded"] = "Succeeded";
    /** TimedOut */
    KnownExecutionState["TimedOut"] = "TimedOut";
    /** Canceled */
    KnownExecutionState["Canceled"] = "Canceled";
})(exports.KnownExecutionState || (exports.KnownExecutionState = {}));
/** Known values of {@link DiskStorageAccountTypes} that the service accepts. */
exports.KnownDiskStorageAccountTypes = void 0;
(function (KnownDiskStorageAccountTypes) {
    /** Standard HDD locally redundant storage. Best for backup, non-critical, and infrequent access. */
    KnownDiskStorageAccountTypes["StandardLRS"] = "Standard_LRS";
    /** Premium SSD locally redundant storage. Best for production and performance sensitive workloads. */
    KnownDiskStorageAccountTypes["PremiumLRS"] = "Premium_LRS";
    /** Standard SSD locally redundant storage. Best for web servers, lightly used enterprise applications and dev/test. */
    KnownDiskStorageAccountTypes["StandardSSDLRS"] = "StandardSSD_LRS";
    /** Ultra SSD locally redundant storage. Best for IO-intensive workloads such as SAP HANA, top tier databases (for example, SQL, Oracle), and other transaction-heavy workloads. */
    KnownDiskStorageAccountTypes["UltraSSDLRS"] = "UltraSSD_LRS";
    /** Premium SSD zone redundant storage. Best for the production workloads that need storage resiliency against zone failures. */
    KnownDiskStorageAccountTypes["PremiumZRS"] = "Premium_ZRS";
    /** Standard SSD zone redundant storage. Best for web servers, lightly used enterprise applications and dev/test that need storage resiliency against zone failures. */
    KnownDiskStorageAccountTypes["StandardSSDZRS"] = "StandardSSD_ZRS";
    /** Premium SSD v2 locally redundant storage. Best for production and performance-sensitive workloads that consistently require low latency and high IOPS and throughput. */
    KnownDiskStorageAccountTypes["PremiumV2LRS"] = "PremiumV2_LRS";
})(exports.KnownDiskStorageAccountTypes || (exports.KnownDiskStorageAccountTypes = {}));
/** Known values of {@link HyperVGeneration} that the service accepts. */
exports.KnownHyperVGeneration = void 0;
(function (KnownHyperVGeneration) {
    /** V1 */
    KnownHyperVGeneration["V1"] = "V1";
    /** V2 */
    KnownHyperVGeneration["V2"] = "V2";
})(exports.KnownHyperVGeneration || (exports.KnownHyperVGeneration = {}));
/** Known values of {@link Architecture} that the service accepts. */
exports.KnownArchitecture = void 0;
(function (KnownArchitecture) {
    /** X64 */
    KnownArchitecture["X64"] = "x64";
    /** Arm64 */
    KnownArchitecture["Arm64"] = "Arm64";
})(exports.KnownArchitecture || (exports.KnownArchitecture = {}));
/** Known values of {@link DiskCreateOption} that the service accepts. */
exports.KnownDiskCreateOption = void 0;
(function (KnownDiskCreateOption) {
    /** Create an empty data disk of a size given by diskSizeGB. */
    KnownDiskCreateOption["Empty"] = "Empty";
    /** Disk will be attached to a VM. */
    KnownDiskCreateOption["Attach"] = "Attach";
    /** Create a new disk from a platform image specified by the given imageReference or galleryImageReference. */
    KnownDiskCreateOption["FromImage"] = "FromImage";
    /** Create a disk by importing from a blob specified by a sourceUri in a storage account specified by storageAccountId. */
    KnownDiskCreateOption["Import"] = "Import";
    /** Create a new disk or snapshot by copying from a disk or snapshot specified by the given sourceResourceId. */
    KnownDiskCreateOption["Copy"] = "Copy";
    /** Create a new disk by copying from a backup recovery point. */
    KnownDiskCreateOption["Restore"] = "Restore";
    /** Create a new disk by obtaining a write token and using it to directly upload the contents of the disk. */
    KnownDiskCreateOption["Upload"] = "Upload";
    /** Create a new disk by using a deep copy process, where the resource creation is considered complete only after all data has been copied from the source. */
    KnownDiskCreateOption["CopyStart"] = "CopyStart";
    /** Similar to Import create option. Create a new Trusted Launch VM or Confidential VM supported disk by importing additional blob for VM guest state specified by securityDataUri in storage account specified by storageAccountId */
    KnownDiskCreateOption["ImportSecure"] = "ImportSecure";
    /** Similar to Upload create option. Create a new Trusted Launch VM or Confidential VM supported disk and upload using write token in both disk and VM guest state */
    KnownDiskCreateOption["UploadPreparedSecure"] = "UploadPreparedSecure";
})(exports.KnownDiskCreateOption || (exports.KnownDiskCreateOption = {}));
/** Known values of {@link DiskState} that the service accepts. */
exports.KnownDiskState = void 0;
(function (KnownDiskState) {
    /** The disk is not being used and can be attached to a VM. */
    KnownDiskState["Unattached"] = "Unattached";
    /** The disk is currently attached to a running VM. */
    KnownDiskState["Attached"] = "Attached";
    /** The disk is attached to a stopped-deallocated VM. */
    KnownDiskState["Reserved"] = "Reserved";
    /** The disk is attached to a VM which is in hibernated state. */
    KnownDiskState["Frozen"] = "Frozen";
    /** The disk currently has an Active SAS Uri associated with it. */
    KnownDiskState["ActiveSAS"] = "ActiveSAS";
    /** The disk is attached to a VM in hibernated state and has an active SAS URI associated with it. */
    KnownDiskState["ActiveSASFrozen"] = "ActiveSASFrozen";
    /** A disk is ready to be created by upload by requesting a write token. */
    KnownDiskState["ReadyToUpload"] = "ReadyToUpload";
    /** A disk is created for upload and a write token has been issued for uploading to it. */
    KnownDiskState["ActiveUpload"] = "ActiveUpload";
})(exports.KnownDiskState || (exports.KnownDiskState = {}));
/** Known values of {@link EncryptionType} that the service accepts. */
exports.KnownEncryptionType = void 0;
(function (KnownEncryptionType) {
    /** Disk is encrypted at rest with Platform managed key. It is the default encryption type. This is not a valid encryption type for disk encryption sets. */
    KnownEncryptionType["EncryptionAtRestWithPlatformKey"] = "EncryptionAtRestWithPlatformKey";
    /** Disk is encrypted at rest with Customer managed key that can be changed and revoked by a customer. */
    KnownEncryptionType["EncryptionAtRestWithCustomerKey"] = "EncryptionAtRestWithCustomerKey";
    /** Disk is encrypted at rest with 2 layers of encryption. One of the keys is Customer managed and the other key is Platform managed. */
    KnownEncryptionType["EncryptionAtRestWithPlatformAndCustomerKeys"] = "EncryptionAtRestWithPlatformAndCustomerKeys";
})(exports.KnownEncryptionType || (exports.KnownEncryptionType = {}));
/** Known values of {@link NetworkAccessPolicy} that the service accepts. */
exports.KnownNetworkAccessPolicy = void 0;
(function (KnownNetworkAccessPolicy) {
    /** The disk can be exported or uploaded to from any network. */
    KnownNetworkAccessPolicy["AllowAll"] = "AllowAll";
    /** The disk can be exported or uploaded to using a DiskAccess resource's private endpoints. */
    KnownNetworkAccessPolicy["AllowPrivate"] = "AllowPrivate";
    /** The disk cannot be exported. */
    KnownNetworkAccessPolicy["DenyAll"] = "DenyAll";
})(exports.KnownNetworkAccessPolicy || (exports.KnownNetworkAccessPolicy = {}));
/** Known values of {@link DiskSecurityTypes} that the service accepts. */
exports.KnownDiskSecurityTypes = void 0;
(function (KnownDiskSecurityTypes) {
    /** Trusted Launch provides security features such as secure boot and virtual Trusted Platform Module (vTPM) */
    KnownDiskSecurityTypes["TrustedLaunch"] = "TrustedLaunch";
    /** Indicates Confidential VM disk with only VM guest state encrypted */
    KnownDiskSecurityTypes["ConfidentialVMVmguestStateOnlyEncryptedWithPlatformKey"] = "ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey";
    /** Indicates Confidential VM disk with both OS disk and VM guest state encrypted with a platform managed key */
    KnownDiskSecurityTypes["ConfidentialVMDiskEncryptedWithPlatformKey"] = "ConfidentialVM_DiskEncryptedWithPlatformKey";
    /** Indicates Confidential VM disk with both OS disk and VM guest state encrypted with a customer managed key */
    KnownDiskSecurityTypes["ConfidentialVMDiskEncryptedWithCustomerKey"] = "ConfidentialVM_DiskEncryptedWithCustomerKey";
})(exports.KnownDiskSecurityTypes || (exports.KnownDiskSecurityTypes = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** You can generate a SAS URI to access the underlying data of the disk publicly on the internet when NetworkAccessPolicy is set to AllowAll. You can access the data via the SAS URI only from your trusted Azure VNET when NetworkAccessPolicy is set to AllowPrivate. */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** You cannot access the underlying data of the disk publicly on the internet even when NetworkAccessPolicy is set to AllowAll. You can access the data via the SAS URI only from your trusted Azure VNET when NetworkAccessPolicy is set to AllowPrivate. */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link DataAccessAuthMode} that the service accepts. */
exports.KnownDataAccessAuthMode = void 0;
(function (KnownDataAccessAuthMode) {
    /** When export/upload URL is used, the system checks if the user has an identity in Azure Active Directory and has necessary permissions to export/upload the data. Please refer to aka.ms/DisksAzureADAuth. */
    KnownDataAccessAuthMode["AzureActiveDirectory"] = "AzureActiveDirectory";
    /** No additional authentication would be performed when accessing export/upload URL. */
    KnownDataAccessAuthMode["None"] = "None";
})(exports.KnownDataAccessAuthMode || (exports.KnownDataAccessAuthMode = {}));
/** Known values of {@link AccessLevel} that the service accepts. */
exports.KnownAccessLevel = void 0;
(function (KnownAccessLevel) {
    /** None */
    KnownAccessLevel["None"] = "None";
    /** Read */
    KnownAccessLevel["Read"] = "Read";
    /** Write */
    KnownAccessLevel["Write"] = "Write";
})(exports.KnownAccessLevel || (exports.KnownAccessLevel = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link DiskEncryptionSetIdentityType} that the service accepts. */
exports.KnownDiskEncryptionSetIdentityType = void 0;
(function (KnownDiskEncryptionSetIdentityType) {
    /** SystemAssigned */
    KnownDiskEncryptionSetIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownDiskEncryptionSetIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownDiskEncryptionSetIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned, UserAssigned";
    /** None */
    KnownDiskEncryptionSetIdentityType["None"] = "None";
})(exports.KnownDiskEncryptionSetIdentityType || (exports.KnownDiskEncryptionSetIdentityType = {}));
/** Known values of {@link DiskEncryptionSetType} that the service accepts. */
exports.KnownDiskEncryptionSetType = void 0;
(function (KnownDiskEncryptionSetType) {
    /** Resource using diskEncryptionSet would be encrypted at rest with Customer managed key that can be changed and revoked by a customer. */
    KnownDiskEncryptionSetType["EncryptionAtRestWithCustomerKey"] = "EncryptionAtRestWithCustomerKey";
    /** Resource using diskEncryptionSet would be encrypted at rest with two layers of encryption. One of the keys is Customer managed and the other key is Platform managed. */
    KnownDiskEncryptionSetType["EncryptionAtRestWithPlatformAndCustomerKeys"] = "EncryptionAtRestWithPlatformAndCustomerKeys";
    /** Confidential VM supported disk and VM guest state would be encrypted with customer managed key. */
    KnownDiskEncryptionSetType["ConfidentialVmEncryptedWithCustomerKey"] = "ConfidentialVmEncryptedWithCustomerKey";
})(exports.KnownDiskEncryptionSetType || (exports.KnownDiskEncryptionSetType = {}));
/** Known values of {@link SnapshotStorageAccountTypes} that the service accepts. */
exports.KnownSnapshotStorageAccountTypes = void 0;
(function (KnownSnapshotStorageAccountTypes) {
    /** Standard HDD locally redundant storage */
    KnownSnapshotStorageAccountTypes["StandardLRS"] = "Standard_LRS";
    /** Premium SSD locally redundant storage */
    KnownSnapshotStorageAccountTypes["PremiumLRS"] = "Premium_LRS";
    /** Standard zone redundant storage */
    KnownSnapshotStorageAccountTypes["StandardZRS"] = "Standard_ZRS";
})(exports.KnownSnapshotStorageAccountTypes || (exports.KnownSnapshotStorageAccountTypes = {}));
/** Known values of {@link CopyCompletionErrorReason} that the service accepts. */
exports.KnownCopyCompletionErrorReason = void 0;
(function (KnownCopyCompletionErrorReason) {
    /** Indicates that the source snapshot was deleted while the background copy of the resource created via CopyStart operation was in progress. */
    KnownCopyCompletionErrorReason["CopySourceNotFound"] = "CopySourceNotFound";
})(exports.KnownCopyCompletionErrorReason || (exports.KnownCopyCompletionErrorReason = {}));
/** Known values of {@link ExtendedLocationType} that the service accepts. */
exports.KnownExtendedLocationType = void 0;
(function (KnownExtendedLocationType) {
    /** EdgeZone */
    KnownExtendedLocationType["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationType || (exports.KnownExtendedLocationType = {}));
/** Known values of {@link GalleryProvisioningState} that the service accepts. */
exports.KnownGalleryProvisioningState = void 0;
(function (KnownGalleryProvisioningState) {
    /** Creating */
    KnownGalleryProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownGalleryProvisioningState["Updating"] = "Updating";
    /** Failed */
    KnownGalleryProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownGalleryProvisioningState["Succeeded"] = "Succeeded";
    /** Deleting */
    KnownGalleryProvisioningState["Deleting"] = "Deleting";
    /** Migrating */
    KnownGalleryProvisioningState["Migrating"] = "Migrating";
})(exports.KnownGalleryProvisioningState || (exports.KnownGalleryProvisioningState = {}));
/** Known values of {@link GallerySharingPermissionTypes} that the service accepts. */
exports.KnownGallerySharingPermissionTypes = void 0;
(function (KnownGallerySharingPermissionTypes) {
    /** Private */
    KnownGallerySharingPermissionTypes["Private"] = "Private";
    /** Groups */
    KnownGallerySharingPermissionTypes["Groups"] = "Groups";
    /** Community */
    KnownGallerySharingPermissionTypes["Community"] = "Community";
})(exports.KnownGallerySharingPermissionTypes || (exports.KnownGallerySharingPermissionTypes = {}));
/** Known values of {@link SharingProfileGroupTypes} that the service accepts. */
exports.KnownSharingProfileGroupTypes = void 0;
(function (KnownSharingProfileGroupTypes) {
    /** Subscriptions */
    KnownSharingProfileGroupTypes["Subscriptions"] = "Subscriptions";
    /** AADTenants */
    KnownSharingProfileGroupTypes["AADTenants"] = "AADTenants";
})(exports.KnownSharingProfileGroupTypes || (exports.KnownSharingProfileGroupTypes = {}));
/** Known values of {@link SharingState} that the service accepts. */
exports.KnownSharingState = void 0;
(function (KnownSharingState) {
    /** Succeeded */
    KnownSharingState["Succeeded"] = "Succeeded";
    /** InProgress */
    KnownSharingState["InProgress"] = "InProgress";
    /** Failed */
    KnownSharingState["Failed"] = "Failed";
    /** Unknown */
    KnownSharingState["Unknown"] = "Unknown";
})(exports.KnownSharingState || (exports.KnownSharingState = {}));
/** Known values of {@link SelectPermissions} that the service accepts. */
exports.KnownSelectPermissions = void 0;
(function (KnownSelectPermissions) {
    /** Permissions */
    KnownSelectPermissions["Permissions"] = "Permissions";
})(exports.KnownSelectPermissions || (exports.KnownSelectPermissions = {}));
/** Known values of {@link GalleryExpandParams} that the service accepts. */
exports.KnownGalleryExpandParams = void 0;
(function (KnownGalleryExpandParams) {
    /** SharingProfileGroups */
    KnownGalleryExpandParams["SharingProfileGroups"] = "SharingProfile/Groups";
})(exports.KnownGalleryExpandParams || (exports.KnownGalleryExpandParams = {}));
/** Known values of {@link StorageAccountType} that the service accepts. */
exports.KnownStorageAccountType = void 0;
(function (KnownStorageAccountType) {
    /** StandardLRS */
    KnownStorageAccountType["StandardLRS"] = "Standard_LRS";
    /** StandardZRS */
    KnownStorageAccountType["StandardZRS"] = "Standard_ZRS";
    /** PremiumLRS */
    KnownStorageAccountType["PremiumLRS"] = "Premium_LRS";
})(exports.KnownStorageAccountType || (exports.KnownStorageAccountType = {}));
/** Known values of {@link ConfidentialVMEncryptionType} that the service accepts. */
exports.KnownConfidentialVMEncryptionType = void 0;
(function (KnownConfidentialVMEncryptionType) {
    /** EncryptedVMGuestStateOnlyWithPmk */
    KnownConfidentialVMEncryptionType["EncryptedVMGuestStateOnlyWithPmk"] = "EncryptedVMGuestStateOnlyWithPmk";
    /** EncryptedWithPmk */
    KnownConfidentialVMEncryptionType["EncryptedWithPmk"] = "EncryptedWithPmk";
    /** EncryptedWithCmk */
    KnownConfidentialVMEncryptionType["EncryptedWithCmk"] = "EncryptedWithCmk";
})(exports.KnownConfidentialVMEncryptionType || (exports.KnownConfidentialVMEncryptionType = {}));
/** Known values of {@link ReplicationMode} that the service accepts. */
exports.KnownReplicationMode = void 0;
(function (KnownReplicationMode) {
    /** Full */
    KnownReplicationMode["Full"] = "Full";
    /** Shallow */
    KnownReplicationMode["Shallow"] = "Shallow";
})(exports.KnownReplicationMode || (exports.KnownReplicationMode = {}));
/** Known values of {@link GalleryExtendedLocationType} that the service accepts. */
exports.KnownGalleryExtendedLocationType = void 0;
(function (KnownGalleryExtendedLocationType) {
    /** EdgeZone */
    KnownGalleryExtendedLocationType["EdgeZone"] = "EdgeZone";
    /** Unknown */
    KnownGalleryExtendedLocationType["Unknown"] = "Unknown";
})(exports.KnownGalleryExtendedLocationType || (exports.KnownGalleryExtendedLocationType = {}));
/** Known values of {@link AggregatedReplicationState} that the service accepts. */
exports.KnownAggregatedReplicationState = void 0;
(function (KnownAggregatedReplicationState) {
    /** Unknown */
    KnownAggregatedReplicationState["Unknown"] = "Unknown";
    /** InProgress */
    KnownAggregatedReplicationState["InProgress"] = "InProgress";
    /** Completed */
    KnownAggregatedReplicationState["Completed"] = "Completed";
    /** Failed */
    KnownAggregatedReplicationState["Failed"] = "Failed";
})(exports.KnownAggregatedReplicationState || (exports.KnownAggregatedReplicationState = {}));
/** Known values of {@link ReplicationState} that the service accepts. */
exports.KnownReplicationState = void 0;
(function (KnownReplicationState) {
    /** Unknown */
    KnownReplicationState["Unknown"] = "Unknown";
    /** Replicating */
    KnownReplicationState["Replicating"] = "Replicating";
    /** Completed */
    KnownReplicationState["Completed"] = "Completed";
    /** Failed */
    KnownReplicationState["Failed"] = "Failed";
})(exports.KnownReplicationState || (exports.KnownReplicationState = {}));
/** Known values of {@link ReplicationStatusTypes} that the service accepts. */
exports.KnownReplicationStatusTypes = void 0;
(function (KnownReplicationStatusTypes) {
    /** ReplicationStatus */
    KnownReplicationStatusTypes["ReplicationStatus"] = "ReplicationStatus";
})(exports.KnownReplicationStatusTypes || (exports.KnownReplicationStatusTypes = {}));
/** Known values of {@link SharingUpdateOperationTypes} that the service accepts. */
exports.KnownSharingUpdateOperationTypes = void 0;
(function (KnownSharingUpdateOperationTypes) {
    /** Add */
    KnownSharingUpdateOperationTypes["Add"] = "Add";
    /** Remove */
    KnownSharingUpdateOperationTypes["Remove"] = "Remove";
    /** Reset */
    KnownSharingUpdateOperationTypes["Reset"] = "Reset";
    /** EnableCommunity */
    KnownSharingUpdateOperationTypes["EnableCommunity"] = "EnableCommunity";
})(exports.KnownSharingUpdateOperationTypes || (exports.KnownSharingUpdateOperationTypes = {}));
/** Known values of {@link SharedToValues} that the service accepts. */
exports.KnownSharedToValues = void 0;
(function (KnownSharedToValues) {
    /** Tenant */
    KnownSharedToValues["Tenant"] = "tenant";
})(exports.KnownSharedToValues || (exports.KnownSharedToValues = {}));
/** Known values of {@link SharedGalleryHostCaching} that the service accepts. */
exports.KnownSharedGalleryHostCaching = void 0;
(function (KnownSharedGalleryHostCaching) {
    /** None */
    KnownSharedGalleryHostCaching["None"] = "None";
    /** ReadOnly */
    KnownSharedGalleryHostCaching["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownSharedGalleryHostCaching["ReadWrite"] = "ReadWrite";
})(exports.KnownSharedGalleryHostCaching || (exports.KnownSharedGalleryHostCaching = {}));
/** Known values of {@link CloudServiceUpgradeMode} that the service accepts. */
exports.KnownCloudServiceUpgradeMode = void 0;
(function (KnownCloudServiceUpgradeMode) {
    /** Auto */
    KnownCloudServiceUpgradeMode["Auto"] = "Auto";
    /** Manual */
    KnownCloudServiceUpgradeMode["Manual"] = "Manual";
    /** Simultaneous */
    KnownCloudServiceUpgradeMode["Simultaneous"] = "Simultaneous";
})(exports.KnownCloudServiceUpgradeMode || (exports.KnownCloudServiceUpgradeMode = {}));
/** Known values of {@link CloudServiceSlotType} that the service accepts. */
exports.KnownCloudServiceSlotType = void 0;
(function (KnownCloudServiceSlotType) {
    /** Production */
    KnownCloudServiceSlotType["Production"] = "Production";
    /** Staging */
    KnownCloudServiceSlotType["Staging"] = "Staging";
})(exports.KnownCloudServiceSlotType || (exports.KnownCloudServiceSlotType = {}));
/** Known values of {@link AvailabilitySetSkuTypes} that the service accepts. */
exports.KnownAvailabilitySetSkuTypes = void 0;
(function (KnownAvailabilitySetSkuTypes) {
    /** Classic */
    KnownAvailabilitySetSkuTypes["Classic"] = "Classic";
    /** Aligned */
    KnownAvailabilitySetSkuTypes["Aligned"] = "Aligned";
})(exports.KnownAvailabilitySetSkuTypes || (exports.KnownAvailabilitySetSkuTypes = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ComputeOperationListResult = {
    type: {
        name: "Composite",
        className: "ComputeOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeOperationValue"
                        }
                    }
                }
            }
        }
    }
};
const ComputeOperationValue = {
    type: {
        name: "Composite",
        className: "ComputeOperationValue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "display.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "display.resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "display.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "display.provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const ApiError = {
    type: {
        name: "Composite",
        className: "ApiError",
        modelProperties: {
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiErrorBase"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiErrorBase = {
    type: {
        name: "Composite",
        className: "ApiErrorBase",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            exceptiontype: {
                serializedName: "exceptiontype",
                type: {
                    name: "String"
                }
            },
            errordetail: {
                serializedName: "errordetail",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListUsagesResult = {
    type: {
        name: "Composite",
        className: "ListUsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            unit: {
                defaultValue: "Count",
                isConstant: true,
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineSizeListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineSizeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineSize"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineSize = {
    type: {
        name: "Composite",
        className: "VirtualMachineSize",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            numberOfCores: {
                serializedName: "numberOfCores",
                type: {
                    name: "Number"
                }
            },
            osDiskSizeInMB: {
                serializedName: "osDiskSizeInMB",
                type: {
                    name: "Number"
                }
            },
            resourceDiskSizeInMB: {
                serializedName: "resourceDiskSizeInMB",
                type: {
                    name: "Number"
                }
            },
            memoryInMB: {
                serializedName: "memoryInMB",
                type: {
                    name: "Number"
                }
            },
            maxDataDiskCount: {
                serializedName: "maxDataDiskCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachineScaleSetListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Plan = {
    type: {
        name: "Composite",
        className: "Plan",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                type: {
                    name: "String"
                }
            },
            promotionCode: {
                serializedName: "promotionCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpgradePolicy = {
    type: {
        name: "Composite",
        className: "UpgradePolicy",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "Enum",
                    allowedValues: ["Automatic", "Manual", "Rolling"]
                }
            },
            rollingUpgradePolicy: {
                serializedName: "rollingUpgradePolicy",
                type: {
                    name: "Composite",
                    className: "RollingUpgradePolicy"
                }
            },
            automaticOSUpgradePolicy: {
                serializedName: "automaticOSUpgradePolicy",
                type: {
                    name: "Composite",
                    className: "AutomaticOSUpgradePolicy"
                }
            }
        }
    }
};
const RollingUpgradePolicy = {
    type: {
        name: "Composite",
        className: "RollingUpgradePolicy",
        modelProperties: {
            maxBatchInstancePercent: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 5
                },
                serializedName: "maxBatchInstancePercent",
                type: {
                    name: "Number"
                }
            },
            maxUnhealthyInstancePercent: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 5
                },
                serializedName: "maxUnhealthyInstancePercent",
                type: {
                    name: "Number"
                }
            },
            maxUnhealthyUpgradedInstancePercent: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxUnhealthyUpgradedInstancePercent",
                type: {
                    name: "Number"
                }
            },
            pauseTimeBetweenBatches: {
                serializedName: "pauseTimeBetweenBatches",
                type: {
                    name: "String"
                }
            },
            enableCrossZoneUpgrade: {
                serializedName: "enableCrossZoneUpgrade",
                type: {
                    name: "Boolean"
                }
            },
            prioritizeUnhealthyInstances: {
                serializedName: "prioritizeUnhealthyInstances",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AutomaticOSUpgradePolicy = {
    type: {
        name: "Composite",
        className: "AutomaticOSUpgradePolicy",
        modelProperties: {
            enableAutomaticOSUpgrade: {
                serializedName: "enableAutomaticOSUpgrade",
                type: {
                    name: "Boolean"
                }
            },
            disableAutomaticRollback: {
                serializedName: "disableAutomaticRollback",
                type: {
                    name: "Boolean"
                }
            },
            useRollingUpgradePolicy: {
                serializedName: "useRollingUpgradePolicy",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AutomaticRepairsPolicy = {
    type: {
        name: "Composite",
        className: "AutomaticRepairsPolicy",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            gracePeriod: {
                serializedName: "gracePeriod",
                type: {
                    name: "String"
                }
            },
            repairAction: {
                serializedName: "repairAction",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMProfile",
        modelProperties: {
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetOSProfile"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetStorageProfile"
                }
            },
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetNetworkProfile"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            diagnosticsProfile: {
                serializedName: "diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            },
            extensionProfile: {
                serializedName: "extensionProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetExtensionProfile"
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "String"
                }
            },
            evictionPolicy: {
                serializedName: "evictionPolicy",
                type: {
                    name: "String"
                }
            },
            billingProfile: {
                serializedName: "billingProfile",
                type: {
                    name: "Composite",
                    className: "BillingProfile"
                }
            },
            scheduledEventsProfile: {
                serializedName: "scheduledEventsProfile",
                type: {
                    name: "Composite",
                    className: "ScheduledEventsProfile"
                }
            },
            userData: {
                serializedName: "userData",
                type: {
                    name: "String"
                }
            },
            capacityReservation: {
                serializedName: "capacityReservation",
                type: {
                    name: "Composite",
                    className: "CapacityReservationProfile"
                }
            },
            applicationProfile: {
                serializedName: "applicationProfile",
                type: {
                    name: "Composite",
                    className: "ApplicationProfile"
                }
            },
            hardwareProfile: {
                serializedName: "hardwareProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetHardwareProfile"
                }
            }
        }
    }
};
const VirtualMachineScaleSetOSProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetOSProfile",
        modelProperties: {
            computerNamePrefix: {
                serializedName: "computerNamePrefix",
                type: {
                    name: "String"
                }
            },
            adminUsername: {
                serializedName: "adminUsername",
                type: {
                    name: "String"
                }
            },
            adminPassword: {
                serializedName: "adminPassword",
                type: {
                    name: "String"
                }
            },
            customData: {
                serializedName: "customData",
                type: {
                    name: "String"
                }
            },
            windowsConfiguration: {
                serializedName: "windowsConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsConfiguration"
                }
            },
            linuxConfiguration: {
                serializedName: "linuxConfiguration",
                type: {
                    name: "Composite",
                    className: "LinuxConfiguration"
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VaultSecretGroup"
                        }
                    }
                }
            },
            allowExtensionOperations: {
                serializedName: "allowExtensionOperations",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const WindowsConfiguration = {
    type: {
        name: "Composite",
        className: "WindowsConfiguration",
        modelProperties: {
            provisionVMAgent: {
                serializedName: "provisionVMAgent",
                type: {
                    name: "Boolean"
                }
            },
            enableAutomaticUpdates: {
                serializedName: "enableAutomaticUpdates",
                type: {
                    name: "Boolean"
                }
            },
            timeZone: {
                serializedName: "timeZone",
                type: {
                    name: "String"
                }
            },
            additionalUnattendContent: {
                serializedName: "additionalUnattendContent",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdditionalUnattendContent"
                        }
                    }
                }
            },
            patchSettings: {
                serializedName: "patchSettings",
                type: {
                    name: "Composite",
                    className: "PatchSettings"
                }
            },
            winRM: {
                serializedName: "winRM",
                type: {
                    name: "Composite",
                    className: "WinRMConfiguration"
                }
            },
            enableVMAgentPlatformUpdates: {
                serializedName: "enableVMAgentPlatformUpdates",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AdditionalUnattendContent = {
    type: {
        name: "Composite",
        className: "AdditionalUnattendContent",
        modelProperties: {
            passName: {
                defaultValue: "OobeSystem",
                isConstant: true,
                serializedName: "passName",
                type: {
                    name: "String"
                }
            },
            componentName: {
                defaultValue: "Microsoft-Windows-Shell-Setup",
                isConstant: true,
                serializedName: "componentName",
                type: {
                    name: "String"
                }
            },
            settingName: {
                serializedName: "settingName",
                type: {
                    name: "Enum",
                    allowedValues: ["AutoLogon", "FirstLogonCommands"]
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PatchSettings = {
    type: {
        name: "Composite",
        className: "PatchSettings",
        modelProperties: {
            patchMode: {
                serializedName: "patchMode",
                type: {
                    name: "String"
                }
            },
            enableHotpatching: {
                serializedName: "enableHotpatching",
                type: {
                    name: "Boolean"
                }
            },
            assessmentMode: {
                serializedName: "assessmentMode",
                type: {
                    name: "String"
                }
            },
            automaticByPlatformSettings: {
                serializedName: "automaticByPlatformSettings",
                type: {
                    name: "Composite",
                    className: "WindowsVMGuestPatchAutomaticByPlatformSettings"
                }
            }
        }
    }
};
const WindowsVMGuestPatchAutomaticByPlatformSettings = {
    type: {
        name: "Composite",
        className: "WindowsVMGuestPatchAutomaticByPlatformSettings",
        modelProperties: {
            rebootSetting: {
                serializedName: "rebootSetting",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WinRMConfiguration = {
    type: {
        name: "Composite",
        className: "WinRMConfiguration",
        modelProperties: {
            listeners: {
                serializedName: "listeners",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WinRMListener"
                        }
                    }
                }
            }
        }
    }
};
const WinRMListener = {
    type: {
        name: "Composite",
        className: "WinRMListener",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "Enum",
                    allowedValues: ["Http", "Https"]
                }
            },
            certificateUrl: {
                serializedName: "certificateUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinuxConfiguration = {
    type: {
        name: "Composite",
        className: "LinuxConfiguration",
        modelProperties: {
            disablePasswordAuthentication: {
                serializedName: "disablePasswordAuthentication",
                type: {
                    name: "Boolean"
                }
            },
            ssh: {
                serializedName: "ssh",
                type: {
                    name: "Composite",
                    className: "SshConfiguration"
                }
            },
            provisionVMAgent: {
                serializedName: "provisionVMAgent",
                type: {
                    name: "Boolean"
                }
            },
            patchSettings: {
                serializedName: "patchSettings",
                type: {
                    name: "Composite",
                    className: "LinuxPatchSettings"
                }
            },
            enableVMAgentPlatformUpdates: {
                serializedName: "enableVMAgentPlatformUpdates",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SshConfiguration = {
    type: {
        name: "Composite",
        className: "SshConfiguration",
        modelProperties: {
            publicKeys: {
                serializedName: "publicKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SshPublicKey"
                        }
                    }
                }
            }
        }
    }
};
const SshPublicKey = {
    type: {
        name: "Composite",
        className: "SshPublicKey",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            keyData: {
                serializedName: "keyData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinuxPatchSettings = {
    type: {
        name: "Composite",
        className: "LinuxPatchSettings",
        modelProperties: {
            patchMode: {
                serializedName: "patchMode",
                type: {
                    name: "String"
                }
            },
            assessmentMode: {
                serializedName: "assessmentMode",
                type: {
                    name: "String"
                }
            },
            automaticByPlatformSettings: {
                serializedName: "automaticByPlatformSettings",
                type: {
                    name: "Composite",
                    className: "LinuxVMGuestPatchAutomaticByPlatformSettings"
                }
            }
        }
    }
};
const LinuxVMGuestPatchAutomaticByPlatformSettings = {
    type: {
        name: "Composite",
        className: "LinuxVMGuestPatchAutomaticByPlatformSettings",
        modelProperties: {
            rebootSetting: {
                serializedName: "rebootSetting",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultSecretGroup = {
    type: {
        name: "Composite",
        className: "VaultSecretGroup",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            vaultCertificates: {
                serializedName: "vaultCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VaultCertificate"
                        }
                    }
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultCertificate = {
    type: {
        name: "Composite",
        className: "VaultCertificate",
        modelProperties: {
            certificateUrl: {
                serializedName: "certificateUrl",
                type: {
                    name: "String"
                }
            },
            certificateStore: {
                serializedName: "certificateStore",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetStorageProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetStorageProfile",
        modelProperties: {
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetOSDisk"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetDataDisk"
                        }
                    }
                }
            },
            diskControllerType: {
                serializedName: "diskControllerType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetOSDisk = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetOSDisk",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            },
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            diffDiskSettings: {
                serializedName: "diffDiskSettings",
                type: {
                    name: "Composite",
                    className: "DiffDiskSettings"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            vhdContainers: {
                serializedName: "vhdContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetManagedDiskParameters"
                }
            },
            deleteOption: {
                serializedName: "deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiffDiskSettings = {
    type: {
        name: "Composite",
        className: "DiffDiskSettings",
        modelProperties: {
            option: {
                serializedName: "option",
                type: {
                    name: "String"
                }
            },
            placement: {
                serializedName: "placement",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHardDisk = {
    type: {
        name: "Composite",
        className: "VirtualHardDisk",
        modelProperties: {
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetManagedDiskParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetManagedDiskParameters",
        modelProperties: {
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            },
            diskEncryptionSet: {
                serializedName: "diskEncryptionSet",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSetParameters"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "VMDiskSecurityProfile"
                }
            }
        }
    }
};
const VMDiskSecurityProfile = {
    type: {
        name: "Composite",
        className: "VMDiskSecurityProfile",
        modelProperties: {
            securityEncryptionType: {
                serializedName: "securityEncryptionType",
                type: {
                    name: "String"
                }
            },
            diskEncryptionSet: {
                serializedName: "diskEncryptionSet",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSetParameters"
                }
            }
        }
    }
};
const VirtualMachineScaleSetDataDisk = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetDataDisk",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            },
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetManagedDiskParameters"
                }
            },
            diskIopsReadWrite: {
                serializedName: "diskIOPSReadWrite",
                type: {
                    name: "Number"
                }
            },
            diskMBpsReadWrite: {
                serializedName: "diskMBpsReadWrite",
                type: {
                    name: "Number"
                }
            },
            deleteOption: {
                serializedName: "deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetNetworkProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetNetworkProfile",
        modelProperties: {
            healthProbe: {
                serializedName: "healthProbe",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            },
            networkInterfaceConfigurations: {
                serializedName: "networkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetNetworkConfiguration"
                        }
                    }
                }
            },
            networkApiVersion: {
                serializedName: "networkApiVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiEntityReference = {
    type: {
        name: "Composite",
        className: "ApiEntityReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetNetworkConfigurationDnsSettings = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetNetworkConfigurationDnsSettings",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetPublicIPAddressConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetPublicIPAddressConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressSku"
                }
            },
            idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            },
            dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings"
                }
            },
            ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetIpTag"
                        }
                    }
                }
            },
            publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            },
            deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings",
        modelProperties: {
            domainNameLabel: {
                serializedName: "domainNameLabel",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetIpTag = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetIpTag",
        modelProperties: {
            ipTagType: {
                serializedName: "ipTagType",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressSku = {
    type: {
        name: "Composite",
        className: "PublicIPAddressSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityProfile = {
    type: {
        name: "Composite",
        className: "SecurityProfile",
        modelProperties: {
            uefiSettings: {
                serializedName: "uefiSettings",
                type: {
                    name: "Composite",
                    className: "UefiSettings"
                }
            },
            encryptionAtHost: {
                serializedName: "encryptionAtHost",
                type: {
                    name: "Boolean"
                }
            },
            securityType: {
                serializedName: "securityType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UefiSettings = {
    type: {
        name: "Composite",
        className: "UefiSettings",
        modelProperties: {
            secureBootEnabled: {
                serializedName: "secureBootEnabled",
                type: {
                    name: "Boolean"
                }
            },
            vTpmEnabled: {
                serializedName: "vTpmEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DiagnosticsProfile = {
    type: {
        name: "Composite",
        className: "DiagnosticsProfile",
        modelProperties: {
            bootDiagnostics: {
                serializedName: "bootDiagnostics",
                type: {
                    name: "Composite",
                    className: "BootDiagnostics"
                }
            }
        }
    }
};
const BootDiagnostics = {
    type: {
        name: "Composite",
        className: "BootDiagnostics",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            storageUri: {
                serializedName: "storageUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetExtensionProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetExtensionProfile",
        modelProperties: {
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetExtension"
                        }
                    }
                }
            },
            extensionsTimeBudget: {
                serializedName: "extensionsTimeBudget",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultSecretReference = {
    type: {
        name: "Composite",
        className: "KeyVaultSecretReference",
        modelProperties: {
            secretUrl: {
                serializedName: "secretUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const SubResourceReadOnly = {
    type: {
        name: "Composite",
        className: "SubResourceReadOnly",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BillingProfile = {
    type: {
        name: "Composite",
        className: "BillingProfile",
        modelProperties: {
            maxPrice: {
                serializedName: "maxPrice",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ScheduledEventsProfile = {
    type: {
        name: "Composite",
        className: "ScheduledEventsProfile",
        modelProperties: {
            terminateNotificationProfile: {
                serializedName: "terminateNotificationProfile",
                type: {
                    name: "Composite",
                    className: "TerminateNotificationProfile"
                }
            }
        }
    }
};
const TerminateNotificationProfile = {
    type: {
        name: "Composite",
        className: "TerminateNotificationProfile",
        modelProperties: {
            notBeforeTimeout: {
                serializedName: "notBeforeTimeout",
                type: {
                    name: "String"
                }
            },
            enable: {
                serializedName: "enable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CapacityReservationProfile = {
    type: {
        name: "Composite",
        className: "CapacityReservationProfile",
        modelProperties: {
            capacityReservationGroup: {
                serializedName: "capacityReservationGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const ApplicationProfile = {
    type: {
        name: "Composite",
        className: "ApplicationProfile",
        modelProperties: {
            galleryApplications: {
                serializedName: "galleryApplications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VMGalleryApplication"
                        }
                    }
                }
            }
        }
    }
};
const VMGalleryApplication = {
    type: {
        name: "Composite",
        className: "VMGalleryApplication",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "Number"
                }
            },
            packageReferenceId: {
                serializedName: "packageReferenceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            configurationReference: {
                serializedName: "configurationReference",
                type: {
                    name: "String"
                }
            },
            treatFailureAsDeploymentFailure: {
                serializedName: "treatFailureAsDeploymentFailure",
                type: {
                    name: "Boolean"
                }
            },
            enableAutomaticUpgrade: {
                serializedName: "enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineScaleSetHardwareProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetHardwareProfile",
        modelProperties: {
            vmSizeProperties: {
                serializedName: "vmSizeProperties",
                type: {
                    name: "Composite",
                    className: "VMSizeProperties"
                }
            }
        }
    }
};
const VMSizeProperties = {
    type: {
        name: "Composite",
        className: "VMSizeProperties",
        modelProperties: {
            vCPUsAvailable: {
                serializedName: "vCPUsAvailable",
                type: {
                    name: "Number"
                }
            },
            vCPUsPerCore: {
                serializedName: "vCPUsPerCore",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AdditionalCapabilities = {
    type: {
        name: "Composite",
        className: "AdditionalCapabilities",
        modelProperties: {
            ultraSSDEnabled: {
                serializedName: "ultraSSDEnabled",
                type: {
                    name: "Boolean"
                }
            },
            hibernationEnabled: {
                serializedName: "hibernationEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ScaleInPolicy = {
    type: {
        name: "Composite",
        className: "ScaleInPolicy",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            forceDeletion: {
                serializedName: "forceDeletion",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SpotRestorePolicy = {
    type: {
        name: "Composite",
        className: "SpotRestorePolicy",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            restoreTimeout: {
                serializedName: "restoreTimeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PriorityMixPolicy = {
    type: {
        name: "Composite",
        className: "PriorityMixPolicy",
        modelProperties: {
            baseRegularPriorityCount: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "baseRegularPriorityCount",
                type: {
                    name: "Number"
                }
            },
            regularPriorityPercentageAboveBase: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "regularPriorityPercentageAboveBase",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachineScaleSetIdentity = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentitiesValue = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentitiesValue",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdateVMProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateVMProfile",
        modelProperties: {
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdateOSProfile"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdateStorageProfile"
                }
            },
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdateNetworkProfile"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            diagnosticsProfile: {
                serializedName: "diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            },
            extensionProfile: {
                serializedName: "extensionProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetExtensionProfile"
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            billingProfile: {
                serializedName: "billingProfile",
                type: {
                    name: "Composite",
                    className: "BillingProfile"
                }
            },
            scheduledEventsProfile: {
                serializedName: "scheduledEventsProfile",
                type: {
                    name: "Composite",
                    className: "ScheduledEventsProfile"
                }
            },
            userData: {
                serializedName: "userData",
                type: {
                    name: "String"
                }
            },
            hardwareProfile: {
                serializedName: "hardwareProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetHardwareProfile"
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdateOSProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateOSProfile",
        modelProperties: {
            customData: {
                serializedName: "customData",
                type: {
                    name: "String"
                }
            },
            windowsConfiguration: {
                serializedName: "windowsConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsConfiguration"
                }
            },
            linuxConfiguration: {
                serializedName: "linuxConfiguration",
                type: {
                    name: "Composite",
                    className: "LinuxConfiguration"
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VaultSecretGroup"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdateStorageProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateStorageProfile",
        modelProperties: {
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdateOSDisk"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetDataDisk"
                        }
                    }
                }
            },
            diskControllerType: {
                serializedName: "diskControllerType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdateOSDisk = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateOSDisk",
        modelProperties: {
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            vhdContainers: {
                serializedName: "vhdContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetManagedDiskParameters"
                }
            },
            deleteOption: {
                serializedName: "deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdateNetworkProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateNetworkProfile",
        modelProperties: {
            healthProbe: {
                serializedName: "healthProbe",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            },
            networkInterfaceConfigurations: {
                serializedName: "networkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetUpdateNetworkConfiguration"
                        }
                    }
                }
            },
            networkApiVersion: {
                serializedName: "networkApiVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetUpdatePublicIPAddressConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdatePublicIPAddressConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            },
            dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings"
                }
            },
            publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateResource = {
    type: {
        name: "Composite",
        className: "UpdateResource",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMInstanceIDs = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMInstanceIDs",
        modelProperties: {
            instanceIds: {
                serializedName: "instanceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMInstanceRequiredIDs = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMInstanceRequiredIDs",
        modelProperties: {
            instanceIds: {
                serializedName: "instanceIds",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetInstanceView",
        modelProperties: {
            virtualMachine: {
                serializedName: "virtualMachine",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetInstanceViewStatusesSummary"
                }
            },
            extensions: {
                serializedName: "extensions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetVMExtensionsSummary"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            },
            orchestrationServices: {
                serializedName: "orchestrationServices",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OrchestrationServiceSummary"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetInstanceViewStatusesSummary = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetInstanceViewStatusesSummary",
        modelProperties: {
            statusesSummary: {
                serializedName: "statusesSummary",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineStatusCodeCount"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineStatusCodeCount = {
    type: {
        name: "Composite",
        className: "VirtualMachineStatusCodeCount",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMExtensionsSummary = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMExtensionsSummary",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusesSummary: {
                serializedName: "statusesSummary",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineStatusCodeCount"
                        }
                    }
                }
            }
        }
    }
};
const InstanceViewStatus = {
    type: {
        name: "Composite",
        className: "InstanceViewStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Info", "Warning", "Error"]
                }
            },
            displayStatus: {
                serializedName: "displayStatus",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            time: {
                serializedName: "time",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const OrchestrationServiceSummary = {
    type: {
        name: "Composite",
        className: "OrchestrationServiceSummary",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceState: {
                serializedName: "serviceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetExtensionListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetExtensionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetExtension"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetListWithLinkResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetListWithLinkResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetListSkusResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetListSkusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetSku = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetSkuCapacity"
                }
            }
        }
    }
};
const VirtualMachineScaleSetSkuCapacity = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetSkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            defaultCapacity: {
                serializedName: "defaultCapacity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Automatic", "None"]
                }
            }
        }
    }
};
const VirtualMachineScaleSetListOSUpgradeHistory = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetListOSUpgradeHistory",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpgradeOperationHistoricalStatusInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpgradeOperationHistoricalStatusInfo = {
    type: {
        name: "Composite",
        className: "UpgradeOperationHistoricalStatusInfo",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "UpgradeOperationHistoricalStatusInfoProperties"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpgradeOperationHistoricalStatusInfoProperties = {
    type: {
        name: "Composite",
        className: "UpgradeOperationHistoricalStatusInfoProperties",
        modelProperties: {
            runningStatus: {
                serializedName: "runningStatus",
                type: {
                    name: "Composite",
                    className: "UpgradeOperationHistoryStatus"
                }
            },
            progress: {
                serializedName: "progress",
                type: {
                    name: "Composite",
                    className: "RollingUpgradeProgressInfo"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            },
            startedBy: {
                serializedName: "startedBy",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Unknown", "User", "Platform"]
                }
            },
            targetImageReference: {
                serializedName: "targetImageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            rollbackInfo: {
                serializedName: "rollbackInfo",
                type: {
                    name: "Composite",
                    className: "RollbackStatusInfo"
                }
            }
        }
    }
};
const UpgradeOperationHistoryStatus = {
    type: {
        name: "Composite",
        className: "UpgradeOperationHistoryStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["RollingForward", "Cancelled", "Completed", "Faulted"]
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RollingUpgradeProgressInfo = {
    type: {
        name: "Composite",
        className: "RollingUpgradeProgressInfo",
        modelProperties: {
            successfulInstanceCount: {
                serializedName: "successfulInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedInstanceCount: {
                serializedName: "failedInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            inProgressInstanceCount: {
                serializedName: "inProgressInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            pendingInstanceCount: {
                serializedName: "pendingInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RollbackStatusInfo = {
    type: {
        name: "Composite",
        className: "RollbackStatusInfo",
        modelProperties: {
            successfullyRolledbackInstanceCount: {
                serializedName: "successfullyRolledbackInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedRolledbackInstanceCount: {
                serializedName: "failedRolledbackInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            rollbackError: {
                serializedName: "rollbackError",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const VirtualMachineReimageParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineReimageParameters",
        modelProperties: {
            tempDisk: {
                serializedName: "tempDisk",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RollingUpgradeRunningStatus = {
    type: {
        name: "Composite",
        className: "RollingUpgradeRunningStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["RollingForward", "Cancelled", "Completed", "Faulted"]
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastAction: {
                serializedName: "lastAction",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Start", "Cancel"]
                }
            },
            lastActionTime: {
                serializedName: "lastActionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RecoveryWalkResponse = {
    type: {
        name: "Composite",
        className: "RecoveryWalkResponse",
        modelProperties: {
            walkPerformed: {
                serializedName: "walkPerformed",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            nextPlatformUpdateDomain: {
                serializedName: "nextPlatformUpdateDomain",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VMScaleSetConvertToSinglePlacementGroupInput = {
    type: {
        name: "Composite",
        className: "VMScaleSetConvertToSinglePlacementGroupInput",
        modelProperties: {
            activePlacementGroupId: {
                serializedName: "activePlacementGroupId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OrchestrationServiceStateInput = {
    type: {
        name: "Composite",
        className: "OrchestrationServiceStateInput",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                required: true,
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineExtensionInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtensionInstanceView",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            substatuses: {
                serializedName: "substatuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMExtensionsListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMExtensionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetVMExtension"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMInstanceView",
        modelProperties: {
            platformUpdateDomain: {
                serializedName: "platformUpdateDomain",
                type: {
                    name: "Number"
                }
            },
            platformFaultDomain: {
                serializedName: "platformFaultDomain",
                type: {
                    name: "Number"
                }
            },
            rdpThumbPrint: {
                serializedName: "rdpThumbPrint",
                type: {
                    name: "String"
                }
            },
            vmAgent: {
                serializedName: "vmAgent",
                type: {
                    name: "Composite",
                    className: "VirtualMachineAgentInstanceView"
                }
            },
            maintenanceRedeployStatus: {
                serializedName: "maintenanceRedeployStatus",
                type: {
                    name: "Composite",
                    className: "MaintenanceRedeployStatus"
                }
            },
            disks: {
                serializedName: "disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskInstanceView"
                        }
                    }
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtensionInstanceView"
                        }
                    }
                }
            },
            vmHealth: {
                serializedName: "vmHealth",
                type: {
                    name: "Composite",
                    className: "VirtualMachineHealthStatus"
                }
            },
            bootDiagnostics: {
                serializedName: "bootDiagnostics",
                type: {
                    name: "Composite",
                    className: "BootDiagnosticsInstanceView"
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            },
            assignedHost: {
                serializedName: "assignedHost",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            placementGroupId: {
                serializedName: "placementGroupId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineAgentInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineAgentInstanceView",
        modelProperties: {
            vmAgentVersion: {
                serializedName: "vmAgentVersion",
                type: {
                    name: "String"
                }
            },
            extensionHandlers: {
                serializedName: "extensionHandlers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtensionHandlerInstanceView"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineExtensionHandlerInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtensionHandlerInstanceView",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            }
        }
    }
};
const MaintenanceRedeployStatus = {
    type: {
        name: "Composite",
        className: "MaintenanceRedeployStatus",
        modelProperties: {
            isCustomerInitiatedMaintenanceAllowed: {
                serializedName: "isCustomerInitiatedMaintenanceAllowed",
                type: {
                    name: "Boolean"
                }
            },
            preMaintenanceWindowStartTime: {
                serializedName: "preMaintenanceWindowStartTime",
                type: {
                    name: "DateTime"
                }
            },
            preMaintenanceWindowEndTime: {
                serializedName: "preMaintenanceWindowEndTime",
                type: {
                    name: "DateTime"
                }
            },
            maintenanceWindowStartTime: {
                serializedName: "maintenanceWindowStartTime",
                type: {
                    name: "DateTime"
                }
            },
            maintenanceWindowEndTime: {
                serializedName: "maintenanceWindowEndTime",
                type: {
                    name: "DateTime"
                }
            },
            lastOperationResultCode: {
                serializedName: "lastOperationResultCode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "RetryLater",
                        "MaintenanceAborted",
                        "MaintenanceCompleted"
                    ]
                }
            },
            lastOperationMessage: {
                serializedName: "lastOperationMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskInstanceView = {
    type: {
        name: "Composite",
        className: "DiskInstanceView",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            encryptionSettings: {
                serializedName: "encryptionSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskEncryptionSettings"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const DiskEncryptionSettings = {
    type: {
        name: "Composite",
        className: "DiskEncryptionSettings",
        modelProperties: {
            diskEncryptionKey: {
                serializedName: "diskEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            },
            keyEncryptionKey: {
                serializedName: "keyEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReference"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const KeyVaultKeyReference = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyReference",
        modelProperties: {
            keyUrl: {
                serializedName: "keyUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const VirtualMachineHealthStatus = {
    type: {
        name: "Composite",
        className: "VirtualMachineHealthStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            }
        }
    }
};
const BootDiagnosticsInstanceView = {
    type: {
        name: "Composite",
        className: "BootDiagnosticsInstanceView",
        modelProperties: {
            consoleScreenshotBlobUri: {
                serializedName: "consoleScreenshotBlobUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serialConsoleLogBlobUri: {
                serializedName: "serialConsoleLogBlobUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            }
        }
    }
};
const HardwareProfile = {
    type: {
        name: "Composite",
        className: "HardwareProfile",
        modelProperties: {
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            vmSizeProperties: {
                serializedName: "vmSizeProperties",
                type: {
                    name: "Composite",
                    className: "VMSizeProperties"
                }
            }
        }
    }
};
const StorageProfile = {
    type: {
        name: "Composite",
        className: "StorageProfile",
        modelProperties: {
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "OSDisk"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDisk"
                        }
                    }
                }
            },
            diskControllerType: {
                serializedName: "diskControllerType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSDisk = {
    type: {
        name: "Composite",
        className: "OSDisk",
        modelProperties: {
            osType: {
                serializedName: "osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            encryptionSettings: {
                serializedName: "encryptionSettings",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSettings"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            vhd: {
                serializedName: "vhd",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            },
            diffDiskSettings: {
                serializedName: "diffDiskSettings",
                type: {
                    name: "Composite",
                    className: "DiffDiskSettings"
                }
            },
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDiskParameters"
                }
            },
            deleteOption: {
                serializedName: "deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataDisk = {
    type: {
        name: "Composite",
        className: "DataDisk",
        modelProperties: {
            lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            vhd: {
                serializedName: "vhd",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "VirtualHardDisk"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            },
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDiskParameters"
                }
            },
            toBeDetached: {
                serializedName: "toBeDetached",
                type: {
                    name: "Boolean"
                }
            },
            diskIopsReadWrite: {
                serializedName: "diskIOPSReadWrite",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            diskMBpsReadWrite: {
                serializedName: "diskMBpsReadWrite",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            detachOption: {
                serializedName: "detachOption",
                type: {
                    name: "String"
                }
            },
            deleteOption: {
                serializedName: "deleteOption",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSProfile = {
    type: {
        name: "Composite",
        className: "OSProfile",
        modelProperties: {
            computerName: {
                serializedName: "computerName",
                type: {
                    name: "String"
                }
            },
            adminUsername: {
                serializedName: "adminUsername",
                type: {
                    name: "String"
                }
            },
            adminPassword: {
                serializedName: "adminPassword",
                type: {
                    name: "String"
                }
            },
            customData: {
                serializedName: "customData",
                type: {
                    name: "String"
                }
            },
            windowsConfiguration: {
                serializedName: "windowsConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsConfiguration"
                }
            },
            linuxConfiguration: {
                serializedName: "linuxConfiguration",
                type: {
                    name: "Composite",
                    className: "LinuxConfiguration"
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VaultSecretGroup"
                        }
                    }
                }
            },
            allowExtensionOperations: {
                serializedName: "allowExtensionOperations",
                type: {
                    name: "Boolean"
                }
            },
            requireGuestProvisionSignal: {
                serializedName: "requireGuestProvisionSignal",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkProfile = {
    type: {
        name: "Composite",
        className: "NetworkProfile",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceReference"
                        }
                    }
                }
            },
            networkApiVersion: {
                serializedName: "networkApiVersion",
                type: {
                    name: "String"
                }
            },
            networkInterfaceConfigurations: {
                serializedName: "networkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineNetworkInterfaceConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineNetworkInterfaceConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineNetworkInterfaceConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            },
            deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            },
            enableAcceleratedNetworking: {
                serializedName: "properties.enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            },
            disableTcpStateTracking: {
                serializedName: "properties.disableTcpStateTracking",
                type: {
                    name: "Boolean"
                }
            },
            enableFpga: {
                serializedName: "properties.enableFpga",
                type: {
                    name: "Boolean"
                }
            },
            enableIPForwarding: {
                serializedName: "properties.enableIPForwarding",
                type: {
                    name: "Boolean"
                }
            },
            networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachineNetworkInterfaceDnsSettingsConfiguration"
                }
            },
            ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineNetworkInterfaceIPConfiguration"
                        }
                    }
                }
            },
            dscpConfiguration: {
                serializedName: "properties.dscpConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const VirtualMachineNetworkInterfaceDnsSettingsConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineNetworkInterfaceDnsSettingsConfiguration",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineNetworkInterfaceIPConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineNetworkInterfaceIPConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            },
            publicIPAddressConfiguration: {
                serializedName: "properties.publicIPAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachinePublicIPAddressConfiguration"
                }
            },
            privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            },
            applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            },
            applicationGatewayBackendAddressPools: {
                serializedName: "properties.applicationGatewayBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            },
            loadBalancerBackendAddressPools: {
                serializedName: "properties.loadBalancerBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachinePublicIPAddressConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachinePublicIPAddressConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressSku"
                }
            },
            idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            },
            deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            },
            dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachinePublicIPAddressDnsSettingsConfiguration"
                }
            },
            ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineIpTag"
                        }
                    }
                }
            },
            publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            },
            publicIPAllocationMethod: {
                serializedName: "properties.publicIPAllocationMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinePublicIPAddressDnsSettingsConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachinePublicIPAddressDnsSettingsConfiguration",
        modelProperties: {
            domainNameLabel: {
                serializedName: "domainNameLabel",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineIpTag = {
    type: {
        name: "Composite",
        className: "VirtualMachineIpTag",
        modelProperties: {
            ipTagType: {
                serializedName: "ipTagType",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMNetworkProfileConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMNetworkProfileConfiguration",
        modelProperties: {
            networkInterfaceConfigurations: {
                serializedName: "networkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetNetworkConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMProtectionPolicy = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMProtectionPolicy",
        modelProperties: {
            protectFromScaleIn: {
                serializedName: "protectFromScaleIn",
                type: {
                    name: "Boolean"
                }
            },
            protectFromScaleSetActions: {
                serializedName: "protectFromScaleSetActions",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourceWithOptionalLocation = {
    type: {
        name: "Composite",
        className: "ResourceWithOptionalLocation",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VirtualMachineIdentity = {
    type: {
        name: "Composite",
        className: "VirtualMachineIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineScaleSetVMListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetVM"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RetrieveBootDiagnosticsDataResult = {
    type: {
        name: "Composite",
        className: "RetrieveBootDiagnosticsDataResult",
        modelProperties: {
            consoleScreenshotBlobUri: {
                serializedName: "consoleScreenshotBlobUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serialConsoleLogBlobUri: {
                serializedName: "serialConsoleLogBlobUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineExtensionsListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtensionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtension"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineInstanceView",
        modelProperties: {
            platformUpdateDomain: {
                serializedName: "platformUpdateDomain",
                type: {
                    name: "Number"
                }
            },
            platformFaultDomain: {
                serializedName: "platformFaultDomain",
                type: {
                    name: "Number"
                }
            },
            computerName: {
                serializedName: "computerName",
                type: {
                    name: "String"
                }
            },
            osName: {
                serializedName: "osName",
                type: {
                    name: "String"
                }
            },
            osVersion: {
                serializedName: "osVersion",
                type: {
                    name: "String"
                }
            },
            hyperVGeneration: {
                serializedName: "hyperVGeneration",
                type: {
                    name: "String"
                }
            },
            rdpThumbPrint: {
                serializedName: "rdpThumbPrint",
                type: {
                    name: "String"
                }
            },
            vmAgent: {
                serializedName: "vmAgent",
                type: {
                    name: "Composite",
                    className: "VirtualMachineAgentInstanceView"
                }
            },
            maintenanceRedeployStatus: {
                serializedName: "maintenanceRedeployStatus",
                type: {
                    name: "Composite",
                    className: "MaintenanceRedeployStatus"
                }
            },
            disks: {
                serializedName: "disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskInstanceView"
                        }
                    }
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtensionInstanceView"
                        }
                    }
                }
            },
            vmHealth: {
                serializedName: "vmHealth",
                type: {
                    name: "Composite",
                    className: "VirtualMachineHealthStatus"
                }
            },
            bootDiagnostics: {
                serializedName: "bootDiagnostics",
                type: {
                    name: "Composite",
                    className: "BootDiagnosticsInstanceView"
                }
            },
            assignedHost: {
                serializedName: "assignedHost",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            },
            patchStatus: {
                serializedName: "patchStatus",
                type: {
                    name: "Composite",
                    className: "VirtualMachinePatchStatus"
                }
            }
        }
    }
};
const VirtualMachinePatchStatus = {
    type: {
        name: "Composite",
        className: "VirtualMachinePatchStatus",
        modelProperties: {
            availablePatchSummary: {
                serializedName: "availablePatchSummary",
                type: {
                    name: "Composite",
                    className: "AvailablePatchSummary"
                }
            },
            lastPatchInstallationSummary: {
                serializedName: "lastPatchInstallationSummary",
                type: {
                    name: "Composite",
                    className: "LastPatchInstallationSummary"
                }
            },
            configurationStatuses: {
                serializedName: "configurationStatuses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const AvailablePatchSummary = {
    type: {
        name: "Composite",
        className: "AvailablePatchSummary",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            assessmentActivityId: {
                serializedName: "assessmentActivityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rebootPending: {
                serializedName: "rebootPending",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            criticalAndSecurityPatchCount: {
                serializedName: "criticalAndSecurityPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            otherPatchCount: {
                serializedName: "otherPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedTime: {
                serializedName: "lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const LastPatchInstallationSummary = {
    type: {
        name: "Composite",
        className: "LastPatchInstallationSummary",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            installationActivityId: {
                serializedName: "installationActivityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            maintenanceWindowExceeded: {
                serializedName: "maintenanceWindowExceeded",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            notSelectedPatchCount: {
                serializedName: "notSelectedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            excludedPatchCount: {
                serializedName: "excludedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            pendingPatchCount: {
                serializedName: "pendingPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            installedPatchCount: {
                serializedName: "installedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedPatchCount: {
                serializedName: "failedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedTime: {
                serializedName: "lastModifiedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const VirtualMachineCaptureParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineCaptureParameters",
        modelProperties: {
            vhdPrefix: {
                serializedName: "vhdPrefix",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationContainerName: {
                serializedName: "destinationContainerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            overwriteVhds: {
                serializedName: "overwriteVhds",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineAssessPatchesResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineAssessPatchesResult",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            assessmentActivityId: {
                serializedName: "assessmentActivityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rebootPending: {
                serializedName: "rebootPending",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            criticalAndSecurityPatchCount: {
                serializedName: "criticalAndSecurityPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            otherPatchCount: {
                serializedName: "otherPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            startDateTime: {
                serializedName: "startDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            availablePatches: {
                serializedName: "availablePatches",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineSoftwarePatchProperties"
                        }
                    }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const VirtualMachineSoftwarePatchProperties = {
    type: {
        name: "Composite",
        className: "VirtualMachineSoftwarePatchProperties",
        modelProperties: {
            patchId: {
                serializedName: "patchId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kbId: {
                serializedName: "kbId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            classifications: {
                serializedName: "classifications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            rebootBehavior: {
                serializedName: "rebootBehavior",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            activityId: {
                serializedName: "activityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publishedDate: {
                serializedName: "publishedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedDateTime: {
                serializedName: "lastModifiedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            assessmentState: {
                serializedName: "assessmentState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineInstallPatchesParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineInstallPatchesParameters",
        modelProperties: {
            maximumDuration: {
                serializedName: "maximumDuration",
                type: {
                    name: "String"
                }
            },
            rebootSetting: {
                serializedName: "rebootSetting",
                required: true,
                type: {
                    name: "String"
                }
            },
            windowsParameters: {
                serializedName: "windowsParameters",
                type: {
                    name: "Composite",
                    className: "WindowsParameters"
                }
            },
            linuxParameters: {
                serializedName: "linuxParameters",
                type: {
                    name: "Composite",
                    className: "LinuxParameters"
                }
            }
        }
    }
};
const WindowsParameters = {
    type: {
        name: "Composite",
        className: "WindowsParameters",
        modelProperties: {
            classificationsToInclude: {
                serializedName: "classificationsToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kbNumbersToInclude: {
                serializedName: "kbNumbersToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kbNumbersToExclude: {
                serializedName: "kbNumbersToExclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            excludeKbsRequiringReboot: {
                serializedName: "excludeKbsRequiringReboot",
                type: {
                    name: "Boolean"
                }
            },
            maxPatchPublishDate: {
                serializedName: "maxPatchPublishDate",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const LinuxParameters = {
    type: {
        name: "Composite",
        className: "LinuxParameters",
        modelProperties: {
            classificationsToInclude: {
                serializedName: "classificationsToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            packageNameMasksToInclude: {
                serializedName: "packageNameMasksToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            packageNameMasksToExclude: {
                serializedName: "packageNameMasksToExclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maintenanceRunId: {
                serializedName: "maintenanceRunId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineInstallPatchesResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineInstallPatchesResult",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            installationActivityId: {
                serializedName: "installationActivityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rebootStatus: {
                serializedName: "rebootStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            maintenanceWindowExceeded: {
                serializedName: "maintenanceWindowExceeded",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            excludedPatchCount: {
                serializedName: "excludedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            notSelectedPatchCount: {
                serializedName: "notSelectedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            pendingPatchCount: {
                serializedName: "pendingPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            installedPatchCount: {
                serializedName: "installedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedPatchCount: {
                serializedName: "failedPatchCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            patches: {
                serializedName: "patches",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PatchInstallationDetail"
                        }
                    }
                }
            },
            startDateTime: {
                serializedName: "startDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }
        }
    }
};
const PatchInstallationDetail = {
    type: {
        name: "Composite",
        className: "PatchInstallationDetail",
        modelProperties: {
            patchId: {
                serializedName: "patchId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kbId: {
                serializedName: "kbId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            classifications: {
                serializedName: "classifications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            installationState: {
                serializedName: "installationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PurchasePlan = {
    type: {
        name: "Composite",
        className: "PurchasePlan",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSDiskImage = {
    type: {
        name: "Composite",
        className: "OSDiskImage",
        modelProperties: {
            operatingSystem: {
                serializedName: "operatingSystem",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }
        }
    }
};
const DataDiskImage = {
    type: {
        name: "Composite",
        className: "DataDiskImage",
        modelProperties: {
            lun: {
                serializedName: "lun",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutomaticOSUpgradeProperties = {
    type: {
        name: "Composite",
        className: "AutomaticOSUpgradeProperties",
        modelProperties: {
            automaticOSUpgradeSupported: {
                serializedName: "automaticOSUpgradeSupported",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DisallowedConfiguration = {
    type: {
        name: "Composite",
        className: "DisallowedConfiguration",
        modelProperties: {
            vmDiskType: {
                serializedName: "vmDiskType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineImageFeature = {
    type: {
        name: "Composite",
        className: "VirtualMachineImageFeature",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VmImagesInEdgeZoneListResult = {
    type: {
        name: "Composite",
        className: "VmImagesInEdgeZoneListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilitySetListResult = {
    type: {
        name: "Composite",
        className: "AvailabilitySetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailabilitySet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProximityPlacementGroupPropertiesIntent = {
    type: {
        name: "Composite",
        className: "ProximityPlacementGroupPropertiesIntent",
        modelProperties: {
            vmSizes: {
                serializedName: "vmSizes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ProximityPlacementGroupListResult = {
    type: {
        name: "Composite",
        className: "ProximityPlacementGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProximityPlacementGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedHostGroupInstanceView = {
    type: {
        name: "Composite",
        className: "DedicatedHostGroupInstanceView",
        modelProperties: {
            hosts: {
                serializedName: "hosts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedHostInstanceViewWithName"
                        }
                    }
                }
            }
        }
    }
};
const DedicatedHostInstanceView = {
    type: {
        name: "Composite",
        className: "DedicatedHostInstanceView",
        modelProperties: {
            assetId: {
                serializedName: "assetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availableCapacity: {
                serializedName: "availableCapacity",
                type: {
                    name: "Composite",
                    className: "DedicatedHostAvailableCapacity"
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const DedicatedHostAvailableCapacity = {
    type: {
        name: "Composite",
        className: "DedicatedHostAvailableCapacity",
        modelProperties: {
            allocatableVMs: {
                serializedName: "allocatableVMs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedHostAllocatableVM"
                        }
                    }
                }
            }
        }
    }
};
const DedicatedHostAllocatableVM = {
    type: {
        name: "Composite",
        className: "DedicatedHostAllocatableVM",
        modelProperties: {
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DedicatedHostGroupPropertiesAdditionalCapabilities = {
    type: {
        name: "Composite",
        className: "DedicatedHostGroupPropertiesAdditionalCapabilities",
        modelProperties: {
            ultraSSDEnabled: {
                serializedName: "ultraSSDEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DedicatedHostGroupListResult = {
    type: {
        name: "Composite",
        className: "DedicatedHostGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedHostGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedHostListResult = {
    type: {
        name: "Composite",
        className: "DedicatedHostListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedHost"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SshPublicKeysGroupListResult = {
    type: {
        name: "Composite",
        className: "SshPublicKeysGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SshPublicKeyResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SshPublicKeyGenerateKeyPairResult = {
    type: {
        name: "Composite",
        className: "SshPublicKeyGenerateKeyPairResult",
        modelProperties: {
            privateKey: {
                serializedName: "privateKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            publicKey: {
                serializedName: "publicKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageStorageProfile = {
    type: {
        name: "Composite",
        className: "ImageStorageProfile",
        modelProperties: {
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "ImageOSDisk"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageDataDisk"
                        }
                    }
                }
            },
            zoneResilient: {
                serializedName: "zoneResilient",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ImageDisk = {
    type: {
        name: "Composite",
        className: "ImageDisk",
        modelProperties: {
            snapshot: {
                serializedName: "snapshot",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            blobUri: {
                serializedName: "blobUri",
                type: {
                    name: "String"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            },
            diskEncryptionSet: {
                serializedName: "diskEncryptionSet",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSetParameters"
                }
            }
        }
    }
};
const ImageListResult = {
    type: {
        name: "Composite",
        className: "ImageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Image"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorePointCollectionSourceProperties = {
    type: {
        name: "Composite",
        className: "RestorePointCollectionSourceProperties",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorePointSourceMetadata = {
    type: {
        name: "Composite",
        className: "RestorePointSourceMetadata",
        modelProperties: {
            hardwareProfile: {
                serializedName: "hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "RestorePointSourceVMStorageProfile"
                }
            },
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "OSProfile"
                }
            },
            diagnosticsProfile: {
                serializedName: "diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            vmId: {
                serializedName: "vmId",
                type: {
                    name: "String"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorePointSourceVMStorageProfile = {
    type: {
        name: "Composite",
        className: "RestorePointSourceVMStorageProfile",
        modelProperties: {
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "RestorePointSourceVmosDisk"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePointSourceVMDataDisk"
                        }
                    }
                }
            }
        }
    }
};
const RestorePointSourceVmosDisk = {
    type: {
        name: "Composite",
        className: "RestorePointSourceVmosDisk",
        modelProperties: {
            osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            encryptionSettings: {
                serializedName: "encryptionSettings",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSettings"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDiskParameters"
                }
            },
            diskRestorePoint: {
                serializedName: "diskRestorePoint",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            }
        }
    }
};
const RestorePointSourceVMDataDisk = {
    type: {
        name: "Composite",
        className: "RestorePointSourceVMDataDisk",
        modelProperties: {
            lun: {
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDiskParameters"
                }
            },
            diskRestorePoint: {
                serializedName: "diskRestorePoint",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            }
        }
    }
};
const RestorePointInstanceView = {
    type: {
        name: "Composite",
        className: "RestorePointInstanceView",
        modelProperties: {
            diskRestorePoints: {
                serializedName: "diskRestorePoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskRestorePointInstanceView"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const DiskRestorePointInstanceView = {
    type: {
        name: "Composite",
        className: "DiskRestorePointInstanceView",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            replicationStatus: {
                serializedName: "replicationStatus",
                type: {
                    name: "Composite",
                    className: "DiskRestorePointReplicationStatus"
                }
            }
        }
    }
};
const DiskRestorePointReplicationStatus = {
    type: {
        name: "Composite",
        className: "DiskRestorePointReplicationStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            },
            completionPercent: {
                serializedName: "completionPercent",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorePointCollectionListResult = {
    type: {
        name: "Composite",
        className: "RestorePointCollectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePointCollection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapacityReservationGroupInstanceView = {
    type: {
        name: "Composite",
        className: "CapacityReservationGroupInstanceView",
        modelProperties: {
            capacityReservations: {
                serializedName: "capacityReservations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CapacityReservationInstanceViewWithName"
                        }
                    }
                }
            }
        }
    }
};
const CapacityReservationInstanceView = {
    type: {
        name: "Composite",
        className: "CapacityReservationInstanceView",
        modelProperties: {
            utilizationInfo: {
                serializedName: "utilizationInfo",
                type: {
                    name: "Composite",
                    className: "CapacityReservationUtilization"
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const CapacityReservationUtilization = {
    type: {
        name: "Composite",
        className: "CapacityReservationUtilization",
        modelProperties: {
            currentCapacity: {
                serializedName: "currentCapacity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            virtualMachinesAllocated: {
                serializedName: "virtualMachinesAllocated",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }
        }
    }
};
const CapacityReservationGroupListResult = {
    type: {
        name: "Composite",
        className: "CapacityReservationGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CapacityReservationGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapacityReservationListResult = {
    type: {
        name: "Composite",
        className: "CapacityReservationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CapacityReservation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogAnalyticsInputBase = {
    type: {
        name: "Composite",
        className: "LogAnalyticsInputBase",
        modelProperties: {
            blobContainerSasUri: {
                serializedName: "blobContainerSasUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            fromTime: {
                serializedName: "fromTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            toTime: {
                serializedName: "toTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            groupByThrottlePolicy: {
                serializedName: "groupByThrottlePolicy",
                type: {
                    name: "Boolean"
                }
            },
            groupByOperationName: {
                serializedName: "groupByOperationName",
                type: {
                    name: "Boolean"
                }
            },
            groupByResourceName: {
                serializedName: "groupByResourceName",
                type: {
                    name: "Boolean"
                }
            },
            groupByClientApplicationId: {
                serializedName: "groupByClientApplicationId",
                type: {
                    name: "Boolean"
                }
            },
            groupByUserAgent: {
                serializedName: "groupByUserAgent",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LogAnalyticsOperationResult = {
    type: {
        name: "Composite",
        className: "LogAnalyticsOperationResult",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "LogAnalyticsOutput"
                }
            }
        }
    }
};
const LogAnalyticsOutput = {
    type: {
        name: "Composite",
        className: "LogAnalyticsOutput",
        modelProperties: {
            output: {
                serializedName: "output",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCommandListResult = {
    type: {
        name: "Composite",
        className: "RunCommandListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandDocumentBase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCommandDocumentBase = {
    type: {
        name: "Composite",
        className: "RunCommandDocumentBase",
        modelProperties: {
            schema: {
                serializedName: "$schema",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            label: {
                serializedName: "label",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCommandParameterDefinition = {
    type: {
        name: "Composite",
        className: "RunCommandParameterDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            defaultValue: {
                serializedName: "defaultValue",
                type: {
                    name: "String"
                }
            },
            required: {
                defaultValue: false,
                serializedName: "required",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RunCommandInput = {
    type: {
        name: "Composite",
        className: "RunCommandInput",
        modelProperties: {
            commandId: {
                serializedName: "commandId",
                required: true,
                type: {
                    name: "String"
                }
            },
            script: {
                serializedName: "script",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandInputParameter"
                        }
                    }
                }
            }
        }
    }
};
const RunCommandInputParameter = {
    type: {
        name: "Composite",
        className: "RunCommandInputParameter",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCommandResult = {
    type: {
        name: "Composite",
        className: "RunCommandResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineRunCommandScriptSource = {
    type: {
        name: "Composite",
        className: "VirtualMachineRunCommandScriptSource",
        modelProperties: {
            script: {
                serializedName: "script",
                type: {
                    name: "String"
                }
            },
            scriptUri: {
                serializedName: "scriptUri",
                type: {
                    name: "String"
                }
            },
            commandId: {
                serializedName: "commandId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineRunCommandInstanceView = {
    type: {
        name: "Composite",
        className: "VirtualMachineRunCommandInstanceView",
        modelProperties: {
            executionState: {
                serializedName: "executionState",
                type: {
                    name: "String"
                }
            },
            executionMessage: {
                serializedName: "executionMessage",
                type: {
                    name: "String"
                }
            },
            exitCode: {
                serializedName: "exitCode",
                type: {
                    name: "Number"
                }
            },
            output: {
                serializedName: "output",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineRunCommandsListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineRunCommandsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineRunCommand"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskSku = {
    type: {
        name: "Composite",
        className: "DiskSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PurchasePlanAutoGenerated = {
    type: {
        name: "Composite",
        className: "PurchasePlanAutoGenerated",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                required: true,
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                required: true,
                type: {
                    name: "String"
                }
            },
            promotionCode: {
                serializedName: "promotionCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SupportedCapabilities = {
    type: {
        name: "Composite",
        className: "SupportedCapabilities",
        modelProperties: {
            diskControllerTypes: {
                serializedName: "diskControllerTypes",
                type: {
                    name: "String"
                }
            },
            acceleratedNetwork: {
                serializedName: "acceleratedNetwork",
                type: {
                    name: "Boolean"
                }
            },
            architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CreationData = {
    type: {
        name: "Composite",
        className: "CreationData",
        modelProperties: {
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageAccountId: {
                serializedName: "storageAccountId",
                type: {
                    name: "String"
                }
            },
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageDiskReference"
                }
            },
            galleryImageReference: {
                serializedName: "galleryImageReference",
                type: {
                    name: "Composite",
                    className: "ImageDiskReference"
                }
            },
            sourceUri: {
                serializedName: "sourceUri",
                type: {
                    name: "String"
                }
            },
            sourceResourceId: {
                serializedName: "sourceResourceId",
                type: {
                    name: "String"
                }
            },
            sourceUniqueId: {
                serializedName: "sourceUniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uploadSizeBytes: {
                serializedName: "uploadSizeBytes",
                type: {
                    name: "Number"
                }
            },
            logicalSectorSize: {
                serializedName: "logicalSectorSize",
                type: {
                    name: "Number"
                }
            },
            securityDataUri: {
                serializedName: "securityDataUri",
                type: {
                    name: "String"
                }
            },
            performancePlus: {
                serializedName: "performancePlus",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ImageDiskReference = {
    type: {
        name: "Composite",
        className: "ImageDiskReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            sharedGalleryImageId: {
                serializedName: "sharedGalleryImageId",
                type: {
                    name: "String"
                }
            },
            communityGalleryImageId: {
                serializedName: "communityGalleryImageId",
                type: {
                    name: "String"
                }
            },
            lun: {
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const EncryptionSettingsCollection = {
    type: {
        name: "Composite",
        className: "EncryptionSettingsCollection",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            encryptionSettings: {
                serializedName: "encryptionSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EncryptionSettingsElement"
                        }
                    }
                }
            },
            encryptionSettingsVersion: {
                serializedName: "encryptionSettingsVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionSettingsElement = {
    type: {
        name: "Composite",
        className: "EncryptionSettingsElement",
        modelProperties: {
            diskEncryptionKey: {
                serializedName: "diskEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultAndSecretReference"
                }
            },
            keyEncryptionKey: {
                serializedName: "keyEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultAndKeyReference"
                }
            }
        }
    }
};
const KeyVaultAndSecretReference = {
    type: {
        name: "Composite",
        className: "KeyVaultAndSecretReference",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SourceVault"
                }
            },
            secretUrl: {
                serializedName: "secretUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceVault = {
    type: {
        name: "Composite",
        className: "SourceVault",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultAndKeyReference = {
    type: {
        name: "Composite",
        className: "KeyVaultAndKeyReference",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SourceVault"
                }
            },
            keyUrl: {
                serializedName: "keyUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Encryption = {
    type: {
        name: "Composite",
        className: "Encryption",
        modelProperties: {
            diskEncryptionSetId: {
                serializedName: "diskEncryptionSetId",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareInfoElement = {
    type: {
        name: "Composite",
        className: "ShareInfoElement",
        modelProperties: {
            vmUri: {
                serializedName: "vmUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PropertyUpdatesInProgress = {
    type: {
        name: "Composite",
        className: "PropertyUpdatesInProgress",
        modelProperties: {
            targetTier: {
                serializedName: "targetTier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskSecurityProfile = {
    type: {
        name: "Composite",
        className: "DiskSecurityProfile",
        modelProperties: {
            securityType: {
                serializedName: "securityType",
                type: {
                    name: "String"
                }
            },
            secureVMDiskEncryptionSetId: {
                serializedName: "secureVMDiskEncryptionSetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskUpdate = {
    type: {
        name: "Composite",
        className: "DiskUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "DiskSku"
                }
            },
            osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            diskSizeGB: {
                serializedName: "properties.diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            encryptionSettingsCollection: {
                serializedName: "properties.encryptionSettingsCollection",
                type: {
                    name: "Composite",
                    className: "EncryptionSettingsCollection"
                }
            },
            diskIopsReadWrite: {
                serializedName: "properties.diskIOPSReadWrite",
                type: {
                    name: "Number"
                }
            },
            diskMBpsReadWrite: {
                serializedName: "properties.diskMBpsReadWrite",
                type: {
                    name: "Number"
                }
            },
            diskIopsReadOnly: {
                serializedName: "properties.diskIOPSReadOnly",
                type: {
                    name: "Number"
                }
            },
            diskMBpsReadOnly: {
                serializedName: "properties.diskMBpsReadOnly",
                type: {
                    name: "Number"
                }
            },
            maxShares: {
                serializedName: "properties.maxShares",
                type: {
                    name: "Number"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            networkAccessPolicy: {
                serializedName: "properties.networkAccessPolicy",
                type: {
                    name: "String"
                }
            },
            diskAccessId: {
                serializedName: "properties.diskAccessId",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "properties.tier",
                type: {
                    name: "String"
                }
            },
            burstingEnabled: {
                serializedName: "properties.burstingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "PurchasePlanAutoGenerated"
                }
            },
            supportedCapabilities: {
                serializedName: "properties.supportedCapabilities",
                type: {
                    name: "Composite",
                    className: "SupportedCapabilities"
                }
            },
            propertyUpdatesInProgress: {
                serializedName: "properties.propertyUpdatesInProgress",
                type: {
                    name: "Composite",
                    className: "PropertyUpdatesInProgress"
                }
            },
            supportsHibernation: {
                serializedName: "properties.supportsHibernation",
                type: {
                    name: "Boolean"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            dataAccessAuthMode: {
                serializedName: "properties.dataAccessAuthMode",
                type: {
                    name: "String"
                }
            },
            optimizedForFrequentAttach: {
                serializedName: "properties.optimizedForFrequentAttach",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DiskList = {
    type: {
        name: "Composite",
        className: "DiskList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Disk"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GrantAccessData = {
    type: {
        name: "Composite",
        className: "GrantAccessData",
        modelProperties: {
            access: {
                serializedName: "access",
                required: true,
                type: {
                    name: "String"
                }
            },
            durationInSeconds: {
                serializedName: "durationInSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            getSecureVMGuestStateSAS: {
                serializedName: "getSecureVMGuestStateSAS",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AccessUri = {
    type: {
        name: "Composite",
        className: "AccessUri",
        modelProperties: {
            accessSAS: {
                serializedName: "accessSAS",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            securityDataAccessSAS: {
                serializedName: "securityDataAccessSAS",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskAccessUpdate = {
    type: {
        name: "Composite",
        className: "DiskAccessUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DiskAccessList = {
    type: {
        name: "Composite",
        className: "DiskAccessList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskAccess"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionSetIdentity = {
    type: {
        name: "Composite",
        className: "EncryptionSetIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const KeyForDiskEncryptionSet = {
    type: {
        name: "Composite",
        className: "KeyForDiskEncryptionSet",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SourceVault"
                }
            },
            keyUrl: {
                serializedName: "keyUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskEncryptionSetUpdate = {
    type: {
        name: "Composite",
        className: "DiskEncryptionSetUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EncryptionSetIdentity"
                }
            },
            encryptionType: {
                serializedName: "properties.encryptionType",
                type: {
                    name: "String"
                }
            },
            activeKey: {
                serializedName: "properties.activeKey",
                type: {
                    name: "Composite",
                    className: "KeyForDiskEncryptionSet"
                }
            },
            rotationToLatestKeyVersionEnabled: {
                serializedName: "properties.rotationToLatestKeyVersionEnabled",
                type: {
                    name: "Boolean"
                }
            },
            federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskEncryptionSetList = {
    type: {
        name: "Composite",
        className: "DiskEncryptionSetList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskEncryptionSet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceUriList = {
    type: {
        name: "Composite",
        className: "ResourceUriList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyOnlyResource = {
    type: {
        name: "Composite",
        className: "ProxyOnlyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskRestorePointList = {
    type: {
        name: "Composite",
        className: "DiskRestorePointList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskRestorePoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotSku = {
    type: {
        name: "Composite",
        className: "SnapshotSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CopyCompletionError = {
    type: {
        name: "Composite",
        className: "CopyCompletionError",
        modelProperties: {
            errorCode: {
                serializedName: "errorCode",
                required: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotUpdate = {
    type: {
        name: "Composite",
        className: "SnapshotUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SnapshotSku"
                }
            },
            osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            diskSizeGB: {
                serializedName: "properties.diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            encryptionSettingsCollection: {
                serializedName: "properties.encryptionSettingsCollection",
                type: {
                    name: "Composite",
                    className: "EncryptionSettingsCollection"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            networkAccessPolicy: {
                serializedName: "properties.networkAccessPolicy",
                type: {
                    name: "String"
                }
            },
            diskAccessId: {
                serializedName: "properties.diskAccessId",
                type: {
                    name: "String"
                }
            },
            supportsHibernation: {
                serializedName: "properties.supportsHibernation",
                type: {
                    name: "Boolean"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            dataAccessAuthMode: {
                serializedName: "properties.dataAccessAuthMode",
                type: {
                    name: "String"
                }
            },
            supportedCapabilities: {
                serializedName: "properties.supportedCapabilities",
                type: {
                    name: "Composite",
                    className: "SupportedCapabilities"
                }
            }
        }
    }
};
const SnapshotList = {
    type: {
        name: "Composite",
        className: "SnapshotList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Snapshot"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkusResult = {
    type: {
        name: "Composite",
        className: "ResourceSkusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSku = {
    type: {
        name: "Composite",
        className: "ResourceSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "ResourceSkuCapacity"
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuLocationInfo"
                        }
                    }
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            costs: {
                serializedName: "costs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuCosts"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuCapabilities"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuRestrictions"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSkuCapacity = {
    type: {
        name: "Composite",
        className: "ResourceSkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Automatic", "Manual", "None"]
                }
            }
        }
    }
};
const ResourceSkuLocationInfo = {
    type: {
        name: "Composite",
        className: "ResourceSkuLocationInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zoneDetails: {
                serializedName: "zoneDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuZoneDetails"
                        }
                    }
                }
            },
            extendedLocations: {
                serializedName: "extendedLocations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuZoneDetails = {
    type: {
        name: "Composite",
        className: "ResourceSkuZoneDetails",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuCapabilities"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSkuCapabilities = {
    type: {
        name: "Composite",
        className: "ResourceSkuCapabilities",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuCosts = {
    type: {
        name: "Composite",
        className: "ResourceSkuCosts",
        modelProperties: {
            meterID: {
                serializedName: "meterID",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            quantity: {
                serializedName: "quantity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            extendedUnit: {
                serializedName: "extendedUnit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuRestrictions = {
    type: {
        name: "Composite",
        className: "ResourceSkuRestrictions",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Location", "Zone"]
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            restrictionInfo: {
                serializedName: "restrictionInfo",
                type: {
                    name: "Composite",
                    className: "ResourceSkuRestrictionInfo"
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["QuotaId", "NotAvailableForSubscription"]
                }
            }
        }
    }
};
const ResourceSkuRestrictionInfo = {
    type: {
        name: "Composite",
        className: "ResourceSkuRestrictionInfo",
        modelProperties: {
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const GalleryIdentifier = {
    type: {
        name: "Composite",
        className: "GalleryIdentifier",
        modelProperties: {
            uniqueName: {
                serializedName: "uniqueName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharingProfile = {
    type: {
        name: "Composite",
        className: "SharingProfile",
        modelProperties: {
            permissions: {
                serializedName: "permissions",
                type: {
                    name: "String"
                }
            },
            groups: {
                serializedName: "groups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharingProfileGroup"
                        }
                    }
                }
            },
            communityGalleryInfo: {
                serializedName: "communityGalleryInfo",
                type: {
                    name: "Composite",
                    className: "CommunityGalleryInfo"
                }
            }
        }
    }
};
const SharingProfileGroup = {
    type: {
        name: "Composite",
        className: "SharingProfileGroup",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            ids: {
                serializedName: "ids",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CommunityGalleryInfo = {
    type: {
        name: "Composite",
        className: "CommunityGalleryInfo",
        modelProperties: {
            publisherUri: {
                serializedName: "publisherUri",
                type: {
                    name: "String"
                }
            },
            publisherContact: {
                serializedName: "publisherContact",
                type: {
                    name: "String"
                }
            },
            eula: {
                serializedName: "eula",
                type: {
                    name: "String"
                }
            },
            publicNamePrefix: {
                serializedName: "publicNamePrefix",
                type: {
                    name: "String"
                }
            },
            communityGalleryEnabled: {
                serializedName: "communityGalleryEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            publicNames: {
                serializedName: "publicNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SoftDeletePolicy = {
    type: {
        name: "Composite",
        className: "SoftDeletePolicy",
        modelProperties: {
            isSoftDeleteEnabled: {
                serializedName: "isSoftDeleteEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SharingStatus = {
    type: {
        name: "Composite",
        className: "SharingStatus",
        modelProperties: {
            aggregatedState: {
                serializedName: "aggregatedState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            summary: {
                serializedName: "summary",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegionalSharingStatus"
                        }
                    }
                }
            }
        }
    }
};
const RegionalSharingStatus = {
    type: {
        name: "Composite",
        className: "RegionalSharingStatus",
        modelProperties: {
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateResourceDefinition = {
    type: {
        name: "Composite",
        className: "UpdateResourceDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const GalleryImageIdentifier = {
    type: {
        name: "Composite",
        className: "GalleryImageIdentifier",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                required: true,
                type: {
                    name: "String"
                }
            },
            offer: {
                serializedName: "offer",
                required: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecommendedMachineConfiguration = {
    type: {
        name: "Composite",
        className: "RecommendedMachineConfiguration",
        modelProperties: {
            vCPUs: {
                serializedName: "vCPUs",
                type: {
                    name: "Composite",
                    className: "ResourceRange"
                }
            },
            memory: {
                serializedName: "memory",
                type: {
                    name: "Composite",
                    className: "ResourceRange"
                }
            }
        }
    }
};
const ResourceRange = {
    type: {
        name: "Composite",
        className: "ResourceRange",
        modelProperties: {
            min: {
                serializedName: "min",
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Disallowed = {
    type: {
        name: "Composite",
        className: "Disallowed",
        modelProperties: {
            diskTypes: {
                serializedName: "diskTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ImagePurchasePlan = {
    type: {
        name: "Composite",
        className: "ImagePurchasePlan",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageFeature = {
    type: {
        name: "Composite",
        className: "GalleryImageFeature",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryArtifactPublishingProfileBase = {
    type: {
        name: "Composite",
        className: "GalleryArtifactPublishingProfileBase",
        modelProperties: {
            targetRegions: {
                serializedName: "targetRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TargetRegion"
                        }
                    }
                }
            },
            replicaCount: {
                serializedName: "replicaCount",
                type: {
                    name: "Number"
                }
            },
            excludeFromLatest: {
                serializedName: "excludeFromLatest",
                type: {
                    name: "Boolean"
                }
            },
            publishedDate: {
                serializedName: "publishedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            },
            replicationMode: {
                serializedName: "replicationMode",
                type: {
                    name: "String"
                }
            },
            targetExtendedLocations: {
                serializedName: "targetExtendedLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryTargetExtendedLocation"
                        }
                    }
                }
            }
        }
    }
};
const TargetRegion = {
    type: {
        name: "Composite",
        className: "TargetRegion",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            regionalReplicaCount: {
                serializedName: "regionalReplicaCount",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            },
            encryption: {
                serializedName: "encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionImages"
                }
            }
        }
    }
};
const EncryptionImages = {
    type: {
        name: "Composite",
        className: "EncryptionImages",
        modelProperties: {
            osDiskImage: {
                serializedName: "osDiskImage",
                type: {
                    name: "Composite",
                    className: "OSDiskImageEncryption"
                }
            },
            dataDiskImages: {
                serializedName: "dataDiskImages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDiskImageEncryption"
                        }
                    }
                }
            }
        }
    }
};
const OSDiskImageSecurityProfile = {
    type: {
        name: "Composite",
        className: "OSDiskImageSecurityProfile",
        modelProperties: {
            confidentialVMEncryptionType: {
                serializedName: "confidentialVMEncryptionType",
                type: {
                    name: "String"
                }
            },
            secureVMDiskEncryptionSetId: {
                serializedName: "secureVMDiskEncryptionSetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskImageEncryption = {
    type: {
        name: "Composite",
        className: "DiskImageEncryption",
        modelProperties: {
            diskEncryptionSetId: {
                serializedName: "diskEncryptionSetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryTargetExtendedLocation = {
    type: {
        name: "Composite",
        className: "GalleryTargetExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "GalleryExtendedLocation"
                }
            },
            extendedLocationReplicaCount: {
                serializedName: "extendedLocationReplicaCount",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            },
            encryption: {
                serializedName: "encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionImages"
                }
            }
        }
    }
};
const GalleryExtendedLocation = {
    type: {
        name: "Composite",
        className: "GalleryExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageVersionStorageProfile = {
    type: {
        name: "Composite",
        className: "GalleryImageVersionStorageProfile",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "GalleryArtifactVersionSource"
                }
            },
            osDiskImage: {
                serializedName: "osDiskImage",
                type: {
                    name: "Composite",
                    className: "GalleryOSDiskImage"
                }
            },
            dataDiskImages: {
                serializedName: "dataDiskImages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryDataDiskImage"
                        }
                    }
                }
            }
        }
    }
};
const GalleryArtifactVersionSource = {
    type: {
        name: "Composite",
        className: "GalleryArtifactVersionSource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryDiskImage = {
    type: {
        name: "Composite",
        className: "GalleryDiskImage",
        modelProperties: {
            sizeInGB: {
                serializedName: "sizeInGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            hostCaching: {
                serializedName: "hostCaching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "GalleryArtifactVersionSource"
                }
            }
        }
    }
};
const ReplicationStatus = {
    type: {
        name: "Composite",
        className: "ReplicationStatus",
        modelProperties: {
            aggregatedState: {
                serializedName: "aggregatedState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            summary: {
                serializedName: "summary",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegionalReplicationStatus"
                        }
                    }
                }
            }
        }
    }
};
const RegionalReplicationStatus = {
    type: {
        name: "Composite",
        className: "RegionalReplicationStatus",
        modelProperties: {
            region: {
                serializedName: "region",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            progress: {
                serializedName: "progress",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const UserArtifactSource = {
    type: {
        name: "Composite",
        className: "UserArtifactSource",
        modelProperties: {
            mediaLink: {
                serializedName: "mediaLink",
                required: true,
                type: {
                    name: "String"
                }
            },
            defaultConfigurationLink: {
                serializedName: "defaultConfigurationLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserArtifactManage = {
    type: {
        name: "Composite",
        className: "UserArtifactManage",
        modelProperties: {
            install: {
                serializedName: "install",
                required: true,
                type: {
                    name: "String"
                }
            },
            remove: {
                serializedName: "remove",
                required: true,
                type: {
                    name: "String"
                }
            },
            update: {
                serializedName: "update",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserArtifactSettings = {
    type: {
        name: "Composite",
        className: "UserArtifactSettings",
        modelProperties: {
            packageFileName: {
                serializedName: "packageFileName",
                type: {
                    name: "String"
                }
            },
            configFileName: {
                serializedName: "configFileName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryList = {
    type: {
        name: "Composite",
        className: "GalleryList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Gallery"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageList = {
    type: {
        name: "Composite",
        className: "GalleryImageList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageVersionList = {
    type: {
        name: "Composite",
        className: "GalleryImageVersionList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImageVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryApplicationList = {
    type: {
        name: "Composite",
        className: "GalleryApplicationList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryApplication"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryApplicationVersionList = {
    type: {
        name: "Composite",
        className: "GalleryApplicationVersionList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryApplicationVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharingUpdate = {
    type: {
        name: "Composite",
        className: "SharingUpdate",
        modelProperties: {
            operationType: {
                serializedName: "operationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            groups: {
                serializedName: "groups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharingProfileGroup"
                        }
                    }
                }
            }
        }
    }
};
const SharedGalleryList = {
    type: {
        name: "Composite",
        className: "SharedGalleryList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedGallery"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PirResource = {
    type: {
        name: "Composite",
        className: "PirResource",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedGalleryImageList = {
    type: {
        name: "Composite",
        className: "SharedGalleryImageList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedGalleryImage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedGalleryImageVersionList = {
    type: {
        name: "Composite",
        className: "SharedGalleryImageVersionList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedGalleryImageVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedGalleryImageVersionStorageProfile = {
    type: {
        name: "Composite",
        className: "SharedGalleryImageVersionStorageProfile",
        modelProperties: {
            osDiskImage: {
                serializedName: "osDiskImage",
                type: {
                    name: "Composite",
                    className: "SharedGalleryOSDiskImage"
                }
            },
            dataDiskImages: {
                serializedName: "dataDiskImages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedGalleryDataDiskImage"
                        }
                    }
                }
            }
        }
    }
};
const SharedGalleryDiskImage = {
    type: {
        name: "Composite",
        className: "SharedGalleryDiskImage",
        modelProperties: {
            diskSizeGB: {
                serializedName: "diskSizeGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            hostCaching: {
                serializedName: "hostCaching",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PirCommunityGalleryResource = {
    type: {
        name: "Composite",
        className: "PirCommunityGalleryResource",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uniqueId: {
                serializedName: "identifier.uniqueId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunityGalleryImageList = {
    type: {
        name: "Composite",
        className: "CommunityGalleryImageList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunityGalleryImage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunityGalleryImageVersionList = {
    type: {
        name: "Composite",
        className: "CommunityGalleryImageVersionList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CommunityGalleryImageVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleInstance = {
    type: {
        name: "Composite",
        className: "RoleInstance",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "InstanceSku"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "RoleInstanceProperties"
                }
            }
        }
    }
};
const InstanceSku = {
    type: {
        name: "Composite",
        className: "InstanceSku",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleInstanceProperties = {
    type: {
        name: "Composite",
        className: "RoleInstanceProperties",
        modelProperties: {
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "RoleInstanceNetworkProfile"
                }
            },
            instanceView: {
                serializedName: "instanceView",
                type: {
                    name: "Composite",
                    className: "RoleInstanceView"
                }
            }
        }
    }
};
const RoleInstanceNetworkProfile = {
    type: {
        name: "Composite",
        className: "RoleInstanceNetworkProfile",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const RoleInstanceView = {
    type: {
        name: "Composite",
        className: "RoleInstanceView",
        modelProperties: {
            platformUpdateDomain: {
                serializedName: "platformUpdateDomain",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            platformFaultDomain: {
                serializedName: "platformFaultDomain",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            privateId: {
                serializedName: "privateId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statuses: {
                serializedName: "statuses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceInstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const ResourceInstanceViewStatus = {
    type: {
        name: "Composite",
        className: "ResourceInstanceViewStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayStatus: {
                serializedName: "displayStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            time: {
                serializedName: "time",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Info", "Warning", "Error"]
                }
            }
        }
    }
};
const RoleInstanceListResult = {
    type: {
        name: "Composite",
        className: "RoleInstanceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleInstance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudServiceRole = {
    type: {
        name: "Composite",
        className: "CloudServiceRole",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "CloudServiceRoleSku"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CloudServiceRoleProperties"
                }
            }
        }
    }
};
const CloudServiceRoleSku = {
    type: {
        name: "Composite",
        className: "CloudServiceRoleSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CloudServiceRoleProperties = {
    type: {
        name: "Composite",
        className: "CloudServiceRoleProperties",
        modelProperties: {
            uniqueId: {
                serializedName: "uniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudServiceRoleListResult = {
    type: {
        name: "Composite",
        className: "CloudServiceRoleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudServiceRole"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudService = {
    type: {
        name: "Composite",
        className: "CloudService",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CloudServiceProperties"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const CloudServiceProperties = {
    type: {
        name: "Composite",
        className: "CloudServiceProperties",
        modelProperties: {
            packageUrl: {
                serializedName: "packageUrl",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "String"
                }
            },
            configurationUrl: {
                serializedName: "configurationUrl",
                type: {
                    name: "String"
                }
            },
            startCloudService: {
                serializedName: "startCloudService",
                type: {
                    name: "Boolean"
                }
            },
            allowModelOverride: {
                serializedName: "allowModelOverride",
                type: {
                    name: "Boolean"
                }
            },
            upgradeMode: {
                serializedName: "upgradeMode",
                type: {
                    name: "String"
                }
            },
            roleProfile: {
                serializedName: "roleProfile",
                type: {
                    name: "Composite",
                    className: "CloudServiceRoleProfile"
                }
            },
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "CloudServiceOsProfile"
                }
            },
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "CloudServiceNetworkProfile"
                }
            },
            extensionProfile: {
                serializedName: "extensionProfile",
                type: {
                    name: "Composite",
                    className: "CloudServiceExtensionProfile"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uniqueId: {
                serializedName: "uniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudServiceRoleProfile = {
    type: {
        name: "Composite",
        className: "CloudServiceRoleProfile",
        modelProperties: {
            roles: {
                serializedName: "roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudServiceRoleProfileProperties"
                        }
                    }
                }
            }
        }
    }
};
const CloudServiceRoleProfileProperties = {
    type: {
        name: "Composite",
        className: "CloudServiceRoleProfileProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "CloudServiceRoleSku"
                }
            }
        }
    }
};
const CloudServiceOsProfile = {
    type: {
        name: "Composite",
        className: "CloudServiceOsProfile",
        modelProperties: {
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudServiceVaultSecretGroup"
                        }
                    }
                }
            }
        }
    }
};
const CloudServiceVaultSecretGroup = {
    type: {
        name: "Composite",
        className: "CloudServiceVaultSecretGroup",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            vaultCertificates: {
                serializedName: "vaultCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudServiceVaultCertificate"
                        }
                    }
                }
            }
        }
    }
};
const CloudServiceVaultCertificate = {
    type: {
        name: "Composite",
        className: "CloudServiceVaultCertificate",
        modelProperties: {
            certificateUrl: {
                serializedName: "certificateUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudServiceNetworkProfile = {
    type: {
        name: "Composite",
        className: "CloudServiceNetworkProfile",
        modelProperties: {
            loadBalancerConfigurations: {
                serializedName: "loadBalancerConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerConfiguration"
                        }
                    }
                }
            },
            slotType: {
                serializedName: "slotType",
                type: {
                    name: "String"
                }
            },
            swappableCloudService: {
                serializedName: "swappableCloudService",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const LoadBalancerConfiguration = {
    type: {
        name: "Composite",
        className: "LoadBalancerConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "LoadBalancerConfigurationProperties"
                }
            }
        }
    }
};
const LoadBalancerConfigurationProperties = {
    type: {
        name: "Composite",
        className: "LoadBalancerConfigurationProperties",
        modelProperties: {
            frontendIPConfigurations: {
                serializedName: "frontendIPConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerFrontendIPConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const LoadBalancerFrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "LoadBalancerFrontendIPConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "LoadBalancerFrontendIPConfigurationProperties"
                }
            }
        }
    }
};
const LoadBalancerFrontendIPConfigurationProperties = {
    type: {
        name: "Composite",
        className: "LoadBalancerFrontendIPConfigurationProperties",
        modelProperties: {
            publicIPAddress: {
                serializedName: "publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudServiceExtensionProfile = {
    type: {
        name: "Composite",
        className: "CloudServiceExtensionProfile",
        modelProperties: {
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Extension"
                        }
                    }
                }
            }
        }
    }
};
const Extension = {
    type: {
        name: "Composite",
        className: "Extension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CloudServiceExtensionProperties"
                }
            }
        }
    }
};
const CloudServiceExtensionProperties = {
    type: {
        name: "Composite",
        className: "CloudServiceExtensionProperties",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            autoUpgradeMinorVersion: {
                serializedName: "autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            },
            settings: {
                serializedName: "settings",
                type: {
                    name: "any"
                }
            },
            protectedSettings: {
                serializedName: "protectedSettings",
                type: {
                    name: "any"
                }
            },
            protectedSettingsFromKeyVault: {
                serializedName: "protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "CloudServiceVaultAndSecretReference"
                }
            },
            forceUpdateTag: {
                serializedName: "forceUpdateTag",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rolesAppliedTo: {
                serializedName: "rolesAppliedTo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CloudServiceVaultAndSecretReference = {
    type: {
        name: "Composite",
        className: "CloudServiceVaultAndSecretReference",
        modelProperties: {
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            secretUrl: {
                serializedName: "secretUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdAt: {
                serializedName: "createdAt",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CloudServiceUpdate = {
    type: {
        name: "Composite",
        className: "CloudServiceUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CloudServiceInstanceView = {
    type: {
        name: "Composite",
        className: "CloudServiceInstanceView",
        modelProperties: {
            roleInstance: {
                serializedName: "roleInstance",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatusesSummary"
                }
            },
            sdkVersion: {
                serializedName: "sdkVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIds: {
                serializedName: "privateIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            statuses: {
                serializedName: "statuses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceInstanceViewStatus"
                        }
                    }
                }
            }
        }
    }
};
const InstanceViewStatusesSummary = {
    type: {
        name: "Composite",
        className: "InstanceViewStatusesSummary",
        modelProperties: {
            statusesSummary: {
                serializedName: "statusesSummary",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StatusCodeCount"
                        }
                    }
                }
            }
        }
    }
};
const StatusCodeCount = {
    type: {
        name: "Composite",
        className: "StatusCodeCount",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CloudServiceListResult = {
    type: {
        name: "Composite",
        className: "CloudServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleInstances = {
    type: {
        name: "Composite",
        className: "RoleInstances",
        modelProperties: {
            roleInstances: {
                serializedName: "roleInstances",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const UpdateDomain = {
    type: {
        name: "Composite",
        className: "UpdateDomain",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateDomainListResult = {
    type: {
        name: "Composite",
        className: "UpdateDomainListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpdateDomain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSVersion = {
    type: {
        name: "Composite",
        className: "OSVersion",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OSVersionProperties"
                }
            }
        }
    }
};
const OSVersionProperties = {
    type: {
        name: "Composite",
        className: "OSVersionProperties",
        modelProperties: {
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            familyLabel: {
                serializedName: "familyLabel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            isActive: {
                serializedName: "isActive",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OSVersionListResult = {
    type: {
        name: "Composite",
        className: "OSVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OSVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSFamily = {
    type: {
        name: "Composite",
        className: "OSFamily",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OSFamilyProperties"
                }
            }
        }
    }
};
const OSFamilyProperties = {
    type: {
        name: "Composite",
        className: "OSFamilyProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            versions: {
                serializedName: "versions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OSVersionPropertiesBase"
                        }
                    }
                }
            }
        }
    }
};
const OSVersionPropertiesBase = {
    type: {
        name: "Composite",
        className: "OSVersionPropertiesBase",
        modelProperties: {
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            isActive: {
                serializedName: "isActive",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OSFamilyListResult = {
    type: {
        name: "Composite",
        className: "OSFamilyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OSFamily"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryArtifactSource = {
    type: {
        name: "Composite",
        className: "GalleryArtifactSource",
        modelProperties: {
            managedImage: {
                serializedName: "managedImage",
                type: {
                    name: "Composite",
                    className: "ManagedArtifact"
                }
            }
        }
    }
};
const ManagedArtifact = {
    type: {
        name: "Composite",
        className: "ManagedArtifact",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageReference = {
    type: {
        name: "Composite",
        className: "ImageReference",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            }, offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }, exactVersion: {
                serializedName: "exactVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharedGalleryImageId: {
                serializedName: "sharedGalleryImageId",
                type: {
                    name: "String"
                }
            }, communityGalleryImageId: {
                serializedName: "communityGalleryImageId",
                type: {
                    name: "String"
                }
            } })
    }
};
const DiskEncryptionSetParameters = {
    type: {
        name: "Composite",
        className: "DiskEncryptionSetParameters",
        modelProperties: Object.assign({}, SubResource.type.modelProperties)
    }
};
const VirtualMachineScaleSetIPConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, publicIPAddressConfiguration: {
                serializedName: "properties.publicIPAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetPublicIPAddressConfiguration"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, applicationGatewayBackendAddressPools: {
                serializedName: "properties.applicationGatewayBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancerBackendAddressPools: {
                serializedName: "properties.loadBalancerBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancerInboundNatPools: {
                serializedName: "properties.loadBalancerInboundNatPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const VirtualMachineScaleSetNetworkConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetNetworkConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, enableAcceleratedNetworking: {
                serializedName: "properties.enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            }, disableTcpStateTracking: {
                serializedName: "properties.disableTcpStateTracking",
                type: {
                    name: "Boolean"
                }
            }, enableFpga: {
                serializedName: "properties.enableFpga",
                type: {
                    name: "Boolean"
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetNetworkConfigurationDnsSettings"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetIPConfiguration"
                        }
                    }
                }
            }, enableIPForwarding: {
                serializedName: "properties.enableIPForwarding",
                type: {
                    name: "Boolean"
                }
            }, deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachineScaleSetUpdateIPConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, publicIPAddressConfiguration: {
                serializedName: "properties.publicIPAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdatePublicIPAddressConfiguration"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, applicationGatewayBackendAddressPools: {
                serializedName: "properties.applicationGatewayBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancerBackendAddressPools: {
                serializedName: "properties.loadBalancerBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancerInboundNatPools: {
                serializedName: "properties.loadBalancerInboundNatPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const VirtualMachineScaleSetUpdateNetworkConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdateNetworkConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, enableAcceleratedNetworking: {
                serializedName: "properties.enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            }, disableTcpStateTracking: {
                serializedName: "properties.disableTcpStateTracking",
                type: {
                    name: "Boolean"
                }
            }, enableFpga: {
                serializedName: "properties.enableFpga",
                type: {
                    name: "Boolean"
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetNetworkConfigurationDnsSettings"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineScaleSetUpdateIPConfiguration"
                        }
                    }
                }
            }, enableIPForwarding: {
                serializedName: "properties.enableIPForwarding",
                type: {
                    name: "Boolean"
                }
            }, deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedDiskParameters = {
    type: {
        name: "Composite",
        className: "ManagedDiskParameters",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            }, diskEncryptionSet: {
                serializedName: "diskEncryptionSet",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionSetParameters"
                }
            }, securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "VMDiskSecurityProfile"
                }
            } })
    }
};
const NetworkInterfaceReference = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceReference",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachineCaptureResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineCaptureResult",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { schema: {
                serializedName: "$schema",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, contentVersion: {
                serializedName: "contentVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "parameters",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, resources: {
                serializedName: "resources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "any"
                        }
                    }
                }
            } })
    }
};
const VirtualMachineImageResource = {
    type: {
        name: "Composite",
        className: "VirtualMachineImageResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            } })
    }
};
const SubResourceWithColocationStatus = {
    type: {
        name: "Composite",
        className: "SubResourceWithColocationStatus",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { colocationStatus: {
                serializedName: "colocationStatus",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            } })
    }
};
const VirtualMachineScaleSetExtension = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetExtension",
        modelProperties: Object.assign(Object.assign({}, SubResourceReadOnly.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisionAfterExtensions: {
                serializedName: "properties.provisionAfterExtensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const VirtualMachineScaleSetExtensionUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetExtensionUpdate",
        modelProperties: Object.assign(Object.assign({}, SubResourceReadOnly.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisionAfterExtensions: {
                serializedName: "properties.provisionAfterExtensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const VirtualMachineScaleSetVMExtension = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMExtension",
        modelProperties: Object.assign(Object.assign({}, SubResourceReadOnly.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineExtensionInstanceView"
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const VirtualMachineScaleSetVMExtensionUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMExtensionUpdate",
        modelProperties: Object.assign(Object.assign({}, SubResourceReadOnly.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const VirtualMachineScaleSet = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSet",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetIdentity"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, upgradePolicy: {
                serializedName: "properties.upgradePolicy",
                type: {
                    name: "Composite",
                    className: "UpgradePolicy"
                }
            }, automaticRepairsPolicy: {
                serializedName: "properties.automaticRepairsPolicy",
                type: {
                    name: "Composite",
                    className: "AutomaticRepairsPolicy"
                }
            }, virtualMachineProfile: {
                serializedName: "properties.virtualMachineProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetVMProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, overprovision: {
                serializedName: "properties.overprovision",
                type: {
                    name: "Boolean"
                }
            }, doNotRunExtensionsOnOverprovisionedVMs: {
                serializedName: "properties.doNotRunExtensionsOnOverprovisionedVMs",
                type: {
                    name: "Boolean"
                }
            }, uniqueId: {
                serializedName: "properties.uniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, singlePlacementGroup: {
                serializedName: "properties.singlePlacementGroup",
                type: {
                    name: "Boolean"
                }
            }, zoneBalance: {
                serializedName: "properties.zoneBalance",
                type: {
                    name: "Boolean"
                }
            }, platformFaultDomainCount: {
                serializedName: "properties.platformFaultDomainCount",
                type: {
                    name: "Number"
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostGroup: {
                serializedName: "properties.hostGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "AdditionalCapabilities"
                }
            }, scaleInPolicy: {
                serializedName: "properties.scaleInPolicy",
                type: {
                    name: "Composite",
                    className: "ScaleInPolicy"
                }
            }, orchestrationMode: {
                serializedName: "properties.orchestrationMode",
                type: {
                    name: "String"
                }
            }, spotRestorePolicy: {
                serializedName: "properties.spotRestorePolicy",
                type: {
                    name: "Composite",
                    className: "SpotRestorePolicy"
                }
            }, priorityMixPolicy: {
                serializedName: "properties.priorityMixPolicy",
                type: {
                    name: "Composite",
                    className: "PriorityMixPolicy"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const RollingUpgradeStatusInfo = {
    type: {
        name: "Composite",
        className: "RollingUpgradeStatusInfo",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { policy: {
                serializedName: "properties.policy",
                type: {
                    name: "Composite",
                    className: "RollingUpgradePolicy"
                }
            }, runningStatus: {
                serializedName: "properties.runningStatus",
                type: {
                    name: "Composite",
                    className: "RollingUpgradeRunningStatus"
                }
            }, progress: {
                serializedName: "properties.progress",
                type: {
                    name: "Composite",
                    className: "RollingUpgradeProgressInfo"
                }
            }, error: {
                serializedName: "properties.error",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            } })
    }
};
const VirtualMachineScaleSetVM = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVM",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { instanceId: {
                serializedName: "instanceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, resources: {
                serializedName: "resources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtension"
                        }
                    }
                }
            }, zones: {
                serializedName: "zones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineIdentity"
                }
            }, latestModelApplied: {
                serializedName: "properties.latestModelApplied",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, vmId: {
                serializedName: "properties.vmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetVMInstanceView"
                }
            }, hardwareProfile: {
                serializedName: "properties.hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "AdditionalCapabilities"
                }
            }, osProfile: {
                serializedName: "properties.osProfile",
                type: {
                    name: "Composite",
                    className: "OSProfile"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            }, networkProfileConfiguration: {
                serializedName: "properties.networkProfileConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetVMNetworkProfileConfiguration"
                }
            }, diagnosticsProfile: {
                serializedName: "properties.diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            }, availabilitySet: {
                serializedName: "properties.availabilitySet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, modelDefinitionApplied: {
                serializedName: "properties.modelDefinitionApplied",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, protectionPolicy: {
                serializedName: "properties.protectionPolicy",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetVMProtectionPolicy"
                }
            }, userData: {
                serializedName: "properties.userData",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachine = {
    type: {
        name: "Composite",
        className: "VirtualMachine",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, resources: {
                serializedName: "resources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtension"
                        }
                    }
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineIdentity"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, hardwareProfile: {
                serializedName: "properties.hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "AdditionalCapabilities"
                }
            }, osProfile: {
                serializedName: "properties.osProfile",
                type: {
                    name: "Composite",
                    className: "OSProfile"
                }
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            }, diagnosticsProfile: {
                serializedName: "properties.diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            }, availabilitySet: {
                serializedName: "properties.availabilitySet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualMachineScaleSet: {
                serializedName: "properties.virtualMachineScaleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "String"
                }
            }, evictionPolicy: {
                serializedName: "properties.evictionPolicy",
                type: {
                    name: "String"
                }
            }, billingProfile: {
                serializedName: "properties.billingProfile",
                type: {
                    name: "Composite",
                    className: "BillingProfile"
                }
            }, host: {
                serializedName: "properties.host",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostGroup: {
                serializedName: "properties.hostGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineInstanceView"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, vmId: {
                serializedName: "properties.vmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, extensionsTimeBudget: {
                serializedName: "properties.extensionsTimeBudget",
                type: {
                    name: "String"
                }
            }, platformFaultDomain: {
                serializedName: "properties.platformFaultDomain",
                type: {
                    name: "Number"
                }
            }, scheduledEventsProfile: {
                serializedName: "properties.scheduledEventsProfile",
                type: {
                    name: "Composite",
                    className: "ScheduledEventsProfile"
                }
            }, userData: {
                serializedName: "properties.userData",
                type: {
                    name: "String"
                }
            }, capacityReservation: {
                serializedName: "properties.capacityReservation",
                type: {
                    name: "Composite",
                    className: "CapacityReservationProfile"
                }
            }, applicationProfile: {
                serializedName: "properties.applicationProfile",
                type: {
                    name: "Composite",
                    className: "ApplicationProfile"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const VirtualMachineExtensionImage = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtensionImage",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { operatingSystem: {
                serializedName: "properties.operatingSystem",
                type: {
                    name: "String"
                }
            }, computeRole: {
                serializedName: "properties.computeRole",
                type: {
                    name: "String"
                }
            }, handlerSchema: {
                serializedName: "properties.handlerSchema",
                type: {
                    name: "String"
                }
            }, vmScaleSetEnabled: {
                serializedName: "properties.vmScaleSetEnabled",
                type: {
                    name: "Boolean"
                }
            }, supportsMultipleExtensions: {
                serializedName: "properties.supportsMultipleExtensions",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const AvailabilitySet = {
    type: {
        name: "Composite",
        className: "AvailabilitySet",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, platformUpdateDomainCount: {
                serializedName: "properties.platformUpdateDomainCount",
                type: {
                    name: "Number"
                }
            }, platformFaultDomainCount: {
                serializedName: "properties.platformFaultDomainCount",
                type: {
                    name: "Number"
                }
            }, virtualMachines: {
                serializedName: "properties.virtualMachines",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, statuses: {
                serializedName: "properties.statuses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            } })
    }
};
const ProximityPlacementGroup = {
    type: {
        name: "Composite",
        className: "ProximityPlacementGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, proximityPlacementGroupType: {
                serializedName: "properties.proximityPlacementGroupType",
                type: {
                    name: "String"
                }
            }, virtualMachines: {
                serializedName: "properties.virtualMachines",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceWithColocationStatus"
                        }
                    }
                }
            }, virtualMachineScaleSets: {
                serializedName: "properties.virtualMachineScaleSets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceWithColocationStatus"
                        }
                    }
                }
            }, availabilitySets: {
                serializedName: "properties.availabilitySets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceWithColocationStatus"
                        }
                    }
                }
            }, colocationStatus: {
                serializedName: "properties.colocationStatus",
                type: {
                    name: "Composite",
                    className: "InstanceViewStatus"
                }
            }, intent: {
                serializedName: "properties.intent",
                type: {
                    name: "Composite",
                    className: "ProximityPlacementGroupPropertiesIntent"
                }
            } })
    }
};
const DedicatedHostGroup = {
    type: {
        name: "Composite",
        className: "DedicatedHostGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, platformFaultDomainCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "properties.platformFaultDomainCount",
                type: {
                    name: "Number"
                }
            }, hosts: {
                serializedName: "properties.hosts",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "DedicatedHostGroupInstanceView"
                }
            }, supportAutomaticPlacement: {
                serializedName: "properties.supportAutomaticPlacement",
                type: {
                    name: "Boolean"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "DedicatedHostGroupPropertiesAdditionalCapabilities"
                }
            } })
    }
};
const DedicatedHost = {
    type: {
        name: "Composite",
        className: "DedicatedHost",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, platformFaultDomain: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.platformFaultDomain",
                type: {
                    name: "Number"
                }
            }, autoReplaceOnFailure: {
                serializedName: "properties.autoReplaceOnFailure",
                type: {
                    name: "Boolean"
                }
            }, hostId: {
                serializedName: "properties.hostId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualMachines: {
                serializedName: "properties.virtualMachines",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Windows_Server_Hybrid",
                        "Windows_Server_Perpetual"
                    ]
                }
            }, provisioningTime: {
                serializedName: "properties.provisioningTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "DedicatedHostInstanceView"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const SshPublicKeyResource = {
    type: {
        name: "Composite",
        className: "SshPublicKeyResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { publicKey: {
                serializedName: "properties.publicKey",
                type: {
                    name: "String"
                }
            } })
    }
};
const Image = {
    type: {
        name: "Composite",
        className: "Image",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sourceVirtualMachine: {
                serializedName: "properties.sourceVirtualMachine",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "ImageStorageProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            } })
    }
};
const RestorePointCollection = {
    type: {
        name: "Composite",
        className: "RestorePointCollection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "RestorePointCollectionSourceProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointCollectionId: {
                serializedName: "properties.restorePointCollectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePoints: {
                serializedName: "properties.restorePoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePoint"
                        }
                    }
                }
            } })
    }
};
const CapacityReservationGroup = {
    type: {
        name: "Composite",
        className: "CapacityReservationGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, capacityReservations: {
                serializedName: "properties.capacityReservations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, virtualMachinesAssociated: {
                serializedName: "properties.virtualMachinesAssociated",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "CapacityReservationGroupInstanceView"
                }
            } })
    }
};
const CapacityReservation = {
    type: {
        name: "Composite",
        className: "CapacityReservation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, reservationId: {
                serializedName: "properties.reservationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, platformFaultDomainCount: {
                serializedName: "properties.platformFaultDomainCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, virtualMachinesAssociated: {
                serializedName: "properties.virtualMachinesAssociated",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, provisioningTime: {
                serializedName: "properties.provisioningTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "CapacityReservationInstanceView"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const VirtualMachineRunCommand = {
    type: {
        name: "Composite",
        className: "VirtualMachineRunCommand",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "VirtualMachineRunCommandScriptSource"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandInputParameter"
                        }
                    }
                }
            }, protectedParameters: {
                serializedName: "properties.protectedParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandInputParameter"
                        }
                    }
                }
            }, asyncExecution: {
                defaultValue: false,
                serializedName: "properties.asyncExecution",
                type: {
                    name: "Boolean"
                }
            }, runAsUser: {
                serializedName: "properties.runAsUser",
                type: {
                    name: "String"
                }
            }, runAsPassword: {
                serializedName: "properties.runAsPassword",
                type: {
                    name: "String"
                }
            }, timeoutInSeconds: {
                serializedName: "properties.timeoutInSeconds",
                type: {
                    name: "Number"
                }
            }, outputBlobUri: {
                serializedName: "properties.outputBlobUri",
                type: {
                    name: "String"
                }
            }, errorBlobUri: {
                serializedName: "properties.errorBlobUri",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineRunCommandInstanceView"
                }
            } })
    }
};
const Disk = {
    type: {
        name: "Composite",
        className: "Disk",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedByExtended: {
                serializedName: "managedByExtended",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "DiskSku"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "PurchasePlanAutoGenerated"
                }
            }, supportedCapabilities: {
                serializedName: "properties.supportedCapabilities",
                type: {
                    name: "Composite",
                    className: "SupportedCapabilities"
                }
            }, creationData: {
                serializedName: "properties.creationData",
                type: {
                    name: "Composite",
                    className: "CreationData"
                }
            }, diskSizeGB: {
                serializedName: "properties.diskSizeGB",
                type: {
                    name: "Number"
                }
            }, diskSizeBytes: {
                serializedName: "properties.diskSizeBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, uniqueId: {
                serializedName: "properties.uniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryptionSettingsCollection: {
                serializedName: "properties.encryptionSettingsCollection",
                type: {
                    name: "Composite",
                    className: "EncryptionSettingsCollection"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, diskIopsReadWrite: {
                serializedName: "properties.diskIOPSReadWrite",
                type: {
                    name: "Number"
                }
            }, diskMBpsReadWrite: {
                serializedName: "properties.diskMBpsReadWrite",
                type: {
                    name: "Number"
                }
            }, diskIopsReadOnly: {
                serializedName: "properties.diskIOPSReadOnly",
                type: {
                    name: "Number"
                }
            }, diskMBpsReadOnly: {
                serializedName: "properties.diskMBpsReadOnly",
                type: {
                    name: "Number"
                }
            }, diskState: {
                serializedName: "properties.diskState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }, maxShares: {
                serializedName: "properties.maxShares",
                type: {
                    name: "Number"
                }
            }, shareInfo: {
                serializedName: "properties.shareInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareInfoElement"
                        }
                    }
                }
            }, networkAccessPolicy: {
                serializedName: "properties.networkAccessPolicy",
                type: {
                    name: "String"
                }
            }, diskAccessId: {
                serializedName: "properties.diskAccessId",
                type: {
                    name: "String"
                }
            }, burstingEnabledTime: {
                serializedName: "properties.burstingEnabledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, tier: {
                serializedName: "properties.tier",
                type: {
                    name: "String"
                }
            }, burstingEnabled: {
                serializedName: "properties.burstingEnabled",
                type: {
                    name: "Boolean"
                }
            }, propertyUpdatesInProgress: {
                serializedName: "properties.propertyUpdatesInProgress",
                type: {
                    name: "Composite",
                    className: "PropertyUpdatesInProgress"
                }
            }, supportsHibernation: {
                serializedName: "properties.supportsHibernation",
                type: {
                    name: "Boolean"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "DiskSecurityProfile"
                }
            }, completionPercent: {
                serializedName: "properties.completionPercent",
                type: {
                    name: "Number"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, dataAccessAuthMode: {
                serializedName: "properties.dataAccessAuthMode",
                type: {
                    name: "String"
                }
            }, optimizedForFrequentAttach: {
                serializedName: "properties.optimizedForFrequentAttach",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DiskAccess = {
    type: {
        name: "Composite",
        className: "DiskAccess",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const DiskEncryptionSet = {
    type: {
        name: "Composite",
        className: "DiskEncryptionSet",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EncryptionSetIdentity"
                }
            }, encryptionType: {
                serializedName: "properties.encryptionType",
                type: {
                    name: "String"
                }
            }, activeKey: {
                serializedName: "properties.activeKey",
                type: {
                    name: "Composite",
                    className: "KeyForDiskEncryptionSet"
                }
            }, previousKeys: {
                serializedName: "properties.previousKeys",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyForDiskEncryptionSet"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rotationToLatestKeyVersionEnabled: {
                serializedName: "properties.rotationToLatestKeyVersionEnabled",
                type: {
                    name: "Boolean"
                }
            }, lastKeyRotationTimestamp: {
                serializedName: "properties.lastKeyRotationTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, autoKeyRotationError: {
                serializedName: "properties.autoKeyRotationError",
                type: {
                    name: "Composite",
                    className: "ApiError"
                }
            }, federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "String"
                }
            } })
    }
};
const Snapshot = {
    type: {
        name: "Composite",
        className: "Snapshot",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SnapshotSku"
                }
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "PurchasePlanAutoGenerated"
                }
            }, supportedCapabilities: {
                serializedName: "properties.supportedCapabilities",
                type: {
                    name: "Composite",
                    className: "SupportedCapabilities"
                }
            }, creationData: {
                serializedName: "properties.creationData",
                type: {
                    name: "Composite",
                    className: "CreationData"
                }
            }, diskSizeGB: {
                serializedName: "properties.diskSizeGB",
                type: {
                    name: "Number"
                }
            }, diskSizeBytes: {
                serializedName: "properties.diskSizeBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, diskState: {
                serializedName: "properties.diskState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueId: {
                serializedName: "properties.uniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryptionSettingsCollection: {
                serializedName: "properties.encryptionSettingsCollection",
                type: {
                    name: "Composite",
                    className: "EncryptionSettingsCollection"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, incremental: {
                serializedName: "properties.incremental",
                type: {
                    name: "Boolean"
                }
            }, incrementalSnapshotFamilyId: {
                serializedName: "properties.incrementalSnapshotFamilyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }, networkAccessPolicy: {
                serializedName: "properties.networkAccessPolicy",
                type: {
                    name: "String"
                }
            }, diskAccessId: {
                serializedName: "properties.diskAccessId",
                type: {
                    name: "String"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "DiskSecurityProfile"
                }
            }, supportsHibernation: {
                serializedName: "properties.supportsHibernation",
                type: {
                    name: "Boolean"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, completionPercent: {
                serializedName: "properties.completionPercent",
                type: {
                    name: "Number"
                }
            }, copyCompletionError: {
                serializedName: "properties.copyCompletionError",
                type: {
                    name: "Composite",
                    className: "CopyCompletionError"
                }
            }, dataAccessAuthMode: {
                serializedName: "properties.dataAccessAuthMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const Gallery = {
    type: {
        name: "Composite",
        className: "Gallery",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryIdentifier"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharingProfile: {
                serializedName: "properties.sharingProfile",
                type: {
                    name: "Composite",
                    className: "SharingProfile"
                }
            }, softDeletePolicy: {
                serializedName: "properties.softDeletePolicy",
                type: {
                    name: "Composite",
                    className: "SoftDeletePolicy"
                }
            }, sharingStatus: {
                serializedName: "properties.sharingStatus",
                type: {
                    name: "Composite",
                    className: "SharingStatus"
                }
            } })
    }
};
const GalleryImage = {
    type: {
        name: "Composite",
        className: "GalleryImage",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, eula: {
                serializedName: "properties.eula",
                type: {
                    name: "String"
                }
            }, privacyStatementUri: {
                serializedName: "properties.privacyStatementUri",
                type: {
                    name: "String"
                }
            }, releaseNoteUri: {
                serializedName: "properties.releaseNoteUri",
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, osState: {
                serializedName: "properties.osState",
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryImageIdentifier"
                }
            }, recommended: {
                serializedName: "properties.recommended",
                type: {
                    name: "Composite",
                    className: "RecommendedMachineConfiguration"
                }
            }, disallowed: {
                serializedName: "properties.disallowed",
                type: {
                    name: "Composite",
                    className: "Disallowed"
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "ImagePurchasePlan"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, features: {
                serializedName: "properties.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImageFeature"
                        }
                    }
                }
            }, architecture: {
                serializedName: "properties.architecture",
                type: {
                    name: "String"
                }
            } })
    }
};
const GalleryImageVersion = {
    type: {
        name: "Composite",
        className: "GalleryImageVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { publishingProfile: {
                serializedName: "properties.publishingProfile",
                type: {
                    name: "Composite",
                    className: "GalleryImageVersionPublishingProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "GalleryImageVersionStorageProfile"
                }
            }, replicationStatus: {
                serializedName: "properties.replicationStatus",
                type: {
                    name: "Composite",
                    className: "ReplicationStatus"
                }
            } })
    }
};
const GalleryApplication = {
    type: {
        name: "Composite",
        className: "GalleryApplication",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, eula: {
                serializedName: "properties.eula",
                type: {
                    name: "String"
                }
            }, privacyStatementUri: {
                serializedName: "properties.privacyStatementUri",
                type: {
                    name: "String"
                }
            }, releaseNoteUri: {
                serializedName: "properties.releaseNoteUri",
                type: {
                    name: "String"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, supportedOSType: {
                serializedName: "properties.supportedOSType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            } })
    }
};
const GalleryApplicationVersion = {
    type: {
        name: "Composite",
        className: "GalleryApplicationVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { publishingProfile: {
                serializedName: "properties.publishingProfile",
                type: {
                    name: "Composite",
                    className: "GalleryApplicationVersionPublishingProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, replicationStatus: {
                serializedName: "properties.replicationStatus",
                type: {
                    name: "Composite",
                    className: "ReplicationStatus"
                }
            } })
    }
};
const VirtualMachineScaleSetUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetIdentity"
                }
            }, upgradePolicy: {
                serializedName: "properties.upgradePolicy",
                type: {
                    name: "Composite",
                    className: "UpgradePolicy"
                }
            }, automaticRepairsPolicy: {
                serializedName: "properties.automaticRepairsPolicy",
                type: {
                    name: "Composite",
                    className: "AutomaticRepairsPolicy"
                }
            }, virtualMachineProfile: {
                serializedName: "properties.virtualMachineProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineScaleSetUpdateVMProfile"
                }
            }, overprovision: {
                serializedName: "properties.overprovision",
                type: {
                    name: "Boolean"
                }
            }, doNotRunExtensionsOnOverprovisionedVMs: {
                serializedName: "properties.doNotRunExtensionsOnOverprovisionedVMs",
                type: {
                    name: "Boolean"
                }
            }, singlePlacementGroup: {
                serializedName: "properties.singlePlacementGroup",
                type: {
                    name: "Boolean"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "AdditionalCapabilities"
                }
            }, scaleInPolicy: {
                serializedName: "properties.scaleInPolicy",
                type: {
                    name: "Composite",
                    className: "ScaleInPolicy"
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const VirtualMachineExtensionUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtensionUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const VirtualMachineUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VirtualMachineIdentity"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hardwareProfile: {
                serializedName: "properties.hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "AdditionalCapabilities"
                }
            }, osProfile: {
                serializedName: "properties.osProfile",
                type: {
                    name: "Composite",
                    className: "OSProfile"
                }
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            }, diagnosticsProfile: {
                serializedName: "properties.diagnosticsProfile",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProfile"
                }
            }, availabilitySet: {
                serializedName: "properties.availabilitySet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualMachineScaleSet: {
                serializedName: "properties.virtualMachineScaleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "String"
                }
            }, evictionPolicy: {
                serializedName: "properties.evictionPolicy",
                type: {
                    name: "String"
                }
            }, billingProfile: {
                serializedName: "properties.billingProfile",
                type: {
                    name: "Composite",
                    className: "BillingProfile"
                }
            }, host: {
                serializedName: "properties.host",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostGroup: {
                serializedName: "properties.hostGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineInstanceView"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, vmId: {
                serializedName: "properties.vmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, extensionsTimeBudget: {
                serializedName: "properties.extensionsTimeBudget",
                type: {
                    name: "String"
                }
            }, platformFaultDomain: {
                serializedName: "properties.platformFaultDomain",
                type: {
                    name: "Number"
                }
            }, scheduledEventsProfile: {
                serializedName: "properties.scheduledEventsProfile",
                type: {
                    name: "Composite",
                    className: "ScheduledEventsProfile"
                }
            }, userData: {
                serializedName: "properties.userData",
                type: {
                    name: "String"
                }
            }, capacityReservation: {
                serializedName: "properties.capacityReservation",
                type: {
                    name: "Composite",
                    className: "CapacityReservationProfile"
                }
            }, applicationProfile: {
                serializedName: "properties.applicationProfile",
                type: {
                    name: "Composite",
                    className: "ApplicationProfile"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const AvailabilitySetUpdate = {
    type: {
        name: "Composite",
        className: "AvailabilitySetUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, platformUpdateDomainCount: {
                serializedName: "properties.platformUpdateDomainCount",
                type: {
                    name: "Number"
                }
            }, platformFaultDomainCount: {
                serializedName: "properties.platformFaultDomainCount",
                type: {
                    name: "Number"
                }
            }, virtualMachines: {
                serializedName: "properties.virtualMachines",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, statuses: {
                serializedName: "properties.statuses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceViewStatus"
                        }
                    }
                }
            } })
    }
};
const ProximityPlacementGroupUpdate = {
    type: {
        name: "Composite",
        className: "ProximityPlacementGroupUpdate",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const DedicatedHostGroupUpdate = {
    type: {
        name: "Composite",
        className: "DedicatedHostGroupUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, platformFaultDomainCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "properties.platformFaultDomainCount",
                type: {
                    name: "Number"
                }
            }, hosts: {
                serializedName: "properties.hosts",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "DedicatedHostGroupInstanceView"
                }
            }, supportAutomaticPlacement: {
                serializedName: "properties.supportAutomaticPlacement",
                type: {
                    name: "Boolean"
                }
            }, additionalCapabilities: {
                serializedName: "properties.additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "DedicatedHostGroupPropertiesAdditionalCapabilities"
                }
            } })
    }
};
const DedicatedHostUpdate = {
    type: {
        name: "Composite",
        className: "DedicatedHostUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { platformFaultDomain: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.platformFaultDomain",
                type: {
                    name: "Number"
                }
            }, autoReplaceOnFailure: {
                serializedName: "properties.autoReplaceOnFailure",
                type: {
                    name: "Boolean"
                }
            }, hostId: {
                serializedName: "properties.hostId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualMachines: {
                serializedName: "properties.virtualMachines",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Windows_Server_Hybrid",
                        "Windows_Server_Perpetual"
                    ]
                }
            }, provisioningTime: {
                serializedName: "properties.provisioningTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "DedicatedHostInstanceView"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const SshPublicKeyUpdateResource = {
    type: {
        name: "Composite",
        className: "SshPublicKeyUpdateResource",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { publicKey: {
                serializedName: "properties.publicKey",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageUpdate = {
    type: {
        name: "Composite",
        className: "ImageUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { sourceVirtualMachine: {
                serializedName: "properties.sourceVirtualMachine",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "ImageStorageProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            } })
    }
};
const RestorePointCollectionUpdate = {
    type: {
        name: "Composite",
        className: "RestorePointCollectionUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "RestorePointCollectionSourceProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointCollectionId: {
                serializedName: "properties.restorePointCollectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePoints: {
                serializedName: "properties.restorePoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePoint"
                        }
                    }
                }
            } })
    }
};
const CapacityReservationGroupUpdate = {
    type: {
        name: "Composite",
        className: "CapacityReservationGroupUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { capacityReservations: {
                serializedName: "properties.capacityReservations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, virtualMachinesAssociated: {
                serializedName: "properties.virtualMachinesAssociated",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "CapacityReservationGroupInstanceView"
                }
            } })
    }
};
const CapacityReservationUpdate = {
    type: {
        name: "Composite",
        className: "CapacityReservationUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, reservationId: {
                serializedName: "properties.reservationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, platformFaultDomainCount: {
                serializedName: "properties.platformFaultDomainCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, virtualMachinesAssociated: {
                serializedName: "properties.virtualMachinesAssociated",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResourceReadOnly"
                        }
                    }
                }
            }, provisioningTime: {
                serializedName: "properties.provisioningTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "CapacityReservationInstanceView"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const VirtualMachineRunCommandUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineRunCommandUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResource.type.modelProperties), { source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "VirtualMachineRunCommandScriptSource"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandInputParameter"
                        }
                    }
                }
            }, protectedParameters: {
                serializedName: "properties.protectedParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandInputParameter"
                        }
                    }
                }
            }, asyncExecution: {
                defaultValue: false,
                serializedName: "properties.asyncExecution",
                type: {
                    name: "Boolean"
                }
            }, runAsUser: {
                serializedName: "properties.runAsUser",
                type: {
                    name: "String"
                }
            }, runAsPassword: {
                serializedName: "properties.runAsPassword",
                type: {
                    name: "String"
                }
            }, timeoutInSeconds: {
                serializedName: "properties.timeoutInSeconds",
                type: {
                    name: "Number"
                }
            }, outputBlobUri: {
                serializedName: "properties.outputBlobUri",
                type: {
                    name: "String"
                }
            }, errorBlobUri: {
                serializedName: "properties.errorBlobUri",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineRunCommandInstanceView"
                }
            } })
    }
};
const VirtualMachineScaleSetVMReimageParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetVMReimageParameters",
        modelProperties: Object.assign({}, VirtualMachineReimageParameters.type.modelProperties)
    }
};
const VirtualMachineExtension = {
    type: {
        name: "Composite",
        className: "VirtualMachineExtension",
        modelProperties: Object.assign(Object.assign({}, ResourceWithOptionalLocation.type.modelProperties), { forceUpdateTag: {
                serializedName: "properties.forceUpdateTag",
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, typeHandlerVersion: {
                serializedName: "properties.typeHandlerVersion",
                type: {
                    name: "String"
                }
            }, autoUpgradeMinorVersion: {
                serializedName: "properties.autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticUpgrade: {
                serializedName: "properties.enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            }, settings: {
                serializedName: "properties.settings",
                type: {
                    name: "any"
                }
            }, protectedSettings: {
                serializedName: "properties.protectedSettings",
                type: {
                    name: "any"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "VirtualMachineExtensionInstanceView"
                }
            }, suppressFailures: {
                serializedName: "properties.suppressFailures",
                type: {
                    name: "Boolean"
                }
            }, protectedSettingsFromKeyVault: {
                serializedName: "properties.protectedSettingsFromKeyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultSecretReference"
                }
            } })
    }
};
const DedicatedHostInstanceViewWithName = {
    type: {
        name: "Composite",
        className: "DedicatedHostInstanceViewWithName",
        modelProperties: Object.assign(Object.assign({}, DedicatedHostInstanceView.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageOSDisk = {
    type: {
        name: "Composite",
        className: "ImageOSDisk",
        modelProperties: Object.assign(Object.assign({}, ImageDisk.type.modelProperties), { osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, osState: {
                serializedName: "osState",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            } })
    }
};
const ImageDataDisk = {
    type: {
        name: "Composite",
        className: "ImageDataDisk",
        modelProperties: Object.assign(Object.assign({}, ImageDisk.type.modelProperties), { lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const RestorePoint = {
    type: {
        name: "Composite",
        className: "RestorePoint",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { excludeDisks: {
                serializedName: "properties.excludeDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiEntityReference"
                        }
                    }
                }
            }, sourceMetadata: {
                serializedName: "properties.sourceMetadata",
                type: {
                    name: "Composite",
                    className: "RestorePointSourceMetadata"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, consistencyMode: {
                serializedName: "properties.consistencyMode",
                type: {
                    name: "String"
                }
            }, timeCreated: {
                serializedName: "properties.timeCreated",
                type: {
                    name: "DateTime"
                }
            }, sourceRestorePoint: {
                serializedName: "properties.sourceRestorePoint",
                type: {
                    name: "Composite",
                    className: "ApiEntityReference"
                }
            }, instanceView: {
                serializedName: "properties.instanceView",
                type: {
                    name: "Composite",
                    className: "RestorePointInstanceView"
                }
            } })
    }
};
const CapacityReservationInstanceViewWithName = {
    type: {
        name: "Composite",
        className: "CapacityReservationInstanceViewWithName",
        modelProperties: Object.assign(Object.assign({}, CapacityReservationInstanceView.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RequestRateByIntervalInput = {
    type: {
        name: "Composite",
        className: "RequestRateByIntervalInput",
        modelProperties: Object.assign(Object.assign({}, LogAnalyticsInputBase.type.modelProperties), { intervalLength: {
                serializedName: "intervalLength",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["ThreeMins", "FiveMins", "ThirtyMins", "SixtyMins"]
                }
            } })
    }
};
const ThrottledRequestsInput = {
    type: {
        name: "Composite",
        className: "ThrottledRequestsInput",
        modelProperties: Object.assign({}, LogAnalyticsInputBase.type.modelProperties)
    }
};
const RunCommandDocument = {
    type: {
        name: "Composite",
        className: "RunCommandDocument",
        modelProperties: Object.assign(Object.assign({}, RunCommandDocumentBase.type.modelProperties), { script: {
                serializedName: "script",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RunCommandParameterDefinition"
                        }
                    }
                }
            } })
    }
};
const DiskRestorePoint = {
    type: {
        name: "Composite",
        className: "DiskRestorePoint",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { timeCreated: {
                serializedName: "properties.timeCreated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, sourceResourceId: {
                serializedName: "properties.sourceResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "PurchasePlanAutoGenerated"
                }
            }, supportedCapabilities: {
                serializedName: "properties.supportedCapabilities",
                type: {
                    name: "Composite",
                    className: "SupportedCapabilities"
                }
            }, familyId: {
                serializedName: "properties.familyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sourceUniqueId: {
                serializedName: "properties.sourceUniqueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }, supportsHibernation: {
                serializedName: "properties.supportsHibernation",
                type: {
                    name: "Boolean"
                }
            }, networkAccessPolicy: {
                serializedName: "properties.networkAccessPolicy",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, diskAccessId: {
                serializedName: "properties.diskAccessId",
                type: {
                    name: "String"
                }
            }, completionPercent: {
                serializedName: "properties.completionPercent",
                type: {
                    name: "Number"
                }
            }, replicationState: {
                serializedName: "properties.replicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sourceResourceLocation: {
                serializedName: "properties.sourceResourceLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "DiskSecurityProfile"
                }
            } })
    }
};
const GalleryUpdate = {
    type: {
        name: "Composite",
        className: "GalleryUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResourceDefinition.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryIdentifier"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharingProfile: {
                serializedName: "properties.sharingProfile",
                type: {
                    name: "Composite",
                    className: "SharingProfile"
                }
            }, softDeletePolicy: {
                serializedName: "properties.softDeletePolicy",
                type: {
                    name: "Composite",
                    className: "SoftDeletePolicy"
                }
            }, sharingStatus: {
                serializedName: "properties.sharingStatus",
                type: {
                    name: "Composite",
                    className: "SharingStatus"
                }
            } })
    }
};
const GalleryImageUpdate = {
    type: {
        name: "Composite",
        className: "GalleryImageUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResourceDefinition.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, eula: {
                serializedName: "properties.eula",
                type: {
                    name: "String"
                }
            }, privacyStatementUri: {
                serializedName: "properties.privacyStatementUri",
                type: {
                    name: "String"
                }
            }, releaseNoteUri: {
                serializedName: "properties.releaseNoteUri",
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, osState: {
                serializedName: "properties.osState",
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryImageIdentifier"
                }
            }, recommended: {
                serializedName: "properties.recommended",
                type: {
                    name: "Composite",
                    className: "RecommendedMachineConfiguration"
                }
            }, disallowed: {
                serializedName: "properties.disallowed",
                type: {
                    name: "Composite",
                    className: "Disallowed"
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "ImagePurchasePlan"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, features: {
                serializedName: "properties.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImageFeature"
                        }
                    }
                }
            }, architecture: {
                serializedName: "properties.architecture",
                type: {
                    name: "String"
                }
            } })
    }
};
const GalleryImageVersionUpdate = {
    type: {
        name: "Composite",
        className: "GalleryImageVersionUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResourceDefinition.type.modelProperties), { publishingProfile: {
                serializedName: "properties.publishingProfile",
                type: {
                    name: "Composite",
                    className: "GalleryImageVersionPublishingProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "GalleryImageVersionStorageProfile"
                }
            }, replicationStatus: {
                serializedName: "properties.replicationStatus",
                type: {
                    name: "Composite",
                    className: "ReplicationStatus"
                }
            } })
    }
};
const GalleryApplicationUpdate = {
    type: {
        name: "Composite",
        className: "GalleryApplicationUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResourceDefinition.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, eula: {
                serializedName: "properties.eula",
                type: {
                    name: "String"
                }
            }, privacyStatementUri: {
                serializedName: "properties.privacyStatementUri",
                type: {
                    name: "String"
                }
            }, releaseNoteUri: {
                serializedName: "properties.releaseNoteUri",
                type: {
                    name: "String"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, supportedOSType: {
                serializedName: "properties.supportedOSType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            } })
    }
};
const GalleryApplicationVersionUpdate = {
    type: {
        name: "Composite",
        className: "GalleryApplicationVersionUpdate",
        modelProperties: Object.assign(Object.assign({}, UpdateResourceDefinition.type.modelProperties), { publishingProfile: {
                serializedName: "properties.publishingProfile",
                type: {
                    name: "Composite",
                    className: "GalleryApplicationVersionPublishingProfile"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, replicationStatus: {
                serializedName: "properties.replicationStatus",
                type: {
                    name: "Composite",
                    className: "ReplicationStatus"
                }
            } })
    }
};
const GalleryImageVersionPublishingProfile = {
    type: {
        name: "Composite",
        className: "GalleryImageVersionPublishingProfile",
        modelProperties: Object.assign({}, GalleryArtifactPublishingProfileBase.type.modelProperties)
    }
};
const GalleryApplicationVersionPublishingProfile = {
    type: {
        name: "Composite",
        className: "GalleryApplicationVersionPublishingProfile",
        modelProperties: Object.assign(Object.assign({}, GalleryArtifactPublishingProfileBase.type.modelProperties), { source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "UserArtifactSource"
                }
            }, manageActions: {
                serializedName: "manageActions",
                type: {
                    name: "Composite",
                    className: "UserArtifactManage"
                }
            }, settings: {
                serializedName: "settings",
                type: {
                    name: "Composite",
                    className: "UserArtifactSettings"
                }
            }, advancedSettings: {
                serializedName: "advancedSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, enableHealthCheck: {
                serializedName: "enableHealthCheck",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const OSDiskImageEncryption = {
    type: {
        name: "Composite",
        className: "OSDiskImageEncryption",
        modelProperties: Object.assign(Object.assign({}, DiskImageEncryption.type.modelProperties), { securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "OSDiskImageSecurityProfile"
                }
            } })
    }
};
const DataDiskImageEncryption = {
    type: {
        name: "Composite",
        className: "DataDiskImageEncryption",
        modelProperties: Object.assign(Object.assign({}, DiskImageEncryption.type.modelProperties), { lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const GalleryOSDiskImage = {
    type: {
        name: "Composite",
        className: "GalleryOSDiskImage",
        modelProperties: Object.assign({}, GalleryDiskImage.type.modelProperties)
    }
};
const GalleryDataDiskImage = {
    type: {
        name: "Composite",
        className: "GalleryDataDiskImage",
        modelProperties: Object.assign(Object.assign({}, GalleryDiskImage.type.modelProperties), { lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const PirSharedGalleryResource = {
    type: {
        name: "Composite",
        className: "PirSharedGalleryResource",
        modelProperties: Object.assign(Object.assign({}, PirResource.type.modelProperties), { uniqueId: {
                serializedName: "identifier.uniqueId",
                type: {
                    name: "String"
                }
            } })
    }
};
const SharedGalleryOSDiskImage = {
    type: {
        name: "Composite",
        className: "SharedGalleryOSDiskImage",
        modelProperties: Object.assign({}, SharedGalleryDiskImage.type.modelProperties)
    }
};
const SharedGalleryDataDiskImage = {
    type: {
        name: "Composite",
        className: "SharedGalleryDataDiskImage",
        modelProperties: Object.assign(Object.assign({}, SharedGalleryDiskImage.type.modelProperties), { lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const CommunityGallery = {
    type: {
        name: "Composite",
        className: "CommunityGallery",
        modelProperties: Object.assign({}, PirCommunityGalleryResource.type.modelProperties)
    }
};
const CommunityGalleryImage = {
    type: {
        name: "Composite",
        className: "CommunityGalleryImage",
        modelProperties: Object.assign(Object.assign({}, PirCommunityGalleryResource.type.modelProperties), { osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, osState: {
                serializedName: "properties.osState",
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryImageIdentifier"
                }
            }, recommended: {
                serializedName: "properties.recommended",
                type: {
                    name: "Composite",
                    className: "RecommendedMachineConfiguration"
                }
            }, disallowed: {
                serializedName: "properties.disallowed",
                type: {
                    name: "Composite",
                    className: "Disallowed"
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, features: {
                serializedName: "properties.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImageFeature"
                        }
                    }
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "ImagePurchasePlan"
                }
            }, architecture: {
                serializedName: "properties.architecture",
                type: {
                    name: "String"
                }
            }, privacyStatementUri: {
                serializedName: "properties.privacyStatementUri",
                type: {
                    name: "String"
                }
            }, eula: {
                serializedName: "properties.eula",
                type: {
                    name: "String"
                }
            } })
    }
};
const CommunityGalleryImageVersion = {
    type: {
        name: "Composite",
        className: "CommunityGalleryImageVersion",
        modelProperties: Object.assign(Object.assign({}, PirCommunityGalleryResource.type.modelProperties), { publishedDate: {
                serializedName: "properties.publishedDate",
                type: {
                    name: "DateTime"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, excludeFromLatest: {
                serializedName: "properties.excludeFromLatest",
                type: {
                    name: "Boolean"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "SharedGalleryImageVersionStorageProfile"
                }
            } })
    }
};
const VirtualMachineImage = {
    type: {
        name: "Composite",
        className: "VirtualMachineImage",
        modelProperties: Object.assign(Object.assign({}, VirtualMachineImageResource.type.modelProperties), { plan: {
                serializedName: "properties.plan",
                type: {
                    name: "Composite",
                    className: "PurchasePlan"
                }
            }, osDiskImage: {
                serializedName: "properties.osDiskImage",
                type: {
                    name: "Composite",
                    className: "OSDiskImage"
                }
            }, dataDiskImages: {
                serializedName: "properties.dataDiskImages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDiskImage"
                        }
                    }
                }
            }, automaticOSUpgradeProperties: {
                serializedName: "properties.automaticOSUpgradeProperties",
                type: {
                    name: "Composite",
                    className: "AutomaticOSUpgradeProperties"
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, disallowed: {
                serializedName: "properties.disallowed",
                type: {
                    name: "Composite",
                    className: "DisallowedConfiguration"
                }
            }, features: {
                serializedName: "properties.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageFeature"
                        }
                    }
                }
            }, architecture: {
                serializedName: "properties.architecture",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachineScaleSetReimageParameters = {
    type: {
        name: "Composite",
        className: "VirtualMachineScaleSetReimageParameters",
        modelProperties: Object.assign(Object.assign({}, VirtualMachineScaleSetVMReimageParameters.type.modelProperties), { instanceIds: {
                serializedName: "instanceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SharedGallery = {
    type: {
        name: "Composite",
        className: "SharedGallery",
        modelProperties: Object.assign({}, PirSharedGalleryResource.type.modelProperties)
    }
};
const SharedGalleryImage = {
    type: {
        name: "Composite",
        className: "SharedGalleryImage",
        modelProperties: Object.assign(Object.assign({}, PirSharedGalleryResource.type.modelProperties), { osType: {
                serializedName: "properties.osType",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, osState: {
                serializedName: "properties.osState",
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, identifier: {
                serializedName: "properties.identifier",
                type: {
                    name: "Composite",
                    className: "GalleryImageIdentifier"
                }
            }, recommended: {
                serializedName: "properties.recommended",
                type: {
                    name: "Composite",
                    className: "RecommendedMachineConfiguration"
                }
            }, disallowed: {
                serializedName: "properties.disallowed",
                type: {
                    name: "Composite",
                    className: "Disallowed"
                }
            }, hyperVGeneration: {
                serializedName: "properties.hyperVGeneration",
                type: {
                    name: "String"
                }
            }, features: {
                serializedName: "properties.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImageFeature"
                        }
                    }
                }
            }, purchasePlan: {
                serializedName: "properties.purchasePlan",
                type: {
                    name: "Composite",
                    className: "ImagePurchasePlan"
                }
            }, architecture: {
                serializedName: "properties.architecture",
                type: {
                    name: "String"
                }
            } })
    }
};
const SharedGalleryImageVersion = {
    type: {
        name: "Composite",
        className: "SharedGalleryImageVersion",
        modelProperties: Object.assign(Object.assign({}, PirSharedGalleryResource.type.modelProperties), { publishedDate: {
                serializedName: "properties.publishedDate",
                type: {
                    name: "DateTime"
                }
            }, endOfLifeDate: {
                serializedName: "properties.endOfLifeDate",
                type: {
                    name: "DateTime"
                }
            }, excludeFromLatest: {
                serializedName: "properties.excludeFromLatest",
                type: {
                    name: "Boolean"
                }
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "SharedGalleryImageVersionStorageProfile"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ComputeOperationListResult: ComputeOperationListResult,
    ComputeOperationValue: ComputeOperationValue,
    CloudError: CloudError,
    ApiError: ApiError,
    ApiErrorBase: ApiErrorBase,
    InnerError: InnerError,
    ListUsagesResult: ListUsagesResult,
    Usage: Usage,
    UsageName: UsageName,
    VirtualMachineSizeListResult: VirtualMachineSizeListResult,
    VirtualMachineSize: VirtualMachineSize,
    VirtualMachineScaleSetListResult: VirtualMachineScaleSetListResult,
    Sku: Sku,
    Plan: Plan,
    UpgradePolicy: UpgradePolicy,
    RollingUpgradePolicy: RollingUpgradePolicy,
    AutomaticOSUpgradePolicy: AutomaticOSUpgradePolicy,
    AutomaticRepairsPolicy: AutomaticRepairsPolicy,
    VirtualMachineScaleSetVMProfile: VirtualMachineScaleSetVMProfile,
    VirtualMachineScaleSetOSProfile: VirtualMachineScaleSetOSProfile,
    WindowsConfiguration: WindowsConfiguration,
    AdditionalUnattendContent: AdditionalUnattendContent,
    PatchSettings: PatchSettings,
    WindowsVMGuestPatchAutomaticByPlatformSettings: WindowsVMGuestPatchAutomaticByPlatformSettings,
    WinRMConfiguration: WinRMConfiguration,
    WinRMListener: WinRMListener,
    LinuxConfiguration: LinuxConfiguration,
    SshConfiguration: SshConfiguration,
    SshPublicKey: SshPublicKey,
    LinuxPatchSettings: LinuxPatchSettings,
    LinuxVMGuestPatchAutomaticByPlatformSettings: LinuxVMGuestPatchAutomaticByPlatformSettings,
    VaultSecretGroup: VaultSecretGroup,
    SubResource: SubResource,
    VaultCertificate: VaultCertificate,
    VirtualMachineScaleSetStorageProfile: VirtualMachineScaleSetStorageProfile,
    VirtualMachineScaleSetOSDisk: VirtualMachineScaleSetOSDisk,
    DiffDiskSettings: DiffDiskSettings,
    VirtualHardDisk: VirtualHardDisk,
    VirtualMachineScaleSetManagedDiskParameters: VirtualMachineScaleSetManagedDiskParameters,
    VMDiskSecurityProfile: VMDiskSecurityProfile,
    VirtualMachineScaleSetDataDisk: VirtualMachineScaleSetDataDisk,
    VirtualMachineScaleSetNetworkProfile: VirtualMachineScaleSetNetworkProfile,
    ApiEntityReference: ApiEntityReference,
    VirtualMachineScaleSetNetworkConfigurationDnsSettings: VirtualMachineScaleSetNetworkConfigurationDnsSettings,
    VirtualMachineScaleSetPublicIPAddressConfiguration: VirtualMachineScaleSetPublicIPAddressConfiguration,
    VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings: VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings,
    VirtualMachineScaleSetIpTag: VirtualMachineScaleSetIpTag,
    PublicIPAddressSku: PublicIPAddressSku,
    SecurityProfile: SecurityProfile,
    UefiSettings: UefiSettings,
    DiagnosticsProfile: DiagnosticsProfile,
    BootDiagnostics: BootDiagnostics,
    VirtualMachineScaleSetExtensionProfile: VirtualMachineScaleSetExtensionProfile,
    KeyVaultSecretReference: KeyVaultSecretReference,
    SubResourceReadOnly: SubResourceReadOnly,
    BillingProfile: BillingProfile,
    ScheduledEventsProfile: ScheduledEventsProfile,
    TerminateNotificationProfile: TerminateNotificationProfile,
    CapacityReservationProfile: CapacityReservationProfile,
    ApplicationProfile: ApplicationProfile,
    VMGalleryApplication: VMGalleryApplication,
    VirtualMachineScaleSetHardwareProfile: VirtualMachineScaleSetHardwareProfile,
    VMSizeProperties: VMSizeProperties,
    AdditionalCapabilities: AdditionalCapabilities,
    ScaleInPolicy: ScaleInPolicy,
    SpotRestorePolicy: SpotRestorePolicy,
    PriorityMixPolicy: PriorityMixPolicy,
    VirtualMachineScaleSetIdentity: VirtualMachineScaleSetIdentity,
    UserAssignedIdentitiesValue: UserAssignedIdentitiesValue,
    ExtendedLocation: ExtendedLocation,
    Resource: Resource,
    VirtualMachineScaleSetUpdateVMProfile: VirtualMachineScaleSetUpdateVMProfile,
    VirtualMachineScaleSetUpdateOSProfile: VirtualMachineScaleSetUpdateOSProfile,
    VirtualMachineScaleSetUpdateStorageProfile: VirtualMachineScaleSetUpdateStorageProfile,
    VirtualMachineScaleSetUpdateOSDisk: VirtualMachineScaleSetUpdateOSDisk,
    VirtualMachineScaleSetUpdateNetworkProfile: VirtualMachineScaleSetUpdateNetworkProfile,
    VirtualMachineScaleSetUpdatePublicIPAddressConfiguration: VirtualMachineScaleSetUpdatePublicIPAddressConfiguration,
    UpdateResource: UpdateResource,
    VirtualMachineScaleSetVMInstanceIDs: VirtualMachineScaleSetVMInstanceIDs,
    VirtualMachineScaleSetVMInstanceRequiredIDs: VirtualMachineScaleSetVMInstanceRequiredIDs,
    VirtualMachineScaleSetInstanceView: VirtualMachineScaleSetInstanceView,
    VirtualMachineScaleSetInstanceViewStatusesSummary: VirtualMachineScaleSetInstanceViewStatusesSummary,
    VirtualMachineStatusCodeCount: VirtualMachineStatusCodeCount,
    VirtualMachineScaleSetVMExtensionsSummary: VirtualMachineScaleSetVMExtensionsSummary,
    InstanceViewStatus: InstanceViewStatus,
    OrchestrationServiceSummary: OrchestrationServiceSummary,
    VirtualMachineScaleSetExtensionListResult: VirtualMachineScaleSetExtensionListResult,
    VirtualMachineScaleSetListWithLinkResult: VirtualMachineScaleSetListWithLinkResult,
    VirtualMachineScaleSetListSkusResult: VirtualMachineScaleSetListSkusResult,
    VirtualMachineScaleSetSku: VirtualMachineScaleSetSku,
    VirtualMachineScaleSetSkuCapacity: VirtualMachineScaleSetSkuCapacity,
    VirtualMachineScaleSetListOSUpgradeHistory: VirtualMachineScaleSetListOSUpgradeHistory,
    UpgradeOperationHistoricalStatusInfo: UpgradeOperationHistoricalStatusInfo,
    UpgradeOperationHistoricalStatusInfoProperties: UpgradeOperationHistoricalStatusInfoProperties,
    UpgradeOperationHistoryStatus: UpgradeOperationHistoryStatus,
    RollingUpgradeProgressInfo: RollingUpgradeProgressInfo,
    RollbackStatusInfo: RollbackStatusInfo,
    VirtualMachineReimageParameters: VirtualMachineReimageParameters,
    RollingUpgradeRunningStatus: RollingUpgradeRunningStatus,
    RecoveryWalkResponse: RecoveryWalkResponse,
    VMScaleSetConvertToSinglePlacementGroupInput: VMScaleSetConvertToSinglePlacementGroupInput,
    OrchestrationServiceStateInput: OrchestrationServiceStateInput,
    VirtualMachineExtensionInstanceView: VirtualMachineExtensionInstanceView,
    VirtualMachineScaleSetVMExtensionsListResult: VirtualMachineScaleSetVMExtensionsListResult,
    VirtualMachineScaleSetVMInstanceView: VirtualMachineScaleSetVMInstanceView,
    VirtualMachineAgentInstanceView: VirtualMachineAgentInstanceView,
    VirtualMachineExtensionHandlerInstanceView: VirtualMachineExtensionHandlerInstanceView,
    MaintenanceRedeployStatus: MaintenanceRedeployStatus,
    DiskInstanceView: DiskInstanceView,
    DiskEncryptionSettings: DiskEncryptionSettings,
    KeyVaultKeyReference: KeyVaultKeyReference,
    VirtualMachineHealthStatus: VirtualMachineHealthStatus,
    BootDiagnosticsInstanceView: BootDiagnosticsInstanceView,
    HardwareProfile: HardwareProfile,
    StorageProfile: StorageProfile,
    OSDisk: OSDisk,
    DataDisk: DataDisk,
    OSProfile: OSProfile,
    NetworkProfile: NetworkProfile,
    VirtualMachineNetworkInterfaceConfiguration: VirtualMachineNetworkInterfaceConfiguration,
    VirtualMachineNetworkInterfaceDnsSettingsConfiguration: VirtualMachineNetworkInterfaceDnsSettingsConfiguration,
    VirtualMachineNetworkInterfaceIPConfiguration: VirtualMachineNetworkInterfaceIPConfiguration,
    VirtualMachinePublicIPAddressConfiguration: VirtualMachinePublicIPAddressConfiguration,
    VirtualMachinePublicIPAddressDnsSettingsConfiguration: VirtualMachinePublicIPAddressDnsSettingsConfiguration,
    VirtualMachineIpTag: VirtualMachineIpTag,
    VirtualMachineScaleSetVMNetworkProfileConfiguration: VirtualMachineScaleSetVMNetworkProfileConfiguration,
    VirtualMachineScaleSetVMProtectionPolicy: VirtualMachineScaleSetVMProtectionPolicy,
    ResourceWithOptionalLocation: ResourceWithOptionalLocation,
    VirtualMachineIdentity: VirtualMachineIdentity,
    VirtualMachineScaleSetVMListResult: VirtualMachineScaleSetVMListResult,
    RetrieveBootDiagnosticsDataResult: RetrieveBootDiagnosticsDataResult,
    VirtualMachineExtensionsListResult: VirtualMachineExtensionsListResult,
    VirtualMachineListResult: VirtualMachineListResult,
    VirtualMachineInstanceView: VirtualMachineInstanceView,
    VirtualMachinePatchStatus: VirtualMachinePatchStatus,
    AvailablePatchSummary: AvailablePatchSummary,
    LastPatchInstallationSummary: LastPatchInstallationSummary,
    VirtualMachineCaptureParameters: VirtualMachineCaptureParameters,
    VirtualMachineAssessPatchesResult: VirtualMachineAssessPatchesResult,
    VirtualMachineSoftwarePatchProperties: VirtualMachineSoftwarePatchProperties,
    VirtualMachineInstallPatchesParameters: VirtualMachineInstallPatchesParameters,
    WindowsParameters: WindowsParameters,
    LinuxParameters: LinuxParameters,
    VirtualMachineInstallPatchesResult: VirtualMachineInstallPatchesResult,
    PatchInstallationDetail: PatchInstallationDetail,
    PurchasePlan: PurchasePlan,
    OSDiskImage: OSDiskImage,
    DataDiskImage: DataDiskImage,
    AutomaticOSUpgradeProperties: AutomaticOSUpgradeProperties,
    DisallowedConfiguration: DisallowedConfiguration,
    VirtualMachineImageFeature: VirtualMachineImageFeature,
    VmImagesInEdgeZoneListResult: VmImagesInEdgeZoneListResult,
    AvailabilitySetListResult: AvailabilitySetListResult,
    ProximityPlacementGroupPropertiesIntent: ProximityPlacementGroupPropertiesIntent,
    ProximityPlacementGroupListResult: ProximityPlacementGroupListResult,
    DedicatedHostGroupInstanceView: DedicatedHostGroupInstanceView,
    DedicatedHostInstanceView: DedicatedHostInstanceView,
    DedicatedHostAvailableCapacity: DedicatedHostAvailableCapacity,
    DedicatedHostAllocatableVM: DedicatedHostAllocatableVM,
    DedicatedHostGroupPropertiesAdditionalCapabilities: DedicatedHostGroupPropertiesAdditionalCapabilities,
    DedicatedHostGroupListResult: DedicatedHostGroupListResult,
    DedicatedHostListResult: DedicatedHostListResult,
    SshPublicKeysGroupListResult: SshPublicKeysGroupListResult,
    SshPublicKeyGenerateKeyPairResult: SshPublicKeyGenerateKeyPairResult,
    ImageStorageProfile: ImageStorageProfile,
    ImageDisk: ImageDisk,
    ImageListResult: ImageListResult,
    RestorePointCollectionSourceProperties: RestorePointCollectionSourceProperties,
    RestorePointSourceMetadata: RestorePointSourceMetadata,
    RestorePointSourceVMStorageProfile: RestorePointSourceVMStorageProfile,
    RestorePointSourceVmosDisk: RestorePointSourceVmosDisk,
    RestorePointSourceVMDataDisk: RestorePointSourceVMDataDisk,
    RestorePointInstanceView: RestorePointInstanceView,
    DiskRestorePointInstanceView: DiskRestorePointInstanceView,
    DiskRestorePointReplicationStatus: DiskRestorePointReplicationStatus,
    ProxyResource: ProxyResource,
    RestorePointCollectionListResult: RestorePointCollectionListResult,
    CapacityReservationGroupInstanceView: CapacityReservationGroupInstanceView,
    CapacityReservationInstanceView: CapacityReservationInstanceView,
    CapacityReservationUtilization: CapacityReservationUtilization,
    CapacityReservationGroupListResult: CapacityReservationGroupListResult,
    CapacityReservationListResult: CapacityReservationListResult,
    LogAnalyticsInputBase: LogAnalyticsInputBase,
    LogAnalyticsOperationResult: LogAnalyticsOperationResult,
    LogAnalyticsOutput: LogAnalyticsOutput,
    RunCommandListResult: RunCommandListResult,
    RunCommandDocumentBase: RunCommandDocumentBase,
    RunCommandParameterDefinition: RunCommandParameterDefinition,
    RunCommandInput: RunCommandInput,
    RunCommandInputParameter: RunCommandInputParameter,
    RunCommandResult: RunCommandResult,
    VirtualMachineRunCommandScriptSource: VirtualMachineRunCommandScriptSource,
    VirtualMachineRunCommandInstanceView: VirtualMachineRunCommandInstanceView,
    VirtualMachineRunCommandsListResult: VirtualMachineRunCommandsListResult,
    DiskSku: DiskSku,
    PurchasePlanAutoGenerated: PurchasePlanAutoGenerated,
    SupportedCapabilities: SupportedCapabilities,
    CreationData: CreationData,
    ImageDiskReference: ImageDiskReference,
    EncryptionSettingsCollection: EncryptionSettingsCollection,
    EncryptionSettingsElement: EncryptionSettingsElement,
    KeyVaultAndSecretReference: KeyVaultAndSecretReference,
    SourceVault: SourceVault,
    KeyVaultAndKeyReference: KeyVaultAndKeyReference,
    Encryption: Encryption,
    ShareInfoElement: ShareInfoElement,
    PropertyUpdatesInProgress: PropertyUpdatesInProgress,
    DiskSecurityProfile: DiskSecurityProfile,
    DiskUpdate: DiskUpdate,
    DiskList: DiskList,
    GrantAccessData: GrantAccessData,
    AccessUri: AccessUri,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    DiskAccessUpdate: DiskAccessUpdate,
    DiskAccessList: DiskAccessList,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkResource: PrivateLinkResource,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    EncryptionSetIdentity: EncryptionSetIdentity,
    KeyForDiskEncryptionSet: KeyForDiskEncryptionSet,
    DiskEncryptionSetUpdate: DiskEncryptionSetUpdate,
    DiskEncryptionSetList: DiskEncryptionSetList,
    ResourceUriList: ResourceUriList,
    ProxyOnlyResource: ProxyOnlyResource,
    DiskRestorePointList: DiskRestorePointList,
    SnapshotSku: SnapshotSku,
    CopyCompletionError: CopyCompletionError,
    SnapshotUpdate: SnapshotUpdate,
    SnapshotList: SnapshotList,
    ResourceSkusResult: ResourceSkusResult,
    ResourceSku: ResourceSku,
    ResourceSkuCapacity: ResourceSkuCapacity,
    ResourceSkuLocationInfo: ResourceSkuLocationInfo,
    ResourceSkuZoneDetails: ResourceSkuZoneDetails,
    ResourceSkuCapabilities: ResourceSkuCapabilities,
    ResourceSkuCosts: ResourceSkuCosts,
    ResourceSkuRestrictions: ResourceSkuRestrictions,
    ResourceSkuRestrictionInfo: ResourceSkuRestrictionInfo,
    GalleryIdentifier: GalleryIdentifier,
    SharingProfile: SharingProfile,
    SharingProfileGroup: SharingProfileGroup,
    CommunityGalleryInfo: CommunityGalleryInfo,
    SoftDeletePolicy: SoftDeletePolicy,
    SharingStatus: SharingStatus,
    RegionalSharingStatus: RegionalSharingStatus,
    UpdateResourceDefinition: UpdateResourceDefinition,
    GalleryImageIdentifier: GalleryImageIdentifier,
    RecommendedMachineConfiguration: RecommendedMachineConfiguration,
    ResourceRange: ResourceRange,
    Disallowed: Disallowed,
    ImagePurchasePlan: ImagePurchasePlan,
    GalleryImageFeature: GalleryImageFeature,
    GalleryArtifactPublishingProfileBase: GalleryArtifactPublishingProfileBase,
    TargetRegion: TargetRegion,
    EncryptionImages: EncryptionImages,
    OSDiskImageSecurityProfile: OSDiskImageSecurityProfile,
    DiskImageEncryption: DiskImageEncryption,
    GalleryTargetExtendedLocation: GalleryTargetExtendedLocation,
    GalleryExtendedLocation: GalleryExtendedLocation,
    GalleryImageVersionStorageProfile: GalleryImageVersionStorageProfile,
    GalleryArtifactVersionSource: GalleryArtifactVersionSource,
    GalleryDiskImage: GalleryDiskImage,
    ReplicationStatus: ReplicationStatus,
    RegionalReplicationStatus: RegionalReplicationStatus,
    UserArtifactSource: UserArtifactSource,
    UserArtifactManage: UserArtifactManage,
    UserArtifactSettings: UserArtifactSettings,
    GalleryList: GalleryList,
    GalleryImageList: GalleryImageList,
    GalleryImageVersionList: GalleryImageVersionList,
    GalleryApplicationList: GalleryApplicationList,
    GalleryApplicationVersionList: GalleryApplicationVersionList,
    SharingUpdate: SharingUpdate,
    SharedGalleryList: SharedGalleryList,
    PirResource: PirResource,
    SharedGalleryImageList: SharedGalleryImageList,
    SharedGalleryImageVersionList: SharedGalleryImageVersionList,
    SharedGalleryImageVersionStorageProfile: SharedGalleryImageVersionStorageProfile,
    SharedGalleryDiskImage: SharedGalleryDiskImage,
    PirCommunityGalleryResource: PirCommunityGalleryResource,
    CommunityGalleryImageList: CommunityGalleryImageList,
    CommunityGalleryImageVersionList: CommunityGalleryImageVersionList,
    RoleInstance: RoleInstance,
    InstanceSku: InstanceSku,
    RoleInstanceProperties: RoleInstanceProperties,
    RoleInstanceNetworkProfile: RoleInstanceNetworkProfile,
    RoleInstanceView: RoleInstanceView,
    ResourceInstanceViewStatus: ResourceInstanceViewStatus,
    RoleInstanceListResult: RoleInstanceListResult,
    CloudServiceRole: CloudServiceRole,
    CloudServiceRoleSku: CloudServiceRoleSku,
    CloudServiceRoleProperties: CloudServiceRoleProperties,
    CloudServiceRoleListResult: CloudServiceRoleListResult,
    CloudService: CloudService,
    CloudServiceProperties: CloudServiceProperties,
    CloudServiceRoleProfile: CloudServiceRoleProfile,
    CloudServiceRoleProfileProperties: CloudServiceRoleProfileProperties,
    CloudServiceOsProfile: CloudServiceOsProfile,
    CloudServiceVaultSecretGroup: CloudServiceVaultSecretGroup,
    CloudServiceVaultCertificate: CloudServiceVaultCertificate,
    CloudServiceNetworkProfile: CloudServiceNetworkProfile,
    LoadBalancerConfiguration: LoadBalancerConfiguration,
    LoadBalancerConfigurationProperties: LoadBalancerConfigurationProperties,
    LoadBalancerFrontendIPConfiguration: LoadBalancerFrontendIPConfiguration,
    LoadBalancerFrontendIPConfigurationProperties: LoadBalancerFrontendIPConfigurationProperties,
    CloudServiceExtensionProfile: CloudServiceExtensionProfile,
    Extension: Extension,
    CloudServiceExtensionProperties: CloudServiceExtensionProperties,
    CloudServiceVaultAndSecretReference: CloudServiceVaultAndSecretReference,
    SystemData: SystemData,
    CloudServiceUpdate: CloudServiceUpdate,
    CloudServiceInstanceView: CloudServiceInstanceView,
    InstanceViewStatusesSummary: InstanceViewStatusesSummary,
    StatusCodeCount: StatusCodeCount,
    CloudServiceListResult: CloudServiceListResult,
    RoleInstances: RoleInstances,
    UpdateDomain: UpdateDomain,
    UpdateDomainListResult: UpdateDomainListResult,
    OSVersion: OSVersion,
    OSVersionProperties: OSVersionProperties,
    OSVersionListResult: OSVersionListResult,
    OSFamily: OSFamily,
    OSFamilyProperties: OSFamilyProperties,
    OSVersionPropertiesBase: OSVersionPropertiesBase,
    OSFamilyListResult: OSFamilyListResult,
    GalleryArtifactSource: GalleryArtifactSource,
    ManagedArtifact: ManagedArtifact,
    ImageReference: ImageReference,
    DiskEncryptionSetParameters: DiskEncryptionSetParameters,
    VirtualMachineScaleSetIPConfiguration: VirtualMachineScaleSetIPConfiguration,
    VirtualMachineScaleSetNetworkConfiguration: VirtualMachineScaleSetNetworkConfiguration,
    VirtualMachineScaleSetUpdateIPConfiguration: VirtualMachineScaleSetUpdateIPConfiguration,
    VirtualMachineScaleSetUpdateNetworkConfiguration: VirtualMachineScaleSetUpdateNetworkConfiguration,
    ManagedDiskParameters: ManagedDiskParameters,
    NetworkInterfaceReference: NetworkInterfaceReference,
    VirtualMachineCaptureResult: VirtualMachineCaptureResult,
    VirtualMachineImageResource: VirtualMachineImageResource,
    SubResourceWithColocationStatus: SubResourceWithColocationStatus,
    VirtualMachineScaleSetExtension: VirtualMachineScaleSetExtension,
    VirtualMachineScaleSetExtensionUpdate: VirtualMachineScaleSetExtensionUpdate,
    VirtualMachineScaleSetVMExtension: VirtualMachineScaleSetVMExtension,
    VirtualMachineScaleSetVMExtensionUpdate: VirtualMachineScaleSetVMExtensionUpdate,
    VirtualMachineScaleSet: VirtualMachineScaleSet,
    RollingUpgradeStatusInfo: RollingUpgradeStatusInfo,
    VirtualMachineScaleSetVM: VirtualMachineScaleSetVM,
    VirtualMachine: VirtualMachine,
    VirtualMachineExtensionImage: VirtualMachineExtensionImage,
    AvailabilitySet: AvailabilitySet,
    ProximityPlacementGroup: ProximityPlacementGroup,
    DedicatedHostGroup: DedicatedHostGroup,
    DedicatedHost: DedicatedHost,
    SshPublicKeyResource: SshPublicKeyResource,
    Image: Image,
    RestorePointCollection: RestorePointCollection,
    CapacityReservationGroup: CapacityReservationGroup,
    CapacityReservation: CapacityReservation,
    VirtualMachineRunCommand: VirtualMachineRunCommand,
    Disk: Disk,
    DiskAccess: DiskAccess,
    DiskEncryptionSet: DiskEncryptionSet,
    Snapshot: Snapshot,
    Gallery: Gallery,
    GalleryImage: GalleryImage,
    GalleryImageVersion: GalleryImageVersion,
    GalleryApplication: GalleryApplication,
    GalleryApplicationVersion: GalleryApplicationVersion,
    VirtualMachineScaleSetUpdate: VirtualMachineScaleSetUpdate,
    VirtualMachineExtensionUpdate: VirtualMachineExtensionUpdate,
    VirtualMachineUpdate: VirtualMachineUpdate,
    AvailabilitySetUpdate: AvailabilitySetUpdate,
    ProximityPlacementGroupUpdate: ProximityPlacementGroupUpdate,
    DedicatedHostGroupUpdate: DedicatedHostGroupUpdate,
    DedicatedHostUpdate: DedicatedHostUpdate,
    SshPublicKeyUpdateResource: SshPublicKeyUpdateResource,
    ImageUpdate: ImageUpdate,
    RestorePointCollectionUpdate: RestorePointCollectionUpdate,
    CapacityReservationGroupUpdate: CapacityReservationGroupUpdate,
    CapacityReservationUpdate: CapacityReservationUpdate,
    VirtualMachineRunCommandUpdate: VirtualMachineRunCommandUpdate,
    VirtualMachineScaleSetVMReimageParameters: VirtualMachineScaleSetVMReimageParameters,
    VirtualMachineExtension: VirtualMachineExtension,
    DedicatedHostInstanceViewWithName: DedicatedHostInstanceViewWithName,
    ImageOSDisk: ImageOSDisk,
    ImageDataDisk: ImageDataDisk,
    RestorePoint: RestorePoint,
    CapacityReservationInstanceViewWithName: CapacityReservationInstanceViewWithName,
    RequestRateByIntervalInput: RequestRateByIntervalInput,
    ThrottledRequestsInput: ThrottledRequestsInput,
    RunCommandDocument: RunCommandDocument,
    DiskRestorePoint: DiskRestorePoint,
    GalleryUpdate: GalleryUpdate,
    GalleryImageUpdate: GalleryImageUpdate,
    GalleryImageVersionUpdate: GalleryImageVersionUpdate,
    GalleryApplicationUpdate: GalleryApplicationUpdate,
    GalleryApplicationVersionUpdate: GalleryApplicationVersionUpdate,
    GalleryImageVersionPublishingProfile: GalleryImageVersionPublishingProfile,
    GalleryApplicationVersionPublishingProfile: GalleryApplicationVersionPublishingProfile,
    OSDiskImageEncryption: OSDiskImageEncryption,
    DataDiskImageEncryption: DataDiskImageEncryption,
    GalleryOSDiskImage: GalleryOSDiskImage,
    GalleryDataDiskImage: GalleryDataDiskImage,
    PirSharedGalleryResource: PirSharedGalleryResource,
    SharedGalleryOSDiskImage: SharedGalleryOSDiskImage,
    SharedGalleryDataDiskImage: SharedGalleryDataDiskImage,
    CommunityGallery: CommunityGallery,
    CommunityGalleryImage: CommunityGalleryImage,
    CommunityGalleryImageVersion: CommunityGalleryImageVersion,
    VirtualMachineImage: VirtualMachineImage,
    VirtualMachineScaleSetReimageParameters: VirtualMachineScaleSetReimageParameters,
    SharedGallery: SharedGallery,
    SharedGalleryImage: SharedGalleryImage,
    SharedGalleryImageVersion: SharedGalleryImageVersion
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-08-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: VirtualMachineScaleSet
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vmScaleSetName = {
    parameterPath: "vmScaleSetName",
    mapper: {
        serializedName: "vmScaleSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: VirtualMachineScaleSetUpdate
};
const forceDeletion = {
    parameterPath: ["options", "forceDeletion"],
    mapper: {
        serializedName: "forceDeletion",
        type: {
            name: "Boolean"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const vmInstanceIDs = {
    parameterPath: ["options", "vmInstanceIDs"],
    mapper: VirtualMachineScaleSetVMInstanceIDs
};
const vmInstanceIDs1 = {
    parameterPath: "vmInstanceIDs",
    mapper: VirtualMachineScaleSetVMInstanceRequiredIDs
};
const skipShutdown = {
    parameterPath: ["options", "skipShutdown"],
    mapper: {
        defaultValue: false,
        serializedName: "skipShutdown",
        type: {
            name: "Boolean"
        }
    }
};
const vmScaleSetReimageInput = {
    parameterPath: ["options", "vmScaleSetReimageInput"],
    mapper: VirtualMachineScaleSetReimageParameters
};
const platformUpdateDomain = {
    parameterPath: "platformUpdateDomain",
    mapper: {
        serializedName: "platformUpdateDomain",
        required: true,
        type: {
            name: "Number"
        }
    }
};
const zone = {
    parameterPath: ["options", "zone"],
    mapper: {
        serializedName: "zone",
        type: {
            name: "String"
        }
    }
};
const placementGroupId = {
    parameterPath: ["options", "placementGroupId"],
    mapper: {
        serializedName: "placementGroupId",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: VMScaleSetConvertToSinglePlacementGroupInput
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: OrchestrationServiceStateInput
};
const extensionParameters = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineScaleSetExtension
};
const vmssExtensionName = {
    parameterPath: "vmssExtensionName",
    mapper: {
        serializedName: "vmssExtensionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const extensionParameters1 = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineScaleSetExtensionUpdate
};
const expand1 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const extensionParameters2 = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineScaleSetVMExtension
};
const instanceId = {
    parameterPath: "instanceId",
    mapper: {
        serializedName: "instanceId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vmExtensionName = {
    parameterPath: "vmExtensionName",
    mapper: {
        serializedName: "vmExtensionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const extensionParameters3 = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineScaleSetVMExtensionUpdate
};
const vmScaleSetVMReimageInput = {
    parameterPath: ["options", "vmScaleSetVMReimageInput"],
    mapper: VirtualMachineScaleSetVMReimageParameters
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: VirtualMachineScaleSetVM
};
const expand2 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "Enum",
            allowedValues: ["instanceView", "userData"]
        }
    }
};
const virtualMachineScaleSetName = {
    parameterPath: "virtualMachineScaleSetName",
    mapper: {
        serializedName: "virtualMachineScaleSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const sasUriExpirationTimeInMinutes = {
    parameterPath: ["options", "sasUriExpirationTimeInMinutes"],
    mapper: {
        serializedName: "sasUriExpirationTimeInMinutes",
        type: {
            name: "Number"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: RunCommandInput
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const extensionParameters4 = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineExtension
};
const vmName = {
    parameterPath: "vmName",
    mapper: {
        serializedName: "vmName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const extensionParameters5 = {
    parameterPath: "extensionParameters",
    mapper: VirtualMachineExtensionUpdate
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: VirtualMachineCaptureParameters
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: VirtualMachine
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: VirtualMachineUpdate
};
const hibernate = {
    parameterPath: ["options", "hibernate"],
    mapper: {
        serializedName: "hibernate",
        type: {
            name: "Boolean"
        }
    }
};
const statusOnly = {
    parameterPath: ["options", "statusOnly"],
    mapper: {
        serializedName: "statusOnly",
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: ["options", "parameters"],
    mapper: VirtualMachineReimageParameters
};
const installPatchesInput = {
    parameterPath: "installPatchesInput",
    mapper: VirtualMachineInstallPatchesParameters
};
const location1 = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const publisherName = {
    parameterPath: "publisherName",
    mapper: {
        serializedName: "publisherName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const offer = {
    parameterPath: "offer",
    mapper: {
        serializedName: "offer",
        required: true,
        type: {
            name: "String"
        }
    }
};
const skus = {
    parameterPath: "skus",
    mapper: {
        serializedName: "skus",
        required: true,
        type: {
            name: "String"
        }
    }
};
const version = {
    parameterPath: "version",
    mapper: {
        serializedName: "version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "String"
        }
    }
};
const edgeZone = {
    parameterPath: "edgeZone",
    mapper: {
        serializedName: "edgeZone",
        required: true,
        type: {
            name: "String"
        }
    }
};
const typeParam = {
    parameterPath: "typeParam",
    mapper: {
        serializedName: "type",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: AvailabilitySet
};
const availabilitySetName = {
    parameterPath: "availabilitySetName",
    mapper: {
        serializedName: "availabilitySetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: AvailabilitySetUpdate
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: ProximityPlacementGroup
};
const proximityPlacementGroupName = {
    parameterPath: "proximityPlacementGroupName",
    mapper: {
        serializedName: "proximityPlacementGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: ProximityPlacementGroupUpdate
};
const includeColocationStatus = {
    parameterPath: ["options", "includeColocationStatus"],
    mapper: {
        serializedName: "includeColocationStatus",
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: DedicatedHostGroup
};
const hostGroupName = {
    parameterPath: "hostGroupName",
    mapper: {
        serializedName: "hostGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: DedicatedHostGroupUpdate
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: DedicatedHost
};
const hostName = {
    parameterPath: "hostName",
    mapper: {
        serializedName: "hostName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: DedicatedHostUpdate
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: SshPublicKeyResource
};
const sshPublicKeyName = {
    parameterPath: "sshPublicKeyName",
    mapper: {
        serializedName: "sshPublicKeyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: SshPublicKeyUpdateResource
};
const parameters20 = {
    parameterPath: "parameters",
    mapper: Image
};
const imageName = {
    parameterPath: "imageName",
    mapper: {
        serializedName: "imageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: ImageUpdate
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: RestorePointCollection
};
const restorePointCollectionName = {
    parameterPath: "restorePointCollectionName",
    mapper: {
        serializedName: "restorePointCollectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: RestorePointCollectionUpdate
};
const expand3 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: RestorePoint
};
const restorePointName = {
    parameterPath: "restorePointName",
    mapper: {
        serializedName: "restorePointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand4 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: CapacityReservationGroup
};
const capacityReservationGroupName = {
    parameterPath: "capacityReservationGroupName",
    mapper: {
        serializedName: "capacityReservationGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: CapacityReservationGroupUpdate
};
const expand5 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const expand6 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: CapacityReservation
};
const capacityReservationName = {
    parameterPath: "capacityReservationName",
    mapper: {
        serializedName: "capacityReservationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters28 = {
    parameterPath: "parameters",
    mapper: CapacityReservationUpdate
};
const expand7 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: RequestRateByIntervalInput
};
const parameters30 = {
    parameterPath: "parameters",
    mapper: ThrottledRequestsInput
};
const commandId = {
    parameterPath: "commandId",
    mapper: {
        serializedName: "commandId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const runCommand = {
    parameterPath: "runCommand",
    mapper: VirtualMachineRunCommand
};
const runCommandName = {
    parameterPath: "runCommandName",
    mapper: {
        serializedName: "runCommandName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const runCommand1 = {
    parameterPath: "runCommand",
    mapper: VirtualMachineRunCommandUpdate
};
const disk = {
    parameterPath: "disk",
    mapper: Disk
};
const diskName = {
    parameterPath: "diskName",
    mapper: {
        serializedName: "diskName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-07-02",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const disk1 = {
    parameterPath: "disk",
    mapper: DiskUpdate
};
const grantAccessData = {
    parameterPath: "grantAccessData",
    mapper: GrantAccessData
};
const diskAccess = {
    parameterPath: "diskAccess",
    mapper: DiskAccess
};
const diskAccessName = {
    parameterPath: "diskAccessName",
    mapper: {
        serializedName: "diskAccessName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const diskAccess1 = {
    parameterPath: "diskAccess",
    mapper: DiskAccessUpdate
};
const privateEndpointConnection = {
    parameterPath: "privateEndpointConnection",
    mapper: PrivateEndpointConnection
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const diskEncryptionSet = {
    parameterPath: "diskEncryptionSet",
    mapper: DiskEncryptionSet
};
const diskEncryptionSetName = {
    parameterPath: "diskEncryptionSetName",
    mapper: {
        serializedName: "diskEncryptionSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const diskEncryptionSet1 = {
    parameterPath: "diskEncryptionSet",
    mapper: DiskEncryptionSetUpdate
};
const vmRestorePointName = {
    parameterPath: "vmRestorePointName",
    mapper: {
        serializedName: "vmRestorePointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const diskRestorePointName = {
    parameterPath: "diskRestorePointName",
    mapper: {
        serializedName: "diskRestorePointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const snapshot = {
    parameterPath: "snapshot",
    mapper: Snapshot
};
const snapshotName = {
    parameterPath: "snapshotName",
    mapper: {
        serializedName: "snapshotName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const snapshot1 = {
    parameterPath: "snapshot",
    mapper: SnapshotUpdate
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-07-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const includeExtendedLocations = {
    parameterPath: ["options", "includeExtendedLocations"],
    mapper: {
        serializedName: "includeExtendedLocations",
        type: {
            name: "String"
        }
    }
};
const gallery = {
    parameterPath: "gallery",
    mapper: Gallery
};
const galleryName = {
    parameterPath: "galleryName",
    mapper: {
        serializedName: "galleryName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion3 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-01-03",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const gallery1 = {
    parameterPath: "gallery",
    mapper: GalleryUpdate
};
const select1 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const expand8 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const galleryImage = {
    parameterPath: "galleryImage",
    mapper: GalleryImage
};
const galleryImageName = {
    parameterPath: "galleryImageName",
    mapper: {
        serializedName: "galleryImageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const galleryImage1 = {
    parameterPath: "galleryImage",
    mapper: GalleryImageUpdate
};
const galleryImageVersion = {
    parameterPath: "galleryImageVersion",
    mapper: GalleryImageVersion
};
const galleryImageVersionName = {
    parameterPath: "galleryImageVersionName",
    mapper: {
        serializedName: "galleryImageVersionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const galleryImageVersion1 = {
    parameterPath: "galleryImageVersion",
    mapper: GalleryImageVersionUpdate
};
const expand9 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const galleryApplication = {
    parameterPath: "galleryApplication",
    mapper: GalleryApplication
};
const galleryApplicationName = {
    parameterPath: "galleryApplicationName",
    mapper: {
        serializedName: "galleryApplicationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const galleryApplication1 = {
    parameterPath: "galleryApplication",
    mapper: GalleryApplicationUpdate
};
const galleryApplicationVersion = {
    parameterPath: "galleryApplicationVersion",
    mapper: GalleryApplicationVersion
};
const galleryApplicationVersionName = {
    parameterPath: "galleryApplicationVersionName",
    mapper: {
        serializedName: "galleryApplicationVersionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const galleryApplicationVersion1 = {
    parameterPath: "galleryApplicationVersion",
    mapper: GalleryApplicationVersionUpdate
};
const sharingUpdate = {
    parameterPath: "sharingUpdate",
    mapper: SharingUpdate
};
const sharedTo = {
    parameterPath: ["options", "sharedTo"],
    mapper: {
        serializedName: "sharedTo",
        type: {
            name: "String"
        }
    }
};
const galleryUniqueName = {
    parameterPath: "galleryUniqueName",
    mapper: {
        serializedName: "galleryUniqueName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const publicGalleryName = {
    parameterPath: "publicGalleryName",
    mapper: {
        serializedName: "publicGalleryName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleInstanceName = {
    parameterPath: "roleInstanceName",
    mapper: {
        serializedName: "roleInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cloudServiceName = {
    parameterPath: "cloudServiceName",
    mapper: {
        serializedName: "cloudServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion4 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-04-04",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/x-rdp",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const roleName = {
    parameterPath: "roleName",
    mapper: {
        serializedName: "roleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters31 = {
    parameterPath: ["options", "parameters"],
    mapper: CloudService
};
const parameters32 = {
    parameterPath: ["options", "parameters"],
    mapper: CloudServiceUpdate
};
const parameters33 = {
    parameterPath: ["options", "parameters"],
    mapper: RoleInstances
};
const parameters34 = {
    parameterPath: ["options", "parameters"],
    mapper: UpdateDomain
};
const updateDomain = {
    parameterPath: "updateDomain",
    mapper: {
        serializedName: "updateDomain",
        required: true,
        type: {
            name: "Number"
        }
    }
};
const osVersionName = {
    parameterPath: "osVersionName",
    mapper: {
        serializedName: "osVersionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const osFamilyName = {
    parameterPath: "osFamilyName",
    mapper: {
        serializedName: "osFamilyName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of compute operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of compute operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$t);
    }
}
// Operation Specifications
const serializer$M = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$t = {
    path: "/providers/Microsoft.Compute/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComputeOperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing UsageOperations operations. */
class UsageOperationsImpl {
    /**
     * Initialize a new instance of the class UsageOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets, for the specified location, the current compute resource usage information as well as the
     * limits for compute resources under the subscription.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets, for the specified location, the current compute resource usage information as well as the
     * limits for compute resources under the subscription.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$s);
    }
    /**
     * ListNext
     * @param location The location for which resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$L = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineSizes operations. */
class VirtualMachineSizesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineSizes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This API is deprecated. Use [Resources
     * Skus](https://docs.microsoft.com/rest/api/compute/resourceskus/list)
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This API is deprecated. Use [Resources
     * Skus](https://docs.microsoft.com/rest/api/compute/resourceskus/list)
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$r);
    }
}
// Operation Specifications
const serializer$K = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/vmSizes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineSizeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineScaleSets operations. */
class VirtualMachineScaleSetsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the VM scale sets under the specified subscription for the specified location.
     * @param location The location for which VM scale sets under the subscription are queried.
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(location, options);
            }
        };
    }
    listByLocationPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all VM scale sets under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of all VM Scale Sets in the subscription, regardless of the associated resource group.
     * Use nextLink property in the response to get the next page of VM Scale Sets. Do this till nextLink
     * is null to fetch all the VM Scale Sets.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of SKUs available for your VM scale set, including the minimum and maximum VM instances
     * allowed for each SKU.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    listSkus(resourceGroupName, vmScaleSetName, options) {
        const iter = this.listSkusPagingAll(resourceGroupName, vmScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSkusPagingPage(resourceGroupName, vmScaleSetName, options);
            }
        };
    }
    listSkusPagingPage(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingPage_1() {
            let result = yield tslib.__await(this._listSkus(resourceGroupName, vmScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSkusNext(resourceGroupName, vmScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSkusPagingAll(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSkusPagingPage(resourceGroupName, vmScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets list of OS upgrades on a VM scale set instance.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    listOSUpgradeHistory(resourceGroupName, vmScaleSetName, options) {
        const iter = this.getOSUpgradeHistoryPagingAll(resourceGroupName, vmScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getOSUpgradeHistoryPagingPage(resourceGroupName, vmScaleSetName, options);
            }
        };
    }
    getOSUpgradeHistoryPagingPage(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getOSUpgradeHistoryPagingPage_1() {
            let result = yield tslib.__await(this._getOSUpgradeHistory(resourceGroupName, vmScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getOSUpgradeHistoryNext(resourceGroupName, vmScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getOSUpgradeHistoryPagingAll(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getOSUpgradeHistoryPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getOSUpgradeHistoryPagingPage(resourceGroupName, vmScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets all the VM scale sets under the specified subscription for the specified location.
     * @param location The location for which VM scale sets under the subscription are queried.
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec$1);
    }
    /**
     * Create or update a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set to create or update.
     * @param parameters The scale set object.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, parameters, options }, createOrUpdateOperationSpec$o);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set to create or update.
     * @param parameters The scale set object.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmScaleSetName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set to create or update.
     * @param parameters The scale set object.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, parameters, options }, updateOperationSpec$r);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set to create or update.
     * @param parameters The scale set object.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmScaleSetName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, deleteOperationSpec$s);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Display information about a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, getOperationSpec$D);
    }
    /**
     * Deallocates specific virtual machines in a VM scale set. Shuts down the virtual machines and
     * releases the compute resources. You are not billed for the compute resources that this virtual
     * machine scale set deallocates.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginDeallocate(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, deallocateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deallocates specific virtual machines in a VM scale set. Shuts down the virtual machines and
     * releases the compute resources. You are not billed for the compute resources that this virtual
     * machine scale set deallocates.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginDeallocateAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeallocate(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param vmInstanceIDs A list of virtual machine instance IDs from the VM scale set.
     * @param options The options parameters.
     */
    beginDeleteInstances(resourceGroupName, vmScaleSetName, vmInstanceIDs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, vmInstanceIDs, options }, deleteInstancesOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param vmInstanceIDs A list of virtual machine instance IDs from the VM scale set.
     * @param options The options parameters.
     */
    beginDeleteInstancesAndWait(resourceGroupName, vmScaleSetName, vmInstanceIDs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteInstances(resourceGroupName, vmScaleSetName, vmInstanceIDs, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of a VM scale set instance.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    getInstanceView(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, getInstanceViewOperationSpec$3);
    }
    /**
     * Gets a list of all VM scale sets under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$q);
    }
    /**
     * Gets a list of all VM Scale Sets in the subscription, regardless of the associated resource group.
     * Use nextLink property in the response to get the next page of VM Scale Sets. Do this till nextLink
     * is null to fetch all the VM Scale Sets.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$3);
    }
    /**
     * Gets a list of SKUs available for your VM scale set, including the minimum and maximum VM instances
     * allowed for each SKU.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    _listSkus(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, listSkusOperationSpec$2);
    }
    /**
     * Gets list of OS upgrades on a VM scale set instance.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    _getOSUpgradeHistory(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, getOSUpgradeHistoryOperationSpec);
    }
    /**
     * Power off (stop) one or more virtual machines in a VM scale set. Note that resources are still
     * attached and you are getting charged for the resources. Instead, use deallocate to release resources
     * and avoid charges.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginPowerOff(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, powerOffOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Power off (stop) one or more virtual machines in a VM scale set. Note that resources are still
     * attached and you are getting charged for the resources. Instead, use deallocate to release resources
     * and avoid charges.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginPowerOffAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPowerOff(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restarts one or more virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, restartOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restarts one or more virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts one or more virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, startOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts one or more virtual machines in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Shuts down all the virtual machines in the virtual machine scale set, moves them to a new node, and
     * powers them back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginRedeploy(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, redeployOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Shuts down all the virtual machines in the virtual machine scale set, moves them to a new node, and
     * powers them back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginRedeployAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRedeploy(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Perform maintenance on one or more virtual machines in a VM scale set. Operation on instances which
     * are not eligible for perform maintenance will be failed. Please refer to best practices for more
     * details:
     * https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-maintenance-notifications
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginPerformMaintenance(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, performMaintenanceOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Perform maintenance on one or more virtual machines in a VM scale set. Operation on instances which
     * are not eligible for perform maintenance will be failed. Please refer to best practices for more
     * details:
     * https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-maintenance-notifications
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginPerformMaintenanceAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPerformMaintenance(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Upgrades one or more virtual machines to the latest SKU set in the VM scale set model.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param vmInstanceIDs A list of virtual machine instance IDs from the VM scale set.
     * @param options The options parameters.
     */
    beginUpdateInstances(resourceGroupName, vmScaleSetName, vmInstanceIDs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, vmInstanceIDs, options }, updateInstancesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Upgrades one or more virtual machines to the latest SKU set in the VM scale set model.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param vmInstanceIDs A list of virtual machine instance IDs from the VM scale set.
     * @param options The options parameters.
     */
    beginUpdateInstancesAndWait(resourceGroupName, vmScaleSetName, vmInstanceIDs, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateInstances(resourceGroupName, vmScaleSetName, vmInstanceIDs, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reimages (upgrade the operating system) one or more virtual machines in a VM scale set which don't
     * have a ephemeral OS disk, for virtual machines who have a ephemeral OS disk the virtual machine is
     * reset to initial state.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginReimage(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, reimageOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reimages (upgrade the operating system) one or more virtual machines in a VM scale set which don't
     * have a ephemeral OS disk, for virtual machines who have a ephemeral OS disk the virtual machine is
     * reset to initial state.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginReimageAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reimages all the disks ( including data disks ) in the virtual machines in a VM scale set. This
     * operation is only supported for managed disks.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginReimageAll(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, reimageAllOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reimages all the disks ( including data disks ) in the virtual machines in a VM scale set. This
     * operation is only supported for managed disks.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginReimageAllAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimageAll(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Manual platform update domain walk to update virtual machines in a service fabric virtual machine
     * scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param platformUpdateDomain The platform update domain for which a manual recovery walk is requested
     * @param options The options parameters.
     */
    forceRecoveryServiceFabricPlatformUpdateDomainWalk(resourceGroupName, vmScaleSetName, platformUpdateDomain, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, platformUpdateDomain, options }, forceRecoveryServiceFabricPlatformUpdateDomainWalkOperationSpec);
    }
    /**
     * Converts SinglePlacementGroup property to false for a existing virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the virtual machine scale set to create or update.
     * @param parameters The input object for ConvertToSinglePlacementGroup API.
     * @param options The options parameters.
     */
    convertToSinglePlacementGroup(resourceGroupName, vmScaleSetName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, parameters, options }, convertToSinglePlacementGroupOperationSpec);
    }
    /**
     * Changes ServiceState property for a given service
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the virtual machine scale set to create or update.
     * @param parameters The input object for SetOrchestrationServiceState API.
     * @param options The options parameters.
     */
    beginSetOrchestrationServiceState(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, parameters, options }, setOrchestrationServiceStateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Changes ServiceState property for a given service
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the virtual machine scale set to create or update.
     * @param parameters The input object for SetOrchestrationServiceState API.
     * @param options The options parameters.
     */
    beginSetOrchestrationServiceStateAndWait(resourceGroupName, vmScaleSetName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetOrchestrationServiceState(resourceGroupName, vmScaleSetName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLocationNext
     * @param location The location for which VM scale sets under the subscription are queried.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listByLocationNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$m);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$3);
    }
    /**
     * ListSkusNext
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param nextLink The nextLink from the previous successful call to the ListSkus method.
     * @param options The options parameters.
     */
    _listSkusNext(resourceGroupName, vmScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, nextLink, options }, listSkusNextOperationSpec);
    }
    /**
     * GetOSUpgradeHistoryNext
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param nextLink The nextLink from the previous successful call to the GetOSUpgradeHistory method.
     * @param options The options parameters.
     */
    _getOSUpgradeHistoryNext(resourceGroupName, vmScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, nextLink, options }, getOSUpgradeHistoryNextOperationSpec);
    }
}
// Operation Specifications
const serializer$J = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/virtualMachineScaleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSet
        },
        201: {
            bodyMapper: VirtualMachineScaleSet
        },
        202: {
            bodyMapper: VirtualMachineScaleSet
        },
        204: {
            bodyMapper: VirtualMachineScaleSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const updateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSet
        },
        201: {
            bodyMapper: VirtualMachineScaleSet
        },
        202: {
            bodyMapper: VirtualMachineScaleSet
        },
        204: {
            bodyMapper: VirtualMachineScaleSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const deleteOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, forceDeletion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const deallocateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/deallocate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const deleteInstancesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/delete",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs1,
    queryParameters: [apiVersion, forceDeletion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const getInstanceViewOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/instanceView",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetInstanceView
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listAllOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachineScaleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListWithLinkResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$J
};
const listSkusOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOSUpgradeHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/osUpgradeHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListOSUpgradeHistory
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const powerOffOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/poweroff",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion, skipShutdown],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const restartOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const startOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const redeployOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/redeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const performMaintenanceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/performMaintenance",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const updateInstancesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/manualupgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const reimageOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmScaleSetReimageInput,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const reimageAllOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/reimageall",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmInstanceIDs,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const forceRecoveryServiceFabricPlatformUpdateDomainWalkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/forceRecoveryServiceFabricPlatformUpdateDomainWalk",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RecoveryWalkResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        platformUpdateDomain,
        zone,
        placementGroupId
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const convertToSinglePlacementGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/convertToSinglePlacementGroup",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const setOrchestrationServiceStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/setOrchestrationServiceState",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const listByLocationNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listAllNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListWithLinkResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOSUpgradeHistoryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetListOSUpgradeHistory
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineScaleSetExtensions operations. */
class VirtualMachineScaleSetExtensionsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSetExtensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all extensions in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set containing the extension.
     * @param options The options parameters.
     */
    list(resourceGroupName, vmScaleSetName, options) {
        const iter = this.listPagingAll(resourceGroupName, vmScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, vmScaleSetName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, vmScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vmScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, vmScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vmScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The operation to create or update an extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be create or updated.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param extensionParameters Parameters supplied to the Create VM scale set Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                vmssExtensionName,
                extensionParameters,
                options
            }, createOrUpdateOperationSpec$n);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update an extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be create or updated.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param extensionParameters Parameters supplied to the Create VM scale set Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update an extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be updated.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param extensionParameters Parameters supplied to the Update VM scale set Extension operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                vmssExtensionName,
                extensionParameters,
                options
            }, updateOperationSpec$q);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update an extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be updated.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param extensionParameters Parameters supplied to the Update VM scale set Extension operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmScaleSetName, vmssExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be deleted.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmScaleSetName, vmssExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, vmssExtensionName, options }, deleteOperationSpec$r);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be deleted.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmScaleSetName, vmssExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmScaleSetName, vmssExtensionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set containing the extension.
     * @param vmssExtensionName The name of the VM scale set extension.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmScaleSetName, vmssExtensionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, vmssExtensionName, options }, getOperationSpec$C);
    }
    /**
     * Gets a list of all extensions in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set containing the extension.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, listOperationSpec$p);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set containing the extension.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vmScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, nextLink, options }, listNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$I = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        201: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        202: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        204: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        vmssExtensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const updateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        201: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        202: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        204: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        vmssExtensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const deleteOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        vmssExtensionName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions/{vmssExtensionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        vmssExtensionName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetExtensionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetExtensionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineScaleSetRollingUpgrades operations. */
class VirtualMachineScaleSetRollingUpgradesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSetRollingUpgrades class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Cancels the current virtual machine scale set rolling upgrade.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginCancel(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, cancelOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Cancels the current virtual machine scale set rolling upgrade.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginCancelAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCancel(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts a rolling upgrade to move all virtual machine scale set instances to the latest available
     * Platform Image OS version. Instances which are already running the latest available OS version are
     * not affected.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStartOSUpgrade(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, startOSUpgradeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts a rolling upgrade to move all virtual machine scale set instances to the latest available
     * Platform Image OS version. Instances which are already running the latest available OS version are
     * not affected.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStartOSUpgradeAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartOSUpgrade(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts a rolling upgrade to move all extensions for all virtual machine scale set instances to the
     * latest available extension version. Instances which are already running the latest extension
     * versions are not affected.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStartExtensionUpgrade(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, options }, startExtensionUpgradeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts a rolling upgrade to move all extensions for all virtual machine scale set instances to the
     * latest available extension version. Instances which are already running the latest extension
     * versions are not affected.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    beginStartExtensionUpgradeAndWait(resourceGroupName, vmScaleSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartExtensionUpgrade(resourceGroupName, vmScaleSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of the latest virtual machine scale set rolling upgrade.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    getLatest(resourceGroupName, vmScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, options }, getLatestOperationSpec);
    }
}
// Operation Specifications
const serializer$H = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/rollingUpgrades/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const startOSUpgradeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/osRollingUpgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const startExtensionUpgradeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/extensionRollingUpgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const getLatestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/rollingUpgrades/latest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RollingUpgradeStatusInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineScaleSetVMExtensions operations. */
class VirtualMachineScaleSetVMExtensionsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSetVMExtensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to create or update the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Create Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                vmExtensionName,
                extensionParameters,
                options
            }, createOrUpdateOperationSpec$m);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Create Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Update Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                vmExtensionName,
                extensionParameters,
                options
            }, updateOperationSpec$p);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Update Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                vmExtensionName,
                options
            }, deleteOperationSpec$q);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the VMSS VM extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmScaleSetName, instanceId, vmExtensionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vmScaleSetName,
            instanceId,
            vmExtensionName,
            options
        }, getOperationSpec$B);
    }
    /**
     * The operation to get all extensions of an instance in Virtual Machine Scaleset.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    list(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, listOperationSpec$o);
    }
}
// Operation Specifications
const serializer$G = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        201: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        202: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        204: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        vmExtensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const updateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        201: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        202: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        204: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        vmExtensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const deleteOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        vmExtensionName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions/{vmExtensionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        vmExtensionName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/extensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMExtensionsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineScaleSetVMs operations. */
class VirtualMachineScaleSetVMsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSetVMs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all virtual machines in a VM scale sets.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualMachineScaleSetName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualMachineScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, virtualMachineScaleSetName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, virtualMachineScaleSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualMachineScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualMachineScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Reimages (upgrade the operating system) a specific virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginReimage(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, reimageOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reimages (upgrade the operating system) a specific virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginReimageAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows you to re-image all the disks ( including data disks ) in the a VM scale set instance. This
     * operation is only supported for managed disks.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginReimageAll(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, reimageAllOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Allows you to re-image all the disks ( including data disks ) in the a VM scale set instance. This
     * operation is only supported for managed disks.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginReimageAllAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimageAll(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deallocates a specific virtual machine in a VM scale set. Shuts down the virtual machine and
     * releases the compute resources it uses. You are not billed for the compute resources of this virtual
     * machine once it is deallocated.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginDeallocate(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, deallocateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deallocates a specific virtual machine in a VM scale set. Shuts down the virtual machine and
     * releases the compute resources it uses. You are not billed for the compute resources of this virtual
     * machine once it is deallocated.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginDeallocateAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeallocate(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual machine of a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be create or updated.
     * @param instanceId The instance ID of the virtual machine.
     * @param parameters Parameters supplied to the Update Virtual Machine Scale Sets VM operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmScaleSetName, instanceId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, parameters, options }, updateOperationSpec$o);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a virtual machine of a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set where the extension should be create or updated.
     * @param instanceId The instance ID of the virtual machine.
     * @param parameters Parameters supplied to the Update Virtual Machine Scale Sets VM operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmScaleSetName, instanceId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmScaleSetName, instanceId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a virtual machine from a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, deleteOperationSpec$p);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a virtual machine from a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a virtual machine from a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, getOperationSpec$A);
    }
    /**
     * Gets the status of a virtual machine from a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    getInstanceView(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, getInstanceViewOperationSpec$2);
    }
    /**
     * Gets a list of all virtual machines in a VM scale sets.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the VM scale set.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualMachineScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, options }, listOperationSpec$n);
    }
    /**
     * Power off (stop) a virtual machine in a VM scale set. Note that resources are still attached and you
     * are getting charged for the resources. Instead, use deallocate to release resources and avoid
     * charges.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginPowerOff(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, powerOffOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Power off (stop) a virtual machine in a VM scale set. Note that resources are still attached and you
     * are getting charged for the resources. Instead, use deallocate to release resources and avoid
     * charges.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginPowerOffAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPowerOff(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restarts a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, restartOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restarts a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, startOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Shuts down the virtual machine in the virtual machine scale set, moves it to a new node, and powers
     * it back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeploy(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, redeployOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Shuts down the virtual machine in the virtual machine scale set, moves it to a new node, and powers
     * it back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeployAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRedeploy(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to retrieve SAS URIs of boot diagnostic logs for a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    retrieveBootDiagnosticsData(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, retrieveBootDiagnosticsDataOperationSpec$1);
    }
    /**
     * Performs maintenance on a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginPerformMaintenance(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, options }, performMaintenanceOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Performs maintenance on a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    beginPerformMaintenanceAndWait(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPerformMaintenance(resourceGroupName, vmScaleSetName, instanceId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to simulate the eviction of spot virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    simulateEviction(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, simulateEvictionOperationSpec$1);
    }
    /**
     * Run command on a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param parameters Parameters supplied to the Run command operation.
     * @param options The options parameters.
     */
    beginRunCommand(resourceGroupName, vmScaleSetName, instanceId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmScaleSetName, instanceId, parameters, options }, runCommandOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Run command on a virtual machine in a VM scale set.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param parameters Parameters supplied to the Run command operation.
     * @param options The options parameters.
     */
    beginRunCommandAndWait(resourceGroupName, vmScaleSetName, instanceId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRunCommand(resourceGroupName, vmScaleSetName, instanceId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the VM scale set.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualMachineScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$F = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const reimageOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vmScaleSetVMReimageInput,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const reimageAllOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/reimageall",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const deallocateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/deallocate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const updateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVM
        },
        201: {
            bodyMapper: VirtualMachineScaleSetVM
        },
        202: {
            bodyMapper: VirtualMachineScaleSetVM
        },
        204: {
            bodyMapper: VirtualMachineScaleSetVM
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const deleteOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, forceDeletion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVM
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getInstanceViewOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/instanceView",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMInstanceView
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand1,
        filter,
        select
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const powerOffOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/poweroff",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, skipShutdown],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const restartOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const startOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const redeployOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/redeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const retrieveBootDiagnosticsDataOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/retrieveBootDiagnosticsData",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RetrieveBootDiagnosticsDataResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        sasUriExpirationTimeInMinutes
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const performMaintenanceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/performMaintenance",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const simulateEvictionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/simulateEviction",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const runCommandOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualmachines/{instanceId}/runCommand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RunCommandResult
        },
        201: {
            bodyMapper: RunCommandResult
        },
        202: {
            bodyMapper: RunCommandResult
        },
        204: {
            bodyMapper: RunCommandResult
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$F
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineScaleSetVMListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand1,
        filter,
        select
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineExtensions operations. */
class VirtualMachineExtensionsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineExtensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be created or updated.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Create Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmName, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmName,
                vmExtensionName,
                extensionParameters,
                options
            }, createOrUpdateOperationSpec$l);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be created or updated.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Create Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmName, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmName, vmExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be updated.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Update Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmName, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmName,
                vmExtensionName,
                extensionParameters,
                options
            }, updateOperationSpec$n);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be updated.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param extensionParameters Parameters supplied to the Update Virtual Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmName, vmExtensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmName, vmExtensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be deleted.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmName, vmExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, vmExtensionName, options }, deleteOperationSpec$o);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the extension should be deleted.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmName, vmExtensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmName, vmExtensionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the extension.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the extension.
     * @param vmExtensionName The name of the virtual machine extension.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmName, vmExtensionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, vmExtensionName, options }, getOperationSpec$z);
    }
    /**
     * The operation to get all extensions of a Virtual Machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the extension.
     * @param options The options parameters.
     */
    list(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, listOperationSpec$m);
    }
}
// Operation Specifications
const serializer$E = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineExtension
        },
        201: {
            bodyMapper: VirtualMachineExtension
        },
        202: {
            bodyMapper: VirtualMachineExtension
        },
        204: {
            bodyMapper: VirtualMachineExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmExtensionName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$E
};
const updateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineExtension
        },
        201: {
            bodyMapper: VirtualMachineExtension
        },
        202: {
            bodyMapper: VirtualMachineExtension
        },
        204: {
            bodyMapper: VirtualMachineExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: extensionParameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmExtensionName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$E
};
const deleteOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmExtensionName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions/{vmExtensionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineExtension
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmExtensionName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/extensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineExtensionsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the virtual machines under the specified subscription for the specified location.
     * @param location The location for which virtual machines under the subscription are queried.
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(location, options);
            }
        };
    }
    listByLocationPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the virtual machines in the specified resource group. Use the nextLink property in the
     * response to get the next page of virtual machines.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the virtual machines in the specified subscription. Use the nextLink property in the
     * response to get the next page of virtual machines.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists all available virtual machine sizes to which the specified virtual machine can be resized.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    listAvailableSizes(resourceGroupName, vmName, options) {
        const iter = this.listAvailableSizesPagingAll(resourceGroupName, vmName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAvailableSizesPagingPage(resourceGroupName, vmName, options);
            }
        };
    }
    listAvailableSizesPagingPage(resourceGroupName, vmName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSizesPagingPage_1() {
            let result = yield tslib.__await(this._listAvailableSizes(resourceGroupName, vmName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listAvailableSizesPagingAll(resourceGroupName, vmName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSizesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAvailableSizesPagingPage(resourceGroupName, vmName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets all the virtual machines under the specified subscription for the specified location.
     * @param location The location for which virtual machines under the subscription are queried.
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
    /**
     * Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to
     * create similar VMs.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Capture Virtual Machine operation.
     * @param options The options parameters.
     */
    beginCapture(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, parameters, options }, captureOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Captures the VM by copying virtual hard disks of the VM and outputs a template that can be used to
     * create similar VMs.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Capture Virtual Machine operation.
     * @param options The options parameters.
     */
    beginCaptureAndWait(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCapture(resourceGroupName, vmName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to create or update a virtual machine. Please note some properties can be set only
     * during virtual machine creation.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Create Virtual Machine operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, parameters, options }, createOrUpdateOperationSpec$k);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update a virtual machine. Please note some properties can be set only
     * during virtual machine creation.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Create Virtual Machine operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Update Virtual Machine operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, parameters, options }, updateOperationSpec$m);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Update Virtual Machine operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, deleteOperationSpec$n);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about the model view or the instance view of a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, getOperationSpec$y);
    }
    /**
     * Retrieves information about the run-time state of a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    instanceView(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, instanceViewOperationSpec);
    }
    /**
     * Converts virtual machine disks from blob-based to managed disks. Virtual machine must be
     * stop-deallocated before invoking this operation.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginConvertToManagedDisks(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, convertToManagedDisksOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Converts virtual machine disks from blob-based to managed disks. Virtual machine must be
     * stop-deallocated before invoking this operation.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginConvertToManagedDisksAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginConvertToManagedDisks(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Shuts down the virtual machine and releases the compute resources. You are not billed for the
     * compute resources that this virtual machine uses.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDeallocate(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, deallocateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Shuts down the virtual machine and releases the compute resources. You are not billed for the
     * compute resources that this virtual machine uses.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDeallocateAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeallocate(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Sets the OS state of the virtual machine to generalized. It is recommended to sysprep the virtual
     * machine before performing this operation. <br>For Windows, please refer to [Create a managed image
     * of a generalized VM in
     * Azure](https://docs.microsoft.com/azure/virtual-machines/windows/capture-image-resource).<br>For
     * Linux, please refer to [How to create an image of a virtual machine or
     * VHD](https://docs.microsoft.com/azure/virtual-machines/linux/capture-image).
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    generalize(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, generalizeOperationSpec);
    }
    /**
     * Lists all of the virtual machines in the specified resource group. Use the nextLink property in the
     * response to get the next page of virtual machines.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$l);
    }
    /**
     * Lists all of the virtual machines in the specified subscription. Use the nextLink property in the
     * response to get the next page of virtual machines.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$2);
    }
    /**
     * Lists all available virtual machine sizes to which the specified virtual machine can be resized.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    _listAvailableSizes(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, listAvailableSizesOperationSpec$1);
    }
    /**
     * The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the
     * same provisioned resources. You are still charged for this virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginPowerOff(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, powerOffOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to power off (stop) a virtual machine. The virtual machine can be restarted with the
     * same provisioned resources. You are still charged for this virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginPowerOffAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPowerOff(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to reapply a virtual machine's state.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginReapply(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, reapplyOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to reapply a virtual machine's state.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginReapplyAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReapply(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to restart a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, restartOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to restart a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to start a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, startOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to start a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Shuts down the virtual machine, moves it to a new node, and powers it back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeploy(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, redeployOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Shuts down the virtual machine, moves it to a new node, and powers it back on.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeployAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRedeploy(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reimages the virtual machine which has an ephemeral OS disk back to its initial state.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginReimage(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, reimageOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reimages the virtual machine which has an ephemeral OS disk back to its initial state.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginReimageAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to retrieve SAS URIs for a virtual machine's boot diagnostic logs.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    retrieveBootDiagnosticsData(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, retrieveBootDiagnosticsDataOperationSpec);
    }
    /**
     * The operation to perform maintenance on a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginPerformMaintenance(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, performMaintenanceOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to perform maintenance on a virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginPerformMaintenanceAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPerformMaintenance(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to simulate the eviction of spot virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    simulateEviction(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, simulateEvictionOperationSpec);
    }
    /**
     * Assess patches on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginAssessPatches(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, options }, assessPatchesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Assess patches on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param options The options parameters.
     */
    beginAssessPatchesAndWait(resourceGroupName, vmName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAssessPatches(resourceGroupName, vmName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Installs patches on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param installPatchesInput Input for InstallPatches as directly received by the API
     * @param options The options parameters.
     */
    beginInstallPatches(resourceGroupName, vmName, installPatchesInput, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, installPatchesInput, options }, installPatchesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Installs patches on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param installPatchesInput Input for InstallPatches as directly received by the API
     * @param options The options parameters.
     */
    beginInstallPatchesAndWait(resourceGroupName, vmName, installPatchesInput, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallPatches(resourceGroupName, vmName, installPatchesInput, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Run command on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Run command operation.
     * @param options The options parameters.
     */
    beginRunCommand(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, parameters, options }, runCommandOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Run command on the VM.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine.
     * @param parameters Parameters supplied to the Run command operation.
     * @param options The options parameters.
     */
    beginRunCommandAndWait(resourceGroupName, vmName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRunCommand(resourceGroupName, vmName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLocationNext
     * @param location The location for which virtual machines under the subscription are queried.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listByLocationNextOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$j);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$D = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const captureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/capture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualMachineCaptureResult
        },
        201: {
            bodyMapper: VirtualMachineCaptureResult
        },
        202: {
            bodyMapper: VirtualMachineCaptureResult
        },
        204: {
            bodyMapper: VirtualMachineCaptureResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        201: {
            bodyMapper: VirtualMachine
        },
        202: {
            bodyMapper: VirtualMachine
        },
        204: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const updateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        201: {
            bodyMapper: VirtualMachine
        },
        202: {
            bodyMapper: VirtualMachine
        },
        204: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, forceDeletion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const instanceViewOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/instanceView",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineInstanceView
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const convertToManagedDisksOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/convertToManagedDisks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const deallocateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/deallocate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, hibernate],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const generalizeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/generalize",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listAllOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        statusOnly
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$D
};
const listAvailableSizesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/vmSizes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineSizeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const powerOffOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/powerOff",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, skipShutdown],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const reapplyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reapply",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const restartOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const redeployOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/redeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const reimageOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const retrieveBootDiagnosticsDataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/retrieveBootDiagnosticsData",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RetrieveBootDiagnosticsDataResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        sasUriExpirationTimeInMinutes
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const performMaintenanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/performMaintenance",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const simulateEvictionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/simulateEviction",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const assessPatchesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/assessPatches",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualMachineAssessPatchesResult
        },
        201: {
            bodyMapper: VirtualMachineAssessPatchesResult
        },
        202: {
            bodyMapper: VirtualMachineAssessPatchesResult
        },
        204: {
            bodyMapper: VirtualMachineAssessPatchesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const installPatchesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/installPatches",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualMachineInstallPatchesResult
        },
        201: {
            bodyMapper: VirtualMachineInstallPatchesResult
        },
        202: {
            bodyMapper: VirtualMachineInstallPatchesResult
        },
        204: {
            bodyMapper: VirtualMachineInstallPatchesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: installPatchesInput,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const runCommandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RunCommandResult
        },
        201: {
            bodyMapper: RunCommandResult
        },
        202: {
            bodyMapper: RunCommandResult
        },
        204: {
            bodyMapper: RunCommandResult
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$D
};
const listByLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listAllNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        statusOnly
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineImages operations. */
class VirtualMachineImagesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a virtual machine image.
     * @param location The name of a supported Azure region.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param skus A valid image SKU.
     * @param version A valid image SKU version.
     * @param options The options parameters.
     */
    get(location, publisherName, offer, skus, version, options) {
        return this.client.sendOperationRequest({ location, publisherName, offer, skus, version, options }, getOperationSpec$x);
    }
    /**
     * Gets a list of all virtual machine image versions for the specified location, publisher, offer, and
     * SKU.
     * @param location The name of a supported Azure region.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param skus A valid image SKU.
     * @param options The options parameters.
     */
    list(location, publisherName, offer, skus, options) {
        return this.client.sendOperationRequest({ location, publisherName, offer, skus, options }, listOperationSpec$k);
    }
    /**
     * Gets a list of virtual machine image offers for the specified location and publisher.
     * @param location The name of a supported Azure region.
     * @param publisherName A valid image publisher.
     * @param options The options parameters.
     */
    listOffers(location, publisherName, options) {
        return this.client.sendOperationRequest({ location, publisherName, options }, listOffersOperationSpec$1);
    }
    /**
     * Gets a list of virtual machine image publishers for the specified Azure location.
     * @param location The name of a supported Azure region.
     * @param options The options parameters.
     */
    listPublishers(location, options) {
        return this.client.sendOperationRequest({ location, options }, listPublishersOperationSpec$1);
    }
    /**
     * Gets a list of virtual machine image SKUs for the specified location, publisher, and offer.
     * @param location The name of a supported Azure region.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param options The options parameters.
     */
    listSkus(location, publisherName, offer, options) {
        return this.client.sendOperationRequest({ location, publisherName, offer, options }, listSkusOperationSpec$1);
    }
    /**
     * Gets a list of all virtual machine image versions for the specified edge zone
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param options The options parameters.
     */
    listByEdgeZone(location, edgeZone, options) {
        return this.client.sendOperationRequest({ location, edgeZone, options }, listByEdgeZoneOperationSpec);
    }
}
// Operation Specifications
const serializer$C = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer,
        skus,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand1,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer,
        skus
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listOffersOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listPublishersOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listSkusOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listByEdgeZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/vmimages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VmImagesInEdgeZoneListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineImagesEdgeZone operations. */
class VirtualMachineImagesEdgeZoneImpl {
    /**
     * Initialize a new instance of the class VirtualMachineImagesEdgeZone class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a virtual machine image in an edge zone.
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param skus A valid image SKU.
     * @param version A valid image SKU version.
     * @param options The options parameters.
     */
    get(location, edgeZone, publisherName, offer, skus, version, options) {
        return this.client.sendOperationRequest({ location, edgeZone, publisherName, offer, skus, version, options }, getOperationSpec$w);
    }
    /**
     * Gets a list of all virtual machine image versions for the specified location, edge zone, publisher,
     * offer, and SKU.
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param skus A valid image SKU.
     * @param options The options parameters.
     */
    list(location, edgeZone, publisherName, offer, skus, options) {
        return this.client.sendOperationRequest({ location, edgeZone, publisherName, offer, skus, options }, listOperationSpec$j);
    }
    /**
     * Gets a list of virtual machine image offers for the specified location, edge zone and publisher.
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param publisherName A valid image publisher.
     * @param options The options parameters.
     */
    listOffers(location, edgeZone, publisherName, options) {
        return this.client.sendOperationRequest({ location, edgeZone, publisherName, options }, listOffersOperationSpec);
    }
    /**
     * Gets a list of virtual machine image publishers for the specified Azure location and edge zone.
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param options The options parameters.
     */
    listPublishers(location, edgeZone, options) {
        return this.client.sendOperationRequest({ location, edgeZone, options }, listPublishersOperationSpec);
    }
    /**
     * Gets a list of virtual machine image SKUs for the specified location, edge zone, publisher, and
     * offer.
     * @param location The name of a supported Azure region.
     * @param edgeZone The name of the edge zone.
     * @param publisherName A valid image publisher.
     * @param offer A valid image publisher offer.
     * @param options The options parameters.
     */
    listSkus(location, edgeZone, publisherName, offer, options) {
        return this.client.sendOperationRequest({ location, edgeZone, publisherName, offer, options }, listSkusOperationSpec);
    }
}
// Operation Specifications
const serializer$B = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer,
        skus,
        version,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus/{skus}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand1,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer,
        skus,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listOffersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/publishers/{publisherName}/artifacttypes/vmimage/offers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listPublishersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/publishers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/edgeZones/{edgeZone}/publishers/{publisherName}/artifacttypes/vmimage/offers/{offer}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineImageResource"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        offer,
        edgeZone
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineExtensionImages operations. */
class VirtualMachineExtensionImagesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineExtensionImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a virtual machine extension image.
     * @param location The name of a supported Azure region.
     * @param publisherName
     * @param version
     * @param typeParam
     * @param options The options parameters.
     */
    get(location, publisherName, version, typeParam, options) {
        return this.client.sendOperationRequest({ location, publisherName, version, typeParam, options }, getOperationSpec$v);
    }
    /**
     * Gets a list of virtual machine extension image types.
     * @param location The name of a supported Azure region.
     * @param publisherName
     * @param options The options parameters.
     */
    listTypes(location, publisherName, options) {
        return this.client.sendOperationRequest({ location, publisherName, options }, listTypesOperationSpec);
    }
    /**
     * Gets a list of virtual machine extension image versions.
     * @param location The name of a supported Azure region.
     * @param publisherName
     * @param typeParam
     * @param options The options parameters.
     */
    listVersions(location, publisherName, typeParam, options) {
        return this.client.sendOperationRequest({ location, publisherName, typeParam, options }, listVersionsOperationSpec);
    }
}
// Operation Specifications
const serializer$A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types/{type}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineExtensionImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        version,
        typeParam
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listTypesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtensionImage"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/publishers/{publisherName}/artifacttypes/vmextension/types/{type}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineExtensionImage"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publisherName,
        typeParam
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailabilitySets operations. */
class AvailabilitySetsImpl {
    /**
     * Initialize a new instance of the class AvailabilitySets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all availability sets in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all availability sets in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all available virtual machine sizes that can be used to create a new virtual machine in an
     * existing availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param options The options parameters.
     */
    listAvailableSizes(resourceGroupName, availabilitySetName, options) {
        const iter = this.listAvailableSizesPagingAll(resourceGroupName, availabilitySetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAvailableSizesPagingPage(resourceGroupName, availabilitySetName, options);
            }
        };
    }
    listAvailableSizesPagingPage(resourceGroupName, availabilitySetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSizesPagingPage_1() {
            let result = yield tslib.__await(this._listAvailableSizes(resourceGroupName, availabilitySetName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listAvailableSizesPagingAll(resourceGroupName, availabilitySetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSizesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAvailableSizesPagingPage(resourceGroupName, availabilitySetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Create or update an availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param parameters Parameters supplied to the Create Availability Set operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, availabilitySetName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, parameters, options }, createOrUpdateOperationSpec$j);
    }
    /**
     * Update an availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param parameters Parameters supplied to the Update Availability Set operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, availabilitySetName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, parameters, options }, updateOperationSpec$l);
    }
    /**
     * Delete an availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param options The options parameters.
     */
    delete(resourceGroupName, availabilitySetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, options }, deleteOperationSpec$m);
    }
    /**
     * Retrieves information about an availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param options The options parameters.
     */
    get(resourceGroupName, availabilitySetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, options }, getOperationSpec$u);
    }
    /**
     * Lists all availability sets in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$4);
    }
    /**
     * Lists all availability sets in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$i);
    }
    /**
     * Lists all available virtual machine sizes that can be used to create a new virtual machine in an
     * existing availability set.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName The name of the availability set.
     * @param options The options parameters.
     */
    _listAvailableSizes(resourceGroupName, availabilitySetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, options }, listAvailableSizesOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$z
};
const updateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$z
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listBySubscriptionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/availabilitySets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$z
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listAvailableSizesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/availabilitySets/{availabilitySetName}/vmSizes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineSizeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listBySubscriptionNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProximityPlacementGroups operations. */
class ProximityPlacementGroupsImpl {
    /**
     * Initialize a new instance of the class ProximityPlacementGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all proximity placement groups in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all proximity placement groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Create or update a proximity placement group.
     * @param resourceGroupName The name of the resource group.
     * @param proximityPlacementGroupName The name of the proximity placement group.
     * @param parameters Parameters supplied to the Create Proximity Placement Group operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, proximityPlacementGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, proximityPlacementGroupName, parameters, options }, createOrUpdateOperationSpec$i);
    }
    /**
     * Update a proximity placement group.
     * @param resourceGroupName The name of the resource group.
     * @param proximityPlacementGroupName The name of the proximity placement group.
     * @param parameters Parameters supplied to the Update Proximity Placement Group operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, proximityPlacementGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, proximityPlacementGroupName, parameters, options }, updateOperationSpec$k);
    }
    /**
     * Delete a proximity placement group.
     * @param resourceGroupName The name of the resource group.
     * @param proximityPlacementGroupName The name of the proximity placement group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, proximityPlacementGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, proximityPlacementGroupName, options }, deleteOperationSpec$l);
    }
    /**
     * Retrieves information about a proximity placement group .
     * @param resourceGroupName The name of the resource group.
     * @param proximityPlacementGroupName The name of the proximity placement group.
     * @param options The options parameters.
     */
    get(resourceGroupName, proximityPlacementGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, proximityPlacementGroupName, options }, getOperationSpec$t);
    }
    /**
     * Lists all proximity placement groups in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * Lists all proximity placement groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$9);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroup
        },
        201: {
            bodyMapper: ProximityPlacementGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        proximityPlacementGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const updateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        proximityPlacementGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        proximityPlacementGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, includeColocationStatus],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        proximityPlacementGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/proximityPlacementGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$y
};
const listByResourceGroupOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listByResourceGroupNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProximityPlacementGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DedicatedHostGroups operations. */
class DedicatedHostGroupsImpl {
    /**
     * Initialize a new instance of the class DedicatedHostGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the dedicated host groups in the specified resource group. Use the nextLink property in
     * the response to get the next page of dedicated host groups.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the dedicated host groups in the subscription. Use the nextLink property in the
     * response to get the next page of dedicated host groups.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Create or update a dedicated host group. For details of Dedicated Host and Dedicated Host Groups
     * please see [Dedicated Host Documentation] (https://go.microsoft.com/fwlink/?linkid=2082596)
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param parameters Parameters supplied to the Create Dedicated Host Group.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, hostGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, parameters, options }, createOrUpdateOperationSpec$h);
    }
    /**
     * Update an dedicated host group.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param parameters Parameters supplied to the Update Dedicated Host Group operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, hostGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, parameters, options }, updateOperationSpec$j);
    }
    /**
     * Delete a dedicated host group.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, hostGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, options }, deleteOperationSpec$k);
    }
    /**
     * Retrieves information about a dedicated host group.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param options The options parameters.
     */
    get(resourceGroupName, hostGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, options }, getOperationSpec$s);
    }
    /**
     * Lists all of the dedicated host groups in the specified resource group. Use the nextLink property in
     * the response to get the next page of dedicated host groups.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$8);
    }
    /**
     * Lists all of the dedicated host groups in the subscription. Use the nextLink property in the
     * response to get the next page of dedicated host groups.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$8);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroup
        },
        201: {
            bodyMapper: DedicatedHostGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const updateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listByResourceGroupOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/hostGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$x
};
const listByResourceGroupNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DedicatedHosts operations. */
class DedicatedHostsImpl {
    /**
     * Initialize a new instance of the class DedicatedHosts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the dedicated hosts in the specified dedicated host group. Use the nextLink property in
     * the response to get the next page of dedicated hosts.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param options The options parameters.
     */
    listByHostGroup(resourceGroupName, hostGroupName, options) {
        const iter = this.listByHostGroupPagingAll(resourceGroupName, hostGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHostGroupPagingPage(resourceGroupName, hostGroupName, options);
            }
        };
    }
    listByHostGroupPagingPage(resourceGroupName, hostGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHostGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByHostGroup(resourceGroupName, hostGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHostGroupNext(resourceGroupName, hostGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHostGroupPagingAll(resourceGroupName, hostGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHostGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHostGroupPagingPage(resourceGroupName, hostGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a dedicated host .
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host .
     * @param parameters Parameters supplied to the Create Dedicated Host.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hostGroupName, hostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hostGroupName, hostName, parameters, options }, createOrUpdateOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a dedicated host .
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host .
     * @param parameters Parameters supplied to the Create Dedicated Host.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hostGroupName, hostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hostGroupName, hostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an dedicated host .
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host .
     * @param parameters Parameters supplied to the Update Dedicated Host operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, hostGroupName, hostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hostGroupName, hostName, parameters, options }, updateOperationSpec$i);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an dedicated host .
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host .
     * @param parameters Parameters supplied to the Update Dedicated Host operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, hostGroupName, hostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, hostGroupName, hostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a dedicated host.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hostGroupName, hostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hostGroupName, hostName, options }, deleteOperationSpec$j);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a dedicated host.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hostGroupName, hostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hostGroupName, hostName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a dedicated host.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host.
     * @param options The options parameters.
     */
    get(resourceGroupName, hostGroupName, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, hostName, options }, getOperationSpec$r);
    }
    /**
     * Lists all of the dedicated hosts in the specified dedicated host group. Use the nextLink property in
     * the response to get the next page of dedicated hosts.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param options The options parameters.
     */
    _listByHostGroup(resourceGroupName, hostGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, options }, listByHostGroupOperationSpec);
    }
    /**
     * Restart the dedicated host. The operation will complete successfully once the dedicated host has
     * restarted and is running. To determine the health of VMs deployed on the dedicated host after the
     * restart check the Resource Health Center in the Azure Portal. Please refer to
     * https://docs.microsoft.com/azure/service-health/resource-health-overview for more details.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, hostGroupName, hostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hostGroupName, hostName, options }, restartOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restart the dedicated host. The operation will complete successfully once the dedicated host has
     * restarted and is running. To determine the health of VMs deployed on the dedicated host after the
     * restart check the Resource Health Center in the Azure Portal. Please refer to
     * https://docs.microsoft.com/azure/service-health/resource-health-overview for more details.
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param hostName The name of the dedicated host.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, hostGroupName, hostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, hostGroupName, hostName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByHostGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param hostGroupName The name of the dedicated host group.
     * @param nextLink The nextLink from the previous successful call to the ListByHostGroup method.
     * @param options The options parameters.
     */
    _listByHostGroupNext(resourceGroupName, hostGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostGroupName, nextLink, options }, listByHostGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DedicatedHost
        },
        201: {
            bodyMapper: DedicatedHost
        },
        202: {
            bodyMapper: DedicatedHost
        },
        204: {
            bodyMapper: DedicatedHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName,
        hostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const updateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DedicatedHost
        },
        201: {
            bodyMapper: DedicatedHost
        },
        202: {
            bodyMapper: DedicatedHost
        },
        204: {
            bodyMapper: DedicatedHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName,
        hostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName,
        hostName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName,
        hostName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listByHostGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const restartOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}/hosts/{hostName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostGroupName,
        hostName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listByHostGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        hostGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SshPublicKeys operations. */
class SshPublicKeysImpl {
    /**
     * Initialize a new instance of the class SshPublicKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the SSH public keys in the subscription. Use the nextLink property in the response to
     * get the next page of SSH public keys.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the SSH public keys in the specified resource group. Use the nextLink property in the
     * response to get the next page of SSH public keys.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the SSH public keys in the subscription. Use the nextLink property in the response to
     * get the next page of SSH public keys.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Lists all of the SSH public keys in the specified resource group. Use the nextLink property in the
     * response to get the next page of SSH public keys.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * Creates a new SSH public key resource.
     * @param resourceGroupName The name of the resource group.
     * @param sshPublicKeyName The name of the SSH public key.
     * @param parameters Parameters supplied to create the SSH public key.
     * @param options The options parameters.
     */
    create(resourceGroupName, sshPublicKeyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sshPublicKeyName, parameters, options }, createOperationSpec$1);
    }
    /**
     * Updates a new SSH public key resource.
     * @param resourceGroupName The name of the resource group.
     * @param sshPublicKeyName The name of the SSH public key.
     * @param parameters Parameters supplied to update the SSH public key.
     * @param options The options parameters.
     */
    update(resourceGroupName, sshPublicKeyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sshPublicKeyName, parameters, options }, updateOperationSpec$h);
    }
    /**
     * Delete an SSH public key.
     * @param resourceGroupName The name of the resource group.
     * @param sshPublicKeyName The name of the SSH public key.
     * @param options The options parameters.
     */
    delete(resourceGroupName, sshPublicKeyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sshPublicKeyName, options }, deleteOperationSpec$i);
    }
    /**
     * Retrieves information about an SSH public key.
     * @param resourceGroupName The name of the resource group.
     * @param sshPublicKeyName The name of the SSH public key.
     * @param options The options parameters.
     */
    get(resourceGroupName, sshPublicKeyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sshPublicKeyName, options }, getOperationSpec$q);
    }
    /**
     * Generates and returns a public/private key pair and populates the SSH public key resource with the
     * public key. The length of the key will be 3072 bits. This operation can only be performed once per
     * SSH public key resource.
     * @param resourceGroupName The name of the resource group.
     * @param sshPublicKeyName The name of the SSH public key.
     * @param options The options parameters.
     */
    generateKeyPair(resourceGroupName, sshPublicKeyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sshPublicKeyName, options }, generateKeyPairOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/sshPublicKeys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SshPublicKeysGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$v
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SshPublicKeysGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys/{sshPublicKeyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SshPublicKeyResource
        },
        201: {
            bodyMapper: SshPublicKeyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        sshPublicKeyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const updateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys/{sshPublicKeyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SshPublicKeyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        sshPublicKeyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys/{sshPublicKeyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        sshPublicKeyName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys/{sshPublicKeyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SshPublicKeyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        sshPublicKeyName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const generateKeyPairOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/sshPublicKeys/{sshPublicKeyName}/generateKeyPair",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SshPublicKeyGenerateKeyPairResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        sshPublicKeyName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SshPublicKeysGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SshPublicKeysGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Images operations. */
class ImagesImpl {
    /**
     * Initialize a new instance of the class Images class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of images under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of Images in the subscription. Use nextLink property in the response to get the next
     * page of Images. Do this till nextLink is null to fetch all the Images.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Create or update an image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param parameters Parameters supplied to the Create Image operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, imageName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, imageName, parameters, options }, createOrUpdateOperationSpec$f);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param parameters Parameters supplied to the Create Image operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, imageName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, imageName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param parameters Parameters supplied to the Update Image operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, imageName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, imageName, parameters, options }, updateOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param parameters Parameters supplied to the Update Image operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, imageName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, imageName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an Image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, imageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, imageName, options }, deleteOperationSpec$h);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an Image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, imageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, imageName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets an image.
     * @param resourceGroupName The name of the resource group.
     * @param imageName The name of the image.
     * @param options The options parameters.
     */
    get(resourceGroupName, imageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, imageName, options }, getOperationSpec$p);
    }
    /**
     * Gets the list of images under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * Gets the list of Images in the subscription. Use nextLink property in the response to get the next
     * page of Images. Do this till nextLink is null to fetch all the Images.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$h);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Image
        },
        201: {
            bodyMapper: Image
        },
        202: {
            bodyMapper: Image
        },
        204: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        imageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const updateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Image
        },
        201: {
            bodyMapper: Image
        },
        202: {
            bodyMapper: Image
        },
        204: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        imageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        imageName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images/{imageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        imageName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImageListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImageListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$u
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImageListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImageListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorePointCollections operations. */
class RestorePointCollectionsImpl {
    /**
     * Initialize a new instance of the class RestorePointCollections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of restore point collections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of restore point collections in the subscription. Use nextLink property in the
     * response to get the next page of restore point collections. Do this till nextLink is not null to
     * fetch all the restore point collections.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * The operation to create or update the restore point collection. Please refer to
     * https://aka.ms/RestorePoints for more details. When updating a restore point collection, only tags
     * may be modified.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param parameters Parameters supplied to the Create or Update restore point collection operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, restorePointCollectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, restorePointCollectionName, parameters, options }, createOrUpdateOperationSpec$e);
    }
    /**
     * The operation to update the restore point collection.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param parameters Parameters supplied to the Update restore point collection operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, restorePointCollectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, restorePointCollectionName, parameters, options }, updateOperationSpec$f);
    }
    /**
     * The operation to delete the restore point collection. This operation will also delete all the
     * contained restore points.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the Restore Point Collection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, restorePointCollectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, restorePointCollectionName, options }, deleteOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the restore point collection. This operation will also delete all the
     * contained restore points.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the Restore Point Collection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, restorePointCollectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, restorePointCollectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the restore point collection.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param options The options parameters.
     */
    get(resourceGroupName, restorePointCollectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, restorePointCollectionName, options }, getOperationSpec$o);
    }
    /**
     * Gets the list of restore point collections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$g);
    }
    /**
     * Gets the list of restore point collections in the subscription. Use nextLink property in the
     * response to get the next page of restore point collections. Do this till nextLink is not null to
     * fetch all the restore point collections.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$g);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RestorePointCollection
        },
        201: {
            bodyMapper: RestorePointCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters22,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const updateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RestorePointCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters23,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listAllOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/restorePointCollections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$t
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listAllNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing RestorePoints operations. */
class RestorePointsImpl {
    /**
     * Initialize a new instance of the class RestorePoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to create the restore point. Updating properties of an existing restore point is not
     * allowed
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param restorePointName The name of the restore point.
     * @param parameters Parameters supplied to the Create restore point operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, restorePointCollectionName, restorePointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                restorePointCollectionName,
                restorePointName,
                parameters,
                options
            }, createOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create the restore point. Updating properties of an existing restore point is not
     * allowed
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param restorePointName The name of the restore point.
     * @param parameters Parameters supplied to the Create restore point operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, restorePointCollectionName, restorePointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, restorePointCollectionName, restorePointName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the restore point.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the Restore Point Collection.
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, restorePointCollectionName, restorePointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                restorePointCollectionName,
                restorePointName,
                options
            }, deleteOperationSpec$f);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the restore point.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the Restore Point Collection.
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, restorePointCollectionName, restorePointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, restorePointCollectionName, restorePointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the restore point.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection.
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    get(resourceGroupName, restorePointCollectionName, restorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            restorePointCollectionName,
            restorePointName,
            options
        }, getOperationSpec$n);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{restorePointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        201: {
            bodyMapper: RestorePoint
        },
        202: {
            bodyMapper: RestorePoint
        },
        204: {
            bodyMapper: RestorePoint
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        restorePointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$s
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{restorePointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        restorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{restorePointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        restorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CapacityReservationGroups operations. */
class CapacityReservationGroupsImpl {
    /**
     * Initialize a new instance of the class CapacityReservationGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the capacity reservation groups in the specified resource group. Use the nextLink
     * property in the response to get the next page of capacity reservation groups.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the capacity reservation groups in the subscription. Use the nextLink property in the
     * response to get the next page of capacity reservation groups.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * The operation to create or update a capacity reservation group. When updating a capacity reservation
     * group, only tags may be modified. Please refer to https://aka.ms/CapacityReservation for more
     * details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param parameters Parameters supplied to the Create capacity reservation Group.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, capacityReservationGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, parameters, options }, createOrUpdateOperationSpec$d);
    }
    /**
     * The operation to update a capacity reservation group. When updating a capacity reservation group,
     * only tags may be modified.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param parameters Parameters supplied to the Update capacity reservation Group operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, capacityReservationGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, parameters, options }, updateOperationSpec$e);
    }
    /**
     * The operation to delete a capacity reservation group. This operation is allowed only if all the
     * associated resources are disassociated from the reservation group and all capacity reservations
     * under the reservation group have also been deleted. Please refer to
     * https://aka.ms/CapacityReservation for more details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, capacityReservationGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, options }, deleteOperationSpec$e);
    }
    /**
     * The operation that retrieves information about a capacity reservation group.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param options The options parameters.
     */
    get(resourceGroupName, capacityReservationGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, options }, getOperationSpec$m);
    }
    /**
     * Lists all of the capacity reservation groups in the specified resource group. Use the nextLink
     * property in the response to get the next page of capacity reservation groups.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * Lists all of the capacity reservation groups in the subscription. Use the nextLink property in the
     * response to get the next page of capacity reservation groups.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroup
        },
        201: {
            bodyMapper: CapacityReservationGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const updateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters26,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand6],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/capacityReservationGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand6],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand6],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand6],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CapacityReservations operations. */
class CapacityReservationsImpl {
    /**
     * Initialize a new instance of the class CapacityReservations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the capacity reservations in the specified capacity reservation group. Use the nextLink
     * property in the response to get the next page of capacity reservations.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param options The options parameters.
     */
    listByCapacityReservationGroup(resourceGroupName, capacityReservationGroupName, options) {
        const iter = this.listByCapacityReservationGroupPagingAll(resourceGroupName, capacityReservationGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByCapacityReservationGroupPagingPage(resourceGroupName, capacityReservationGroupName, options);
            }
        };
    }
    listByCapacityReservationGroupPagingPage(resourceGroupName, capacityReservationGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByCapacityReservationGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByCapacityReservationGroup(resourceGroupName, capacityReservationGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByCapacityReservationGroupNext(resourceGroupName, capacityReservationGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByCapacityReservationGroupPagingAll(resourceGroupName, capacityReservationGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByCapacityReservationGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByCapacityReservationGroupPagingPage(resourceGroupName, capacityReservationGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The operation to create or update a capacity reservation. Please note some properties can be set
     * only during capacity reservation creation. Please refer to https://aka.ms/CapacityReservation for
     * more details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param parameters Parameters supplied to the Create capacity reservation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                capacityReservationGroupName,
                capacityReservationName,
                parameters,
                options
            }, createOrUpdateOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update a capacity reservation. Please note some properties can be set
     * only during capacity reservation creation. Please refer to https://aka.ms/CapacityReservation for
     * more details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param parameters Parameters supplied to the Create capacity reservation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update a capacity reservation.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param parameters Parameters supplied to the Update capacity reservation operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                capacityReservationGroupName,
                capacityReservationName,
                parameters,
                options
            }, updateOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update a capacity reservation.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param parameters Parameters supplied to the Update capacity reservation operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, capacityReservationGroupName, capacityReservationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete a capacity reservation. This operation is allowed only when all the
     * associated resources are disassociated from the capacity reservation. Please refer to
     * https://aka.ms/CapacityReservation for more details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, capacityReservationGroupName, capacityReservationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                capacityReservationGroupName,
                capacityReservationName,
                options
            }, deleteOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete a capacity reservation. This operation is allowed only when all the
     * associated resources are disassociated from the capacity reservation. Please refer to
     * https://aka.ms/CapacityReservation for more details.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, capacityReservationGroupName, capacityReservationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, capacityReservationGroupName, capacityReservationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation that retrieves information about the capacity reservation.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param capacityReservationName The name of the capacity reservation.
     * @param options The options parameters.
     */
    get(resourceGroupName, capacityReservationGroupName, capacityReservationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            capacityReservationGroupName,
            capacityReservationName,
            options
        }, getOperationSpec$l);
    }
    /**
     * Lists all of the capacity reservations in the specified capacity reservation group. Use the nextLink
     * property in the response to get the next page of capacity reservations.
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param options The options parameters.
     */
    _listByCapacityReservationGroup(resourceGroupName, capacityReservationGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, options }, listByCapacityReservationGroupOperationSpec);
    }
    /**
     * ListByCapacityReservationGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param capacityReservationGroupName The name of the capacity reservation group.
     * @param nextLink The nextLink from the previous successful call to the ListByCapacityReservationGroup
     *                 method.
     * @param options The options parameters.
     */
    _listByCapacityReservationGroupNext(resourceGroupName, capacityReservationGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, capacityReservationGroupName, nextLink, options }, listByCapacityReservationGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}/capacityReservations/{capacityReservationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CapacityReservation
        },
        201: {
            bodyMapper: CapacityReservation
        },
        202: {
            bodyMapper: CapacityReservation
        },
        204: {
            bodyMapper: CapacityReservation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName,
        capacityReservationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const updateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}/capacityReservations/{capacityReservationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CapacityReservation
        },
        201: {
            bodyMapper: CapacityReservation
        },
        202: {
            bodyMapper: CapacityReservation
        },
        204: {
            bodyMapper: CapacityReservation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters28,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName,
        capacityReservationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}/capacityReservations/{capacityReservationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName,
        capacityReservationName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}/capacityReservations/{capacityReservationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand7],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName,
        capacityReservationName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByCapacityReservationGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/capacityReservationGroups/{capacityReservationGroupName}/capacityReservations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByCapacityReservationGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityReservationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        capacityReservationGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing LogAnalytics operations. */
class LogAnalyticsImpl {
    /**
     * Initialize a new instance of the class LogAnalytics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Export logs that show Api requests made by this subscription in the given time window to show
     * throttling activities.
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param parameters Parameters supplied to the LogAnalytics getRequestRateByInterval Api.
     * @param options The options parameters.
     */
    beginExportRequestRateByInterval(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { location, parameters, options }, exportRequestRateByIntervalOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Export logs that show Api requests made by this subscription in the given time window to show
     * throttling activities.
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param parameters Parameters supplied to the LogAnalytics getRequestRateByInterval Api.
     * @param options The options parameters.
     */
    beginExportRequestRateByIntervalAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExportRequestRateByInterval(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Export logs that show total throttled Api requests for this subscription in the given time window.
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param parameters Parameters supplied to the LogAnalytics getThrottledRequests Api.
     * @param options The options parameters.
     */
    beginExportThrottledRequests(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { location, parameters, options }, exportThrottledRequestsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Export logs that show total throttled Api requests for this subscription in the given time window.
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param parameters Parameters supplied to the LogAnalytics getThrottledRequests Api.
     * @param options The options parameters.
     */
    beginExportThrottledRequestsAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExportThrottledRequests(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const exportRequestRateByIntervalOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/logAnalytics/apiAccess/getRequestRateByInterval",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LogAnalyticsOperationResult
        },
        201: {
            bodyMapper: LogAnalyticsOperationResult
        },
        202: {
            bodyMapper: LogAnalyticsOperationResult
        },
        204: {
            bodyMapper: LogAnalyticsOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const exportThrottledRequestsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/logAnalytics/apiAccess/getThrottledRequests",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LogAnalyticsOperationResult
        },
        201: {
            bodyMapper: LogAnalyticsOperationResult
        },
        202: {
            bodyMapper: LogAnalyticsOperationResult
        },
        204: {
            bodyMapper: LogAnalyticsOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineRunCommands operations. */
class VirtualMachineRunCommandsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineRunCommands class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all available run commands for a subscription in a location.
     * @param location The location upon which run commands is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The operation to get all run commands of a Virtual Machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the run command.
     * @param options The options parameters.
     */
    listByVirtualMachine(resourceGroupName, vmName, options) {
        const iter = this.listByVirtualMachinePagingAll(resourceGroupName, vmName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVirtualMachinePagingPage(resourceGroupName, vmName, options);
            }
        };
    }
    listByVirtualMachinePagingPage(resourceGroupName, vmName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualMachinePagingPage_1() {
            let result = yield tslib.__await(this._listByVirtualMachine(resourceGroupName, vmName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVirtualMachineNext(resourceGroupName, vmName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVirtualMachinePagingAll(resourceGroupName, vmName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualMachinePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVirtualMachinePagingPage(resourceGroupName, vmName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all available run commands for a subscription in a location.
     * @param location The location upon which run commands is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$f);
    }
    /**
     * Gets specific run command for a subscription in a location.
     * @param location The location upon which run commands is queried.
     * @param commandId The command id.
     * @param options The options parameters.
     */
    get(location, commandId, options) {
        return this.client.sendOperationRequest({ location, commandId, options }, getOperationSpec$k);
    }
    /**
     * The operation to create or update the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be created or updated.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Create Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmName, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, runCommandName, runCommand, options }, createOrUpdateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be created or updated.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Create Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmName, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmName, runCommandName, runCommand, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be updated.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Update Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmName, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, runCommandName, runCommand, options }, updateOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be updated.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Update Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmName, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmName, runCommandName, runCommand, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be deleted.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmName, runCommandName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmName, runCommandName, options }, deleteOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine where the run command should be deleted.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmName, runCommandName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmName, runCommandName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the run command.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    getByVirtualMachine(resourceGroupName, vmName, runCommandName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, runCommandName, options }, getByVirtualMachineOperationSpec);
    }
    /**
     * The operation to get all run commands of a Virtual Machine.
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the run command.
     * @param options The options parameters.
     */
    _listByVirtualMachine(resourceGroupName, vmName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, options }, listByVirtualMachineOperationSpec);
    }
    /**
     * ListNext
     * @param location The location upon which run commands is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$f);
    }
    /**
     * ListByVirtualMachineNext
     * @param resourceGroupName The name of the resource group.
     * @param vmName The name of the virtual machine containing the run command.
     * @param nextLink The nextLink from the previous successful call to the ListByVirtualMachine method.
     * @param options The options parameters.
     */
    _listByVirtualMachineNext(resourceGroupName, vmName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmName, nextLink, options }, listByVirtualMachineNextOperationSpec);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/runCommands",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunCommandListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/runCommands/{commandId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunCommandDocument
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId,
        commandId
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommands/{runCommandName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        201: {
            bodyMapper: VirtualMachineRunCommand
        },
        202: {
            bodyMapper: VirtualMachineRunCommand
        },
        204: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: runCommand,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName,
        runCommandName
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$o
};
const updateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommands/{runCommandName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        201: {
            bodyMapper: VirtualMachineRunCommand
        },
        202: {
            bodyMapper: VirtualMachineRunCommand
        },
        204: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: runCommand1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName,
        runCommandName
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$o
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommands/{runCommandName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName,
        runCommandName
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const getByVirtualMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommands/{runCommandName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName,
        runCommandName
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const listByVirtualMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}/runCommands",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommandsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunCommandListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        location,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};
const listByVirtualMachineNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommandsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        vmName
    ],
    headerParameters: [accept1],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineScaleSetVMRunCommands operations. */
class VirtualMachineScaleSetVMRunCommandsImpl {
    /**
     * Initialize a new instance of the class VirtualMachineScaleSetVMRunCommands class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to get all run commands of an instance in Virtual Machine Scaleset.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    list(resourceGroupName, vmScaleSetName, instanceId, options) {
        const iter = this.listPagingAll(resourceGroupName, vmScaleSetName, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, vmScaleSetName, instanceId, options);
            }
        };
    }
    listPagingPage(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, vmScaleSetName, instanceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vmScaleSetName, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, vmScaleSetName, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vmScaleSetName, instanceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The operation to create or update the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Create Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                runCommandName,
                runCommand,
                options
            }, createOrUpdateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to create or update the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Create Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to update the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Update Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                runCommandName,
                runCommand,
                options
            }, updateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to update the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param runCommand Parameters supplied to the Update Virtual Machine RunCommand operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmScaleSetName, instanceId, runCommandName, runCommand, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmScaleSetName, instanceId, runCommandName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                vmScaleSetName,
                instanceId,
                runCommandName,
                options
            }, deleteOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The operation to delete the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmScaleSetName, instanceId, runCommandName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmScaleSetName, instanceId, runCommandName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the VMSS VM run command.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param runCommandName The name of the virtual machine run command.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmScaleSetName, instanceId, runCommandName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vmScaleSetName,
            instanceId,
            runCommandName,
            options
        }, getOperationSpec$j);
    }
    /**
     * The operation to get all run commands of an instance in Virtual Machine Scaleset.
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vmScaleSetName, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, options }, listOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param vmScaleSetName The name of the VM scale set.
     * @param instanceId The instance ID of the virtual machine.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vmScaleSetName, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmScaleSetName, instanceId, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/runCommands/{runCommandName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        201: {
            bodyMapper: VirtualMachineRunCommand
        },
        202: {
            bodyMapper: VirtualMachineRunCommand
        },
        204: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: runCommand,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        runCommandName
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$n
};
const updateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/runCommands/{runCommandName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        201: {
            bodyMapper: VirtualMachineRunCommand
        },
        202: {
            bodyMapper: VirtualMachineRunCommand
        },
        204: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: runCommand1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        runCommandName
    ],
    headerParameters: [contentType, accept1],
    mediaType: "json",
    serializer: serializer$n
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/runCommands/{runCommandName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        runCommandName
    ],
    headerParameters: [accept1],
    serializer: serializer$n
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/runCommands/{runCommandName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId,
        runCommandName
    ],
    headerParameters: [accept1],
    serializer: serializer$n
};
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}/virtualMachines/{instanceId}/runCommands",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommandsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept1],
    serializer: serializer$n
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineRunCommandsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        vmScaleSetName,
        instanceId
    ],
    headerParameters: [accept1],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Disks operations. */
class DisksImpl {
    /**
     * Initialize a new instance of the class Disks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the disks under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the disks under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param disk Disk object supplied in the body of the Put disk operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, diskName, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskName, disk, options }, createOrUpdateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param disk Disk object supplied in the body of the Put disk operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, diskName, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, diskName, disk, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates (patches) a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param disk Disk object supplied in the body of the Patch disk operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, diskName, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskName, disk, options }, updateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates (patches) a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param disk Disk object supplied in the body of the Patch disk operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, diskName, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, diskName, disk, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param options The options parameters.
     */
    get(resourceGroupName, diskName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskName, options }, getOperationSpec$i);
    }
    /**
     * Deletes a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, diskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskName, options }, deleteOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, diskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, diskName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the disks under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * Lists all the disks under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * Grants access to a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param grantAccessData Access data object supplied in the body of the get disk access operation.
     * @param options The options parameters.
     */
    beginGrantAccess(resourceGroupName, diskName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskName, grantAccessData, options }, grantAccessOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Grants access to a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param grantAccessData Access data object supplied in the body of the get disk access operation.
     * @param options The options parameters.
     */
    beginGrantAccessAndWait(resourceGroupName, diskName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGrantAccess(resourceGroupName, diskName, grantAccessData, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revokes access to a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param options The options parameters.
     */
    beginRevokeAccess(resourceGroupName, diskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskName, options }, revokeAccessOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Revokes access to a disk.
     * @param resourceGroupName The name of the resource group.
     * @param diskName The name of the managed disk that is being created. The name can't be changed after
     *                 the disk is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The maximum name
     *                 length is 80 characters.
     * @param options The options parameters.
     */
    beginRevokeAccessAndWait(resourceGroupName, diskName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevokeAccess(resourceGroupName, diskName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Disk
        },
        201: {
            bodyMapper: Disk
        },
        202: {
            bodyMapper: Disk
        },
        204: {
            bodyMapper: Disk
        }
    },
    requestBody: disk,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Disk
        },
        201: {
            bodyMapper: Disk
        },
        202: {
            bodyMapper: Disk
        },
        204: {
            bodyMapper: Disk
        }
    },
    requestBody: disk1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Disk
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    serializer: serializer$m
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/disks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$m
};
const grantAccessOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}/beginGetAccess",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AccessUri
        },
        201: {
            bodyMapper: AccessUri
        },
        202: {
            bodyMapper: AccessUri
        },
        204: {
            bodyMapper: AccessUri
        }
    },
    requestBody: grantAccessData,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const revokeAccessOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/disks/{diskName}/endGetAccess",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskName
    ],
    serializer: serializer$m
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DiskAccesses operations. */
class DiskAccessesImpl {
    /**
     * Initialize a new instance of the class DiskAccesses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the disk access resources under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the disk access resources under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List information about private endpoint connections under a disk access resource
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    listPrivateEndpointConnections(resourceGroupName, diskAccessName, options) {
        const iter = this.listPrivateEndpointConnectionsPagingAll(resourceGroupName, diskAccessName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, diskAccessName, options);
            }
        };
    }
    listPrivateEndpointConnectionsPagingPage(resourceGroupName, diskAccessName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingPage_1() {
            let result = yield tslib.__await(this._listPrivateEndpointConnections(resourceGroupName, diskAccessName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listPrivateEndpointConnectionsNext(resourceGroupName, diskAccessName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPrivateEndpointConnectionsPagingAll(resourceGroupName, diskAccessName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, diskAccessName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Creates or updates a disk access resource
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param diskAccess disk access object supplied in the body of the Put disk access operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, diskAccessName, diskAccess, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskAccessName, diskAccess, options }, createOrUpdateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a disk access resource
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param diskAccess disk access object supplied in the body of the Put disk access operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, diskAccessName, diskAccess, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, diskAccessName, diskAccess, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates (patches) a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param diskAccess disk access object supplied in the body of the Patch disk access operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, diskAccessName, diskAccess, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskAccessName, diskAccess, options }, updateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates (patches) a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param diskAccess disk access object supplied in the body of the Patch disk access operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, diskAccessName, diskAccess, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, diskAccessName, diskAccess, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    get(resourceGroupName, diskAccessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskAccessName, options }, getOperationSpec$h);
    }
    /**
     * Deletes a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, diskAccessName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskAccessName, options }, deleteOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, diskAccessName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, diskAccessName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the disk access resources under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Lists all the disk access resources under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Gets the private link resources possible under disk access resource
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, diskAccessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskAccessName, options }, getPrivateLinkResourcesOperationSpec);
    }
    /**
     * Approve or reject a private endpoint connection under disk access resource, this can't be used to
     * create a new private endpoint connection.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param privateEndpointConnection private endpoint connection object supplied in the body of the Put
     *                                  private endpoint connection operation.
     * @param options The options parameters.
     */
    beginUpdateAPrivateEndpointConnection(resourceGroupName, diskAccessName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                diskAccessName,
                privateEndpointConnectionName,
                privateEndpointConnection,
                options
            }, updateAPrivateEndpointConnectionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Approve or reject a private endpoint connection under disk access resource, this can't be used to
     * create a new private endpoint connection.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param privateEndpointConnection private endpoint connection object supplied in the body of the Put
     *                                  private endpoint connection operation.
     * @param options The options parameters.
     */
    beginUpdateAPrivateEndpointConnectionAndWait(resourceGroupName, diskAccessName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateAPrivateEndpointConnection(resourceGroupName, diskAccessName, privateEndpointConnectionName, privateEndpointConnection, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about a private endpoint connection under a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    getAPrivateEndpointConnection(resourceGroupName, diskAccessName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            diskAccessName,
            privateEndpointConnectionName,
            options
        }, getAPrivateEndpointConnectionOperationSpec);
    }
    /**
     * Deletes a private endpoint connection under a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAPrivateEndpointConnection(resourceGroupName, diskAccessName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                diskAccessName,
                privateEndpointConnectionName,
                options
            }, deleteAPrivateEndpointConnectionOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a private endpoint connection under a disk access resource.
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAPrivateEndpointConnectionAndWait(resourceGroupName, diskAccessName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAPrivateEndpointConnection(resourceGroupName, diskAccessName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List information about private endpoint connections under a disk access resource
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnections(resourceGroupName, diskAccessName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskAccessName, options }, listPrivateEndpointConnectionsOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
    /**
     * ListPrivateEndpointConnectionsNext
     * @param resourceGroupName The name of the resource group.
     * @param diskAccessName The name of the disk access resource that is being created. The name can't be
     *                       changed after the disk encryption set is created. Supported characters for the name are a-z, A-Z,
     *                       0-9, _ and -. The maximum name length is 80 characters.
     * @param nextLink The nextLink from the previous successful call to the ListPrivateEndpointConnections
     *                 method.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnectionsNext(resourceGroupName, diskAccessName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskAccessName, nextLink, options }, listPrivateEndpointConnectionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiskAccess
        },
        201: {
            bodyMapper: DiskAccess
        },
        202: {
            bodyMapper: DiskAccess
        },
        204: {
            bodyMapper: DiskAccess
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: diskAccess,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DiskAccess
        },
        201: {
            bodyMapper: DiskAccess
        },
        202: {
            bodyMapper: DiskAccess
        },
        204: {
            bodyMapper: DiskAccess
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: diskAccess1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskAccess
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskAccessList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/diskAccesses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskAccessList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$l
};
const getPrivateLinkResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const updateAPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: privateEndpointConnection,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const getAPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const deleteAPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listPrivateEndpointConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskAccesses/{diskAccessName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskAccessList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskAccessList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listPrivateEndpointConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        diskAccessName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DiskEncryptionSets operations. */
class DiskEncryptionSetsImpl {
    /**
     * Initialize a new instance of the class DiskEncryptionSets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the disk encryption sets under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the disk encryption sets under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all resources that are encrypted with this disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    listAssociatedResources(resourceGroupName, diskEncryptionSetName, options) {
        const iter = this.listAssociatedResourcesPagingAll(resourceGroupName, diskEncryptionSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAssociatedResourcesPagingPage(resourceGroupName, diskEncryptionSetName, options);
            }
        };
    }
    listAssociatedResourcesPagingPage(resourceGroupName, diskEncryptionSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAssociatedResourcesPagingPage_1() {
            let result = yield tslib.__await(this._listAssociatedResources(resourceGroupName, diskEncryptionSetName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAssociatedResourcesNext(resourceGroupName, diskEncryptionSetName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAssociatedResourcesPagingAll(resourceGroupName, diskEncryptionSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAssociatedResourcesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAssociatedResourcesPagingPage(resourceGroupName, diskEncryptionSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Creates or updates a disk encryption set
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param diskEncryptionSet disk encryption set object supplied in the body of the Put disk encryption
     *                          set operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options }, createOrUpdateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a disk encryption set
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param diskEncryptionSet disk encryption set object supplied in the body of the Put disk encryption
     *                          set operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates (patches) a disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param diskEncryptionSet disk encryption set object supplied in the body of the Patch disk
     *                          encryption set operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options }, updateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates (patches) a disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param diskEncryptionSet disk encryption set object supplied in the body of the Patch disk
     *                          encryption set operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, diskEncryptionSetName, diskEncryptionSet, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about a disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    get(resourceGroupName, diskEncryptionSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskEncryptionSetName, options }, getOperationSpec$g);
    }
    /**
     * Deletes a disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, diskEncryptionSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, diskEncryptionSetName, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, diskEncryptionSetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, diskEncryptionSetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the disk encryption sets under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Lists all the disk encryption sets under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$b);
    }
    /**
     * Lists all resources that are encrypted with this disk encryption set.
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param options The options parameters.
     */
    _listAssociatedResources(resourceGroupName, diskEncryptionSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskEncryptionSetName, options }, listAssociatedResourcesOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$b);
    }
    /**
     * ListAssociatedResourcesNext
     * @param resourceGroupName The name of the resource group.
     * @param diskEncryptionSetName The name of the disk encryption set that is being created. The name
     *                              can't be changed after the disk encryption set is created. Supported characters for the name are
     *                              a-z, A-Z, 0-9, _ and -. The maximum name length is 80 characters.
     * @param nextLink The nextLink from the previous successful call to the ListAssociatedResources
     *                 method.
     * @param options The options parameters.
     */
    _listAssociatedResourcesNext(resourceGroupName, diskEncryptionSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, diskEncryptionSetName, nextLink, options }, listAssociatedResourcesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSet
        },
        201: {
            bodyMapper: DiskEncryptionSet
        },
        202: {
            bodyMapper: DiskEncryptionSet
        },
        204: {
            bodyMapper: DiskEncryptionSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: diskEncryptionSet,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSet
        },
        201: {
            bodyMapper: DiskEncryptionSet
        },
        202: {
            bodyMapper: DiskEncryptionSet
        },
        204: {
            bodyMapper: DiskEncryptionSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: diskEncryptionSet1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSetList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/diskEncryptionSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSetList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$k
};
const listAssociatedResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}/associatedResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUriList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSetList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskEncryptionSetList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listAssociatedResourcesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUriList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        diskEncryptionSetName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DiskRestorePointOperations operations. */
class DiskRestorePointOperationsImpl {
    /**
     * Initialize a new instance of the class DiskRestorePointOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists diskRestorePoints under a vmRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param options The options parameters.
     */
    listByRestorePoint(resourceGroupName, restorePointCollectionName, vmRestorePointName, options) {
        const iter = this.listByRestorePointPagingAll(resourceGroupName, restorePointCollectionName, vmRestorePointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByRestorePointPagingPage(resourceGroupName, restorePointCollectionName, vmRestorePointName, options);
            }
        };
    }
    listByRestorePointPagingPage(resourceGroupName, restorePointCollectionName, vmRestorePointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRestorePointPagingPage_1() {
            let result = yield tslib.__await(this._listByRestorePoint(resourceGroupName, restorePointCollectionName, vmRestorePointName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByRestorePointNext(resourceGroupName, restorePointCollectionName, vmRestorePointName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByRestorePointPagingAll(resourceGroupName, restorePointCollectionName, vmRestorePointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRestorePointPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRestorePointPagingPage(resourceGroupName, restorePointCollectionName, vmRestorePointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get disk restorePoint resource
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param diskRestorePointName The name of the disk restore point created.
     * @param options The options parameters.
     */
    get(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            restorePointCollectionName,
            vmRestorePointName,
            diskRestorePointName,
            options
        }, getOperationSpec$f);
    }
    /**
     * Lists diskRestorePoints under a vmRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param options The options parameters.
     */
    _listByRestorePoint(resourceGroupName, restorePointCollectionName, vmRestorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            restorePointCollectionName,
            vmRestorePointName,
            options
        }, listByRestorePointOperationSpec);
    }
    /**
     * Grants access to a diskRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param diskRestorePointName The name of the disk restore point created.
     * @param grantAccessData Access data object supplied in the body of the get disk access operation.
     * @param options The options parameters.
     */
    beginGrantAccess(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                restorePointCollectionName,
                vmRestorePointName,
                diskRestorePointName,
                grantAccessData,
                options
            }, grantAccessOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Grants access to a diskRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param diskRestorePointName The name of the disk restore point created.
     * @param grantAccessData Access data object supplied in the body of the get disk access operation.
     * @param options The options parameters.
     */
    beginGrantAccessAndWait(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGrantAccess(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, grantAccessData, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revokes access to a diskRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param diskRestorePointName The name of the disk restore point created.
     * @param options The options parameters.
     */
    beginRevokeAccess(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                restorePointCollectionName,
                vmRestorePointName,
                diskRestorePointName,
                options
            }, revokeAccessOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Revokes access to a diskRestorePoint.
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param diskRestorePointName The name of the disk restore point created.
     * @param options The options parameters.
     */
    beginRevokeAccessAndWait(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevokeAccess(resourceGroupName, restorePointCollectionName, vmRestorePointName, diskRestorePointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByRestorePointNext
     * @param resourceGroupName The name of the resource group.
     * @param restorePointCollectionName The name of the restore point collection that the disk restore
     *                                   point belongs.
     * @param vmRestorePointName The name of the vm restore point that the disk disk restore point belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByRestorePoint method.
     * @param options The options parameters.
     */
    _listByRestorePointNext(resourceGroupName, restorePointCollectionName, vmRestorePointName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            restorePointCollectionName,
            vmRestorePointName,
            nextLink,
            options
        }, listByRestorePointNextOperationSpec);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{vmRestorePointName}/diskRestorePoints/{diskRestorePointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskRestorePoint
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        vmRestorePointName,
        diskRestorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByRestorePointOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{vmRestorePointName}/diskRestorePoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskRestorePointList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        vmRestorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const grantAccessOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{vmRestorePointName}/diskRestorePoints/{diskRestorePointName}/beginGetAccess",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AccessUri
        },
        201: {
            bodyMapper: AccessUri
        },
        202: {
            bodyMapper: AccessUri
        },
        204: {
            bodyMapper: AccessUri
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: grantAccessData,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        vmRestorePointName,
        diskRestorePointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const revokeAccessOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/restorePointCollections/{restorePointCollectionName}/restorePoints/{vmRestorePointName}/diskRestorePoints/{diskRestorePointName}/endGetAccess",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        restorePointCollectionName,
        vmRestorePointName,
        diskRestorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByRestorePointNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskRestorePointList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        restorePointCollectionName,
        vmRestorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Snapshots operations. */
class SnapshotsImpl {
    /**
     * Initialize a new instance of the class Snapshots class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists snapshots under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists snapshots under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param snapshot Snapshot object supplied in the body of the Put disk operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, snapshotName, snapshot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, snapshotName, snapshot, options }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param snapshot Snapshot object supplied in the body of the Put disk operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, snapshotName, snapshot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, snapshotName, snapshot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates (patches) a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param snapshot Snapshot object supplied in the body of the Patch snapshot operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, snapshotName, snapshot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, snapshotName, snapshot, options }, updateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates (patches) a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param snapshot Snapshot object supplied in the body of the Patch snapshot operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, snapshotName, snapshot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, snapshotName, snapshot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param options The options parameters.
     */
    get(resourceGroupName, snapshotName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, snapshotName, options }, getOperationSpec$e);
    }
    /**
     * Deletes a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, snapshotName, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, snapshotName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists snapshots under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Lists snapshots under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$a);
    }
    /**
     * Grants access to a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param grantAccessData Access data object supplied in the body of the get snapshot access operation.
     * @param options The options parameters.
     */
    beginGrantAccess(resourceGroupName, snapshotName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, snapshotName, grantAccessData, options }, grantAccessOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Grants access to a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param grantAccessData Access data object supplied in the body of the get snapshot access operation.
     * @param options The options parameters.
     */
    beginGrantAccessAndWait(resourceGroupName, snapshotName, grantAccessData, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGrantAccess(resourceGroupName, snapshotName, grantAccessData, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revokes access to a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param options The options parameters.
     */
    beginRevokeAccess(resourceGroupName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, snapshotName, options }, revokeAccessOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Revokes access to a snapshot.
     * @param resourceGroupName The name of the resource group.
     * @param snapshotName The name of the snapshot that is being created. The name can't be changed after
     *                     the snapshot is created. Supported characters for the name are a-z, A-Z, 0-9, _ and -. The max name
     *                     length is 80 characters.
     * @param options The options parameters.
     */
    beginRevokeAccessAndWait(resourceGroupName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevokeAccess(resourceGroupName, snapshotName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Snapshot
        },
        201: {
            bodyMapper: Snapshot
        },
        202: {
            bodyMapper: Snapshot
        },
        204: {
            bodyMapper: Snapshot
        }
    },
    requestBody: snapshot,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Snapshot
        },
        201: {
            bodyMapper: Snapshot
        },
        202: {
            bodyMapper: Snapshot
        },
        204: {
            bodyMapper: Snapshot
        }
    },
    requestBody: snapshot1,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Snapshot
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    serializer: serializer$i
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};
const grantAccessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}/beginGetAccess",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AccessUri
        },
        201: {
            bodyMapper: AccessUri
        },
        202: {
            bodyMapper: AccessUri
        },
        204: {
            bodyMapper: AccessUri
        }
    },
    requestBody: grantAccessData,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const revokeAccessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/snapshots/{snapshotName}/endGetAccess",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        snapshotName
    ],
    serializer: serializer$i
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotList
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceSkus operations. */
class ResourceSkusImpl {
    /**
     * Initialize a new instance of the class ResourceSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of Microsoft.Compute SKUs available for your Subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of Microsoft.Compute SKUs available for your Subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkusResult
        }
    },
    queryParameters: [
        filter,
        apiVersion2,
        includeExtendedLocations
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkusResult
        }
    },
    queryParameters: [
        filter,
        apiVersion2,
        includeExtendedLocations
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Galleries operations. */
class GalleriesImpl {
    /**
     * Initialize a new instance of the class Galleries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List galleries under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List galleries under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Create or update a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery. The allowed characters are alphabets and
     *                    numbers with dots and periods allowed in the middle. The maximum length is 80 characters.
     * @param gallery Parameters supplied to the create or update Shared Image Gallery operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, galleryName, gallery, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, gallery, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery. The allowed characters are alphabets and
     *                    numbers with dots and periods allowed in the middle. The maximum length is 80 characters.
     * @param gallery Parameters supplied to the create or update Shared Image Gallery operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, galleryName, gallery, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, galleryName, gallery, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery. The allowed characters are alphabets and
     *                    numbers with dots and periods allowed in the middle. The maximum length is 80 characters.
     * @param gallery Parameters supplied to the update Shared Image Gallery operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, gallery, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, gallery, options }, updateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery. The allowed characters are alphabets and
     *                    numbers with dots and periods allowed in the middle. The maximum length is 80 characters.
     * @param gallery Parameters supplied to the update Shared Image Gallery operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, gallery, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, gallery, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery.
     * @param options The options parameters.
     */
    get(resourceGroupName, galleryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, options }, getOperationSpec$d);
    }
    /**
     * Delete a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, galleryName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Shared Image Gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, galleryName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, galleryName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List galleries under a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * List galleries under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Gallery
        },
        201: {
            bodyMapper: Gallery
        },
        202: {
            bodyMapper: Gallery
        },
        204: {
            bodyMapper: Gallery
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: gallery,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Gallery
        },
        201: {
            bodyMapper: Gallery
        },
        202: {
            bodyMapper: Gallery
        },
        204: {
            bodyMapper: Gallery
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: gallery1,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Gallery
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion3,
        select1,
        expand8
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/galleries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GalleryImages operations. */
class GalleryImagesImpl {
    /**
     * Initialize a new instance of the class GalleryImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List gallery image definitions in a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery from which Image Definitions are to be
     *                    listed.
     * @param options The options parameters.
     */
    listByGallery(resourceGroupName, galleryName, options) {
        const iter = this.listByGalleryPagingAll(resourceGroupName, galleryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByGalleryPagingPage(resourceGroupName, galleryName, options);
            }
        };
    }
    listByGalleryPagingPage(resourceGroupName, galleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryPagingPage_1() {
            let result = yield tslib.__await(this._listByGallery(resourceGroupName, galleryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByGalleryNext(resourceGroupName, galleryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByGalleryPagingAll(resourceGroupName, galleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByGalleryPagingPage(resourceGroupName, galleryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    created.
     * @param galleryImageName The name of the gallery image definition to be created or updated. The
     *                         allowed characters are alphabets and numbers with dots, dashes, and periods allowed in the middle.
     *                         The maximum length is 80 characters.
     * @param galleryImage Parameters supplied to the create or update gallery image operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, galleryName, galleryImageName, galleryImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryImageName,
                galleryImage,
                options
            }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    created.
     * @param galleryImageName The name of the gallery image definition to be created or updated. The
     *                         allowed characters are alphabets and numbers with dots, dashes, and periods allowed in the middle.
     *                         The maximum length is 80 characters.
     * @param galleryImage Parameters supplied to the create or update gallery image operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, galleryName, galleryImageName, galleryImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, galleryName, galleryImageName, galleryImage, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    updated.
     * @param galleryImageName The name of the gallery image definition to be updated. The allowed
     *                         characters are alphabets and numbers with dots, dashes, and periods allowed in the middle. The
     *                         maximum length is 80 characters.
     * @param galleryImage Parameters supplied to the update gallery image operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, galleryImageName, galleryImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryImageName,
                galleryImage,
                options
            }, updateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    updated.
     * @param galleryImageName The name of the gallery image definition to be updated. The allowed
     *                         characters are alphabets and numbers with dots, dashes, and periods allowed in the middle. The
     *                         maximum length is 80 characters.
     * @param galleryImage Parameters supplied to the update gallery image operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, galleryImageName, galleryImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, galleryImageName, galleryImage, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery from which the Image Definitions are to be
     *                    retrieved.
     * @param galleryImageName The name of the gallery image definition to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, galleryName, galleryImageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, galleryImageName, options }, getOperationSpec$c);
    }
    /**
     * Delete a gallery image.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    deleted.
     * @param galleryImageName The name of the gallery image definition to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, galleryName, galleryImageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, galleryImageName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a gallery image.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition is to be
     *                    deleted.
     * @param galleryImageName The name of the gallery image definition to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, galleryName, galleryImageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, galleryName, galleryImageName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List gallery image definitions in a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery from which Image Definitions are to be
     *                    listed.
     * @param options The options parameters.
     */
    _listByGallery(resourceGroupName, galleryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, options }, listByGalleryOperationSpec$1);
    }
    /**
     * ListByGalleryNext
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery from which Image Definitions are to be
     *                    listed.
     * @param nextLink The nextLink from the previous successful call to the ListByGallery method.
     * @param options The options parameters.
     */
    _listByGalleryNext(resourceGroupName, galleryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, nextLink, options }, listByGalleryNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GalleryImage
        },
        201: {
            bodyMapper: GalleryImage
        },
        202: {
            bodyMapper: GalleryImage
        },
        204: {
            bodyMapper: GalleryImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryImage,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GalleryImage
        },
        201: {
            bodyMapper: GalleryImage
        },
        202: {
            bodyMapper: GalleryImage
        },
        204: {
            bodyMapper: GalleryImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryImage1,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByGalleryOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByGalleryNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GalleryImageVersions operations. */
class GalleryImageVersionsImpl {
    /**
     * Initialize a new instance of the class GalleryImageVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List gallery image versions in a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the Shared Image Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param options The options parameters.
     */
    listByGalleryImage(resourceGroupName, galleryName, galleryImageName, options) {
        const iter = this.listByGalleryImagePagingAll(resourceGroupName, galleryName, galleryImageName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByGalleryImagePagingPage(resourceGroupName, galleryName, galleryImageName, options);
            }
        };
    }
    listByGalleryImagePagingPage(resourceGroupName, galleryName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryImagePagingPage_1() {
            let result = yield tslib.__await(this._listByGalleryImage(resourceGroupName, galleryName, galleryImageName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByGalleryImageNext(resourceGroupName, galleryName, galleryImageName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByGalleryImagePagingAll(resourceGroupName, galleryName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryImagePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByGalleryImagePagingPage(resourceGroupName, galleryName, galleryImageName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version is to be
     *                         created.
     * @param galleryImageVersionName The name of the gallery image version to be created. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryImageVersion Parameters supplied to the create or update gallery image version
     *                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryImageName,
                galleryImageVersionName,
                galleryImageVersion,
                options
            }, createOrUpdateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version is to be
     *                         created.
     * @param galleryImageVersionName The name of the gallery image version to be created. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryImageVersion Parameters supplied to the create or update gallery image version
     *                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version is to be
     *                         updated.
     * @param galleryImageVersionName The name of the gallery image version to be updated. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryImageVersion Parameters supplied to the update gallery image version operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryImageName,
                galleryImageVersionName,
                galleryImageVersion,
                options
            }, updateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version is to be
     *                         updated.
     * @param galleryImageVersionName The name of the gallery image version to be updated. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryImageVersion Parameters supplied to the update gallery image version operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, galleryImageVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version resides.
     * @param galleryImageVersionName The name of the gallery image version to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            galleryName,
            galleryImageName,
            galleryImageVersionName,
            options
        }, getOperationSpec$b);
    }
    /**
     * Delete a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version resides.
     * @param galleryImageVersionName The name of the gallery image version to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryImageName,
                galleryImageVersionName,
                options
            }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a gallery image version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the gallery image definition in which the Image Version resides.
     * @param galleryImageVersionName The name of the gallery image version to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, galleryName, galleryImageName, galleryImageVersionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List gallery image versions in a gallery image definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the Shared Image Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param options The options parameters.
     */
    _listByGalleryImage(resourceGroupName, galleryName, galleryImageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, galleryImageName, options }, listByGalleryImageOperationSpec);
    }
    /**
     * ListByGalleryImageNext
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery in which the Image Definition resides.
     * @param galleryImageName The name of the Shared Image Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param nextLink The nextLink from the previous successful call to the ListByGalleryImage method.
     * @param options The options parameters.
     */
    _listByGalleryImageNext(resourceGroupName, galleryName, galleryImageName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, galleryImageName, nextLink, options }, listByGalleryImageNextOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GalleryImageVersion
        },
        201: {
            bodyMapper: GalleryImageVersion
        },
        202: {
            bodyMapper: GalleryImageVersion
        },
        204: {
            bodyMapper: GalleryImageVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryImageVersion,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName,
        galleryImageVersionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GalleryImageVersion
        },
        201: {
            bodyMapper: GalleryImageVersion
        },
        202: {
            bodyMapper: GalleryImageVersion
        },
        204: {
            bodyMapper: GalleryImageVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryImageVersion1,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName,
        galleryImageVersionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, expand9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName,
        galleryImageVersionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName,
        galleryImageVersionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByGalleryImageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{galleryImageName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByGalleryImageNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        galleryName,
        galleryImageName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GalleryApplications operations. */
class GalleryApplicationsImpl {
    /**
     * Initialize a new instance of the class GalleryApplications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List gallery Application Definitions in a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery from which Application Definitions are
     *                    to be listed.
     * @param options The options parameters.
     */
    listByGallery(resourceGroupName, galleryName, options) {
        const iter = this.listByGalleryPagingAll(resourceGroupName, galleryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByGalleryPagingPage(resourceGroupName, galleryName, options);
            }
        };
    }
    listByGalleryPagingPage(resourceGroupName, galleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryPagingPage_1() {
            let result = yield tslib.__await(this._listByGallery(resourceGroupName, galleryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByGalleryNext(resourceGroupName, galleryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByGalleryPagingAll(resourceGroupName, galleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByGalleryPagingPage(resourceGroupName, galleryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be created.
     * @param galleryApplicationName The name of the gallery Application Definition to be created or
     *                               updated. The allowed characters are alphabets and numbers with dots, dashes, and periods allowed in
     *                               the middle. The maximum length is 80 characters.
     * @param galleryApplication Parameters supplied to the create or update gallery Application operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryApplicationName,
                galleryApplication,
                options
            }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be created.
     * @param galleryApplicationName The name of the gallery Application Definition to be created or
     *                               updated. The allowed characters are alphabets and numbers with dots, dashes, and periods allowed in
     *                               the middle. The maximum length is 80 characters.
     * @param galleryApplication Parameters supplied to the create or update gallery Application operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be updated.
     * @param galleryApplicationName The name of the gallery Application Definition to be updated. The
     *                               allowed characters are alphabets and numbers with dots, dashes, and periods allowed in the middle.
     *                               The maximum length is 80 characters.
     * @param galleryApplication Parameters supplied to the update gallery Application operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryApplicationName,
                galleryApplication,
                options
            }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be updated.
     * @param galleryApplicationName The name of the gallery Application Definition to be updated. The
     *                               allowed characters are alphabets and numbers with dots, dashes, and periods allowed in the middle.
     *                               The maximum length is 80 characters.
     * @param galleryApplication Parameters supplied to the update gallery Application operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplication, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery from which the Application Definitions
     *                    are to be retrieved.
     * @param galleryApplicationName The name of the gallery Application Definition to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, galleryName, galleryApplicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, galleryApplicationName, options }, getOperationSpec$a);
    }
    /**
     * Delete a gallery Application.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be deleted.
     * @param galleryApplicationName The name of the gallery Application Definition to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, galleryName, galleryApplicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, galleryApplicationName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a gallery Application.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition is
     *                    to be deleted.
     * @param galleryApplicationName The name of the gallery Application Definition to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, galleryName, galleryApplicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, galleryName, galleryApplicationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List gallery Application Definitions in a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery from which Application Definitions are
     *                    to be listed.
     * @param options The options parameters.
     */
    _listByGallery(resourceGroupName, galleryName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, options }, listByGalleryOperationSpec);
    }
    /**
     * ListByGalleryNext
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery from which Application Definitions are
     *                    to be listed.
     * @param nextLink The nextLink from the previous successful call to the ListByGallery method.
     * @param options The options parameters.
     */
    _listByGalleryNext(resourceGroupName, galleryName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, nextLink, options }, listByGalleryNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GalleryApplication
        },
        201: {
            bodyMapper: GalleryApplication
        },
        202: {
            bodyMapper: GalleryApplication
        },
        204: {
            bodyMapper: GalleryApplication
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryApplication,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GalleryApplication
        },
        201: {
            bodyMapper: GalleryApplication
        },
        202: {
            bodyMapper: GalleryApplication
        },
        204: {
            bodyMapper: GalleryApplication
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryApplication1,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplication
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByGalleryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplicationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByGalleryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplicationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GalleryApplicationVersions operations. */
class GalleryApplicationVersionsImpl {
    /**
     * Initialize a new instance of the class GalleryApplicationVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List gallery Application Versions in a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the Shared Application Gallery Application Definition from
     *                               which the Application Versions are to be listed.
     * @param options The options parameters.
     */
    listByGalleryApplication(resourceGroupName, galleryName, galleryApplicationName, options) {
        const iter = this.listByGalleryApplicationPagingAll(resourceGroupName, galleryName, galleryApplicationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByGalleryApplicationPagingPage(resourceGroupName, galleryName, galleryApplicationName, options);
            }
        };
    }
    listByGalleryApplicationPagingPage(resourceGroupName, galleryName, galleryApplicationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryApplicationPagingPage_1() {
            let result = yield tslib.__await(this._listByGalleryApplication(resourceGroupName, galleryName, galleryApplicationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByGalleryApplicationNext(resourceGroupName, galleryName, galleryApplicationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByGalleryApplicationPagingAll(resourceGroupName, galleryName, galleryApplicationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGalleryApplicationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByGalleryApplicationPagingPage(resourceGroupName, galleryName, galleryApplicationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version is to be created.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be created.
     *                                      Needs to follow semantic version name pattern: The allowed characters are digit and period. Digits
     *                                      must be within the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryApplicationVersion Parameters supplied to the create or update gallery Application
     *                                  Version operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryApplicationName,
                galleryApplicationVersionName,
                galleryApplicationVersion,
                options
            }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version is to be created.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be created.
     *                                      Needs to follow semantic version name pattern: The allowed characters are digit and period. Digits
     *                                      must be within the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryApplicationVersion Parameters supplied to the create or update gallery Application
     *                                  Version operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version is to be updated.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be updated.
     *                                      Needs to follow semantic version name pattern: The allowed characters are digit and period. Digits
     *                                      must be within the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryApplicationVersion Parameters supplied to the update gallery Application Version
     *                                  operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryApplicationName,
                galleryApplicationVersionName,
                galleryApplicationVersion,
                options
            }, updateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version is to be updated.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be updated.
     *                                      Needs to follow semantic version name pattern: The allowed characters are digit and period. Digits
     *                                      must be within the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param galleryApplicationVersion Parameters supplied to the update gallery Application Version
     *                                  operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, galleryApplicationVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves information about a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version resides.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            galleryName,
            galleryApplicationName,
            galleryApplicationVersionName,
            options
        }, getOperationSpec$9);
    }
    /**
     * Delete a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version resides.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                galleryName,
                galleryApplicationName,
                galleryApplicationVersionName,
                options
            }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a gallery Application Version.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the gallery Application Definition in which the
     *                               Application Version resides.
     * @param galleryApplicationVersionName The name of the gallery Application Version to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, galleryName, galleryApplicationName, galleryApplicationVersionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List gallery Application Versions in a gallery Application Definition.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the Shared Application Gallery Application Definition from
     *                               which the Application Versions are to be listed.
     * @param options The options parameters.
     */
    _listByGalleryApplication(resourceGroupName, galleryName, galleryApplicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, galleryName, galleryApplicationName, options }, listByGalleryApplicationOperationSpec);
    }
    /**
     * ListByGalleryApplicationNext
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Application Gallery in which the Application Definition
     *                    resides.
     * @param galleryApplicationName The name of the Shared Application Gallery Application Definition from
     *                               which the Application Versions are to be listed.
     * @param nextLink The nextLink from the previous successful call to the ListByGalleryApplication
     *                 method.
     * @param options The options parameters.
     */
    _listByGalleryApplicationNext(resourceGroupName, galleryName, galleryApplicationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            galleryName,
            galleryApplicationName,
            nextLink,
            options
        }, listByGalleryApplicationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}/versions/{galleryApplicationVersionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GalleryApplicationVersion
        },
        201: {
            bodyMapper: GalleryApplicationVersion
        },
        202: {
            bodyMapper: GalleryApplicationVersion
        },
        204: {
            bodyMapper: GalleryApplicationVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryApplicationVersion,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName,
        galleryApplicationVersionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}/versions/{galleryApplicationVersionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GalleryApplicationVersion
        },
        201: {
            bodyMapper: GalleryApplicationVersion
        },
        202: {
            bodyMapper: GalleryApplicationVersion
        },
        204: {
            bodyMapper: GalleryApplicationVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: galleryApplicationVersion1,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName,
        galleryApplicationVersionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}/versions/{galleryApplicationVersionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplicationVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, expand9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName,
        galleryApplicationVersionName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}/versions/{galleryApplicationVersionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName,
        galleryApplicationVersionName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByGalleryApplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{galleryApplicationName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplicationVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByGalleryApplicationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryApplicationVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        galleryName,
        galleryApplicationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing GallerySharingProfile operations. */
class GallerySharingProfileImpl {
    /**
     * Initialize a new instance of the class GallerySharingProfile class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Update sharing profile of a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery.
     * @param sharingUpdate Parameters supplied to the update gallery sharing profile.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, galleryName, sharingUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, galleryName, sharingUpdate, options }, updateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update sharing profile of a gallery.
     * @param resourceGroupName The name of the resource group.
     * @param galleryName The name of the Shared Image Gallery.
     * @param sharingUpdate Parameters supplied to the update gallery sharing profile.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, galleryName, sharingUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, galleryName, sharingUpdate, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/share",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SharingUpdate
        },
        201: {
            bodyMapper: SharingUpdate
        },
        202: {
            bodyMapper: SharingUpdate
        },
        204: {
            bodyMapper: SharingUpdate
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: sharingUpdate,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        galleryName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SharedGalleries operations. */
class SharedGalleriesImpl {
    /**
     * Initialize a new instance of the class SharedGalleries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List shared galleries by subscription id or tenant id.
     * @param location Resource location.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List shared galleries by subscription id or tenant id.
     * @param location Resource location.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$7);
    }
    /**
     * Get a shared gallery by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param options The options parameters.
     */
    get(location, galleryUniqueName, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, options }, getOperationSpec$8);
    }
    /**
     * ListNext
     * @param location Resource location.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries/{galleryUniqueName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGallery
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SharedGalleryImages operations. */
class SharedGalleryImagesImpl {
    /**
     * Initialize a new instance of the class SharedGalleryImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List shared gallery images by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param options The options parameters.
     */
    list(location, galleryUniqueName, options) {
        const iter = this.listPagingAll(location, galleryUniqueName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, galleryUniqueName, options);
            }
        };
    }
    listPagingPage(location, galleryUniqueName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, galleryUniqueName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, galleryUniqueName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, galleryUniqueName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, galleryUniqueName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List shared gallery images by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param options The options parameters.
     */
    _list(location, galleryUniqueName, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, options }, listOperationSpec$6);
    }
    /**
     * Get a shared gallery image by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param galleryImageName The name of the Shared Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param options The options parameters.
     */
    get(location, galleryUniqueName, galleryImageName, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, galleryImageName, options }, getOperationSpec$7);
    }
    /**
     * ListNext
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, galleryUniqueName, nextLink, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries/{galleryUniqueName}/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries/{galleryUniqueName}/images/{galleryImageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SharedGalleryImageVersions operations. */
class SharedGalleryImageVersionsImpl {
    /**
     * Initialize a new instance of the class SharedGalleryImageVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List shared gallery image versions by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param galleryImageName The name of the Shared Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param options The options parameters.
     */
    list(location, galleryUniqueName, galleryImageName, options) {
        const iter = this.listPagingAll(location, galleryUniqueName, galleryImageName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, galleryUniqueName, galleryImageName, options);
            }
        };
    }
    listPagingPage(location, galleryUniqueName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, galleryUniqueName, galleryImageName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, galleryUniqueName, galleryImageName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, galleryUniqueName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, galleryUniqueName, galleryImageName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List shared gallery image versions by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param galleryImageName The name of the Shared Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param options The options parameters.
     */
    _list(location, galleryUniqueName, galleryImageName, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, galleryImageName, options }, listOperationSpec$5);
    }
    /**
     * Get a shared gallery image version by subscription id or tenant id.
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param galleryImageName The name of the Shared Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param galleryImageVersionName The name of the gallery image version to be created. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param options The options parameters.
     */
    get(location, galleryUniqueName, galleryImageName, galleryImageVersionName, options) {
        return this.client.sendOperationRequest({
            location,
            galleryUniqueName,
            galleryImageName,
            galleryImageVersionName,
            options
        }, getOperationSpec$6);
    }
    /**
     * ListNext
     * @param location Resource location.
     * @param galleryUniqueName The unique name of the Shared Gallery.
     * @param galleryImageName The name of the Shared Gallery Image Definition from which the Image
     *                         Versions are to be listed.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, galleryUniqueName, galleryImageName, nextLink, options) {
        return this.client.sendOperationRequest({ location, galleryUniqueName, galleryImageName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries/{galleryUniqueName}/images/{galleryImageName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/sharedGalleries/{galleryUniqueName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImageVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        galleryImageVersionName,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedGalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3, sharedTo],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1,
        galleryImageName,
        galleryUniqueName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing CommunityGalleries operations. */
class CommunityGalleriesImpl {
    /**
     * Initialize a new instance of the class CommunityGalleries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a community gallery by gallery public name.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param options The options parameters.
     */
    get(location, publicGalleryName, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, options }, getOperationSpec$5);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/communityGalleries/{publicGalleryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGallery
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CommunityGalleryImages operations. */
class CommunityGalleryImagesImpl {
    /**
     * Initialize a new instance of the class CommunityGalleryImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List community gallery images inside a gallery.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param options The options parameters.
     */
    list(location, publicGalleryName, options) {
        const iter = this.listPagingAll(location, publicGalleryName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, publicGalleryName, options);
            }
        };
    }
    listPagingPage(location, publicGalleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, publicGalleryName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, publicGalleryName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, publicGalleryName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, publicGalleryName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a community gallery image.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param galleryImageName The name of the community gallery image definition.
     * @param options The options parameters.
     */
    get(location, publicGalleryName, galleryImageName, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, galleryImageName, options }, getOperationSpec$4);
    }
    /**
     * List community gallery images inside a gallery.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param options The options parameters.
     */
    _list(location, publicGalleryName, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, publicGalleryName, nextLink, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/communityGalleries/{publicGalleryName}/images/{galleryImageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/communityGalleries/{publicGalleryName}/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CommunityGalleryImageVersions operations. */
class CommunityGalleryImageVersionsImpl {
    /**
     * Initialize a new instance of the class CommunityGalleryImageVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List community gallery image versions inside an image.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param galleryImageName The name of the community gallery image definition.
     * @param options The options parameters.
     */
    list(location, publicGalleryName, galleryImageName, options) {
        const iter = this.listPagingAll(location, publicGalleryName, galleryImageName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, publicGalleryName, galleryImageName, options);
            }
        };
    }
    listPagingPage(location, publicGalleryName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, publicGalleryName, galleryImageName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, publicGalleryName, galleryImageName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, publicGalleryName, galleryImageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, publicGalleryName, galleryImageName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a community gallery image version.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param galleryImageName The name of the community gallery image definition.
     * @param galleryImageVersionName The name of the community gallery image version. Needs to follow
     *                                semantic version name pattern: The allowed characters are digit and period. Digits must be within
     *                                the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>
     * @param options The options parameters.
     */
    get(location, publicGalleryName, galleryImageName, galleryImageVersionName, options) {
        return this.client.sendOperationRequest({
            location,
            publicGalleryName,
            galleryImageName,
            galleryImageVersionName,
            options
        }, getOperationSpec$3);
    }
    /**
     * List community gallery image versions inside an image.
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param galleryImageName The name of the community gallery image definition.
     * @param options The options parameters.
     */
    _list(location, publicGalleryName, galleryImageName, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, galleryImageName, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param location Resource location.
     * @param publicGalleryName The public name of the community gallery.
     * @param galleryImageName The name of the community gallery image definition.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, publicGalleryName, galleryImageName, nextLink, options) {
        return this.client.sendOperationRequest({ location, publicGalleryName, galleryImageName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/communityGalleries/{publicGalleryName}/images/{galleryImageName}/versions/{galleryImageVersionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImageVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        galleryImageVersionName,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/communityGalleries/{publicGalleryName}/images/{galleryImageName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        galleryImageName,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CommunityGalleryImageVersionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1,
        galleryImageName,
        publicGalleryName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudServiceRoleInstances operations. */
class CloudServiceRoleInstancesImpl {
    /**
     * Initialize a new instance of the class CloudServiceRoleInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of all role instances in a cloud service. Use nextLink property in the response to get
     * the next page of role instances. Do this till nextLink is null to fetch all the role instances.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    list(resourceGroupName, cloudServiceName, options) {
        const iter = this.listPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, cloudServiceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, cloudServiceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes a role instance from a cloud service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDelete(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { roleInstanceName, resourceGroupName, cloudServiceName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a role instance from a cloud service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDeleteAndWait(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(roleInstanceName, resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a role instance from a cloud service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    get(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ roleInstanceName, resourceGroupName, cloudServiceName, options }, getOperationSpec$2);
    }
    /**
     * Retrieves information about the run-time state of a role instance in a cloud service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    getInstanceView(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ roleInstanceName, resourceGroupName, cloudServiceName, options }, getInstanceViewOperationSpec$1);
    }
    /**
     * Gets the list of all role instances in a cloud service. Use nextLink property in the response to get
     * the next page of role instances. Do this till nextLink is null to fetch all the role instances.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    _list(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listOperationSpec$2);
    }
    /**
     * The Reboot Role Instance asynchronous operation requests a reboot of a role instance in the cloud
     * service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRestart(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { roleInstanceName, resourceGroupName, cloudServiceName, options }, restartOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Reboot Role Instance asynchronous operation requests a reboot of a role instance in the cloud
     * service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRestartAndWait(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(roleInstanceName, resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Reimage Role Instance asynchronous operation reinstalls the operating system on instances of web
     * roles or worker roles.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginReimage(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { roleInstanceName, resourceGroupName, cloudServiceName, options }, reimageOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Reimage Role Instance asynchronous operation reinstalls the operating system on instances of web
     * roles or worker roles.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginReimageAndWait(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(roleInstanceName, resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Rebuild Role Instance asynchronous operation reinstalls the operating system on instances of web
     * roles or worker roles and initializes the storage resources that are used by them. If you do not
     * want to initialize storage resources, you can use Reimage Role Instance.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRebuild(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { roleInstanceName, resourceGroupName, cloudServiceName, options }, rebuildOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Rebuild Role Instance asynchronous operation reinstalls the operating system on instances of web
     * roles or worker roles and initializes the storage resources that are used by them. If you do not
     * want to initialize storage resources, you can use Reimage Role Instance.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRebuildAndWait(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRebuild(roleInstanceName, resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a remote desktop file for a role instance in a cloud service.
     * @param roleInstanceName Name of the role instance.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    getRemoteDesktopFile(roleInstanceName, resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ roleInstanceName, resourceGroupName, cloudServiceName, options }, getRemoteDesktopFileOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleInstance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand2, apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getInstanceViewOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/instanceView",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleInstanceView
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand2, apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const restartOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const reimageOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const rebuildOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/rebuild",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getRemoteDesktopFileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/remoteDesktopFile",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        default: {}
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        roleInstanceName,
        cloudServiceName
    ],
    headerParameters: [accept2],
    serializer: serializer$4
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleInstanceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand2, apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudServiceRoles operations. */
class CloudServiceRolesImpl {
    /**
     * Initialize a new instance of the class CloudServiceRoles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all roles in a cloud service. Use nextLink property in the response to get the next
     * page of roles. Do this till nextLink is null to fetch all the roles.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    list(resourceGroupName, cloudServiceName, options) {
        const iter = this.listPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, cloudServiceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, cloudServiceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a role from a cloud service.
     * @param roleName Name of the role.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    get(roleName, resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ roleName, resourceGroupName, cloudServiceName, options }, getOperationSpec$1);
    }
    /**
     * Gets a list of all roles in a cloud service. Use nextLink property in the response to get the next
     * page of roles. Do this till nextLink is null to fetch all the roles.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    _list(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roles/{roleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceRole
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceRoleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceRoleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudServices operations. */
class CloudServicesImpl {
    /**
     * Initialize a new instance of the class CloudServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all cloud services in the subscription, regardless of the associated resource group.
     * Use nextLink property in the response to get the next page of Cloud Services. Do this till nextLink
     * is null to fetch all the Cloud Services.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(options);
            }
        };
    }
    listAllPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all cloud services under a resource group. Use nextLink property in the response to
     * get the next page of Cloud Services. Do this till nextLink is null to fetch all the Cloud Services.
     * @param resourceGroupName Name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Create or update a cloud service. Please note some properties can be set only during cloud service
     * creation.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a cloud service. Please note some properties can be set only during cloud service
     * creation.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Display information about a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    get(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, getOperationSpec);
    }
    /**
     * Gets the status of a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    getInstanceView(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, getInstanceViewOperationSpec);
    }
    /**
     * Gets a list of all cloud services in the subscription, regardless of the associated resource group.
     * Use nextLink property in the response to get the next page of Cloud Services. Do this till nextLink
     * is null to fetch all the Cloud Services.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec);
    }
    /**
     * Gets a list of all cloud services under a resource group. Use nextLink property in the response to
     * get the next page of Cloud Services. Do this till nextLink is null to fetch all the Cloud Services.
     * @param resourceGroupName Name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec);
    }
    /**
     * Starts the cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts the cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Power off the cloud service. Note that resources are still attached and you are getting charged for
     * the resources.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginPowerOff(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, powerOffOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Power off the cloud service. Note that resources are still attached and you are getting charged for
     * the resources.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginPowerOffAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPowerOff(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restarts one or more role instances in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restarts one or more role instances in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reimage asynchronous operation reinstalls the operating system on instances of web roles or worker
     * roles.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginReimage(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, reimageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reimage asynchronous operation reinstalls the operating system on instances of web roles or worker
     * roles.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginReimageAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Rebuild Role Instances reinstalls the operating system on instances of web roles or worker roles and
     * initializes the storage resources that are used by them. If you do not want to initialize storage
     * resources, you can use Reimage Role Instances.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRebuild(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, rebuildOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Rebuild Role Instances reinstalls the operating system on instances of web roles or worker roles and
     * initializes the storage resources that are used by them. If you do not want to initialize storage
     * resources, you can use Reimage Role Instances.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginRebuildAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRebuild(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes role instances in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDeleteInstances(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, options }, deleteInstancesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes role instances in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    beginDeleteInstancesAndWait(resourceGroupName, cloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteInstances(resourceGroupName, cloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CloudService
        },
        201: {
            bodyMapper: CloudService
        },
        202: {
            bodyMapper: CloudService
        },
        204: {
            bodyMapper: CloudService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters31,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CloudService
        },
        201: {
            bodyMapper: CloudService
        },
        202: {
            bodyMapper: CloudService
        },
        204: {
            bodyMapper: CloudService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters32,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getInstanceViewOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/instanceView",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceInstanceView
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listAllOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/cloudServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const powerOffOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/poweroff",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const reimageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const rebuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/rebuild",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteInstancesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/delete",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listAllNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudServicesUpdateDomain operations. */
class CloudServicesUpdateDomainImpl {
    /**
     * Initialize a new instance of the class CloudServicesUpdateDomain class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all update domains in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    listUpdateDomains(resourceGroupName, cloudServiceName, options) {
        const iter = this.listUpdateDomainsPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listUpdateDomainsPagingPage(resourceGroupName, cloudServiceName, options);
            }
        };
    }
    listUpdateDomainsPagingPage(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUpdateDomainsPagingPage_1() {
            let result = yield tslib.__await(this._listUpdateDomains(resourceGroupName, cloudServiceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listUpdateDomainsNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listUpdateDomainsPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUpdateDomainsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUpdateDomainsPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Updates the role instances in the specified update domain.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param updateDomain Specifies an integer value that identifies the update domain. Update domains are
     *                     identified with a zero-based index: the first update domain has an ID of 0, the second has an ID of
     *                     1, and so on.
     * @param options The options parameters.
     */
    beginWalkUpdateDomain(resourceGroupName, cloudServiceName, updateDomain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudServiceName, updateDomain, options }, walkUpdateDomainOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the role instances in the specified update domain.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param updateDomain Specifies an integer value that identifies the update domain. Update domains are
     *                     identified with a zero-based index: the first update domain has an ID of 0, the second has an ID of
     *                     1, and so on.
     * @param options The options parameters.
     */
    beginWalkUpdateDomainAndWait(resourceGroupName, cloudServiceName, updateDomain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWalkUpdateDomain(resourceGroupName, cloudServiceName, updateDomain, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified update domain of a cloud service. Use nextLink property in the response to get
     * the next page of update domains. Do this till nextLink is null to fetch all the update domains.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param updateDomain Specifies an integer value that identifies the update domain. Update domains are
     *                     identified with a zero-based index: the first update domain has an ID of 0, the second has an ID of
     *                     1, and so on.
     * @param options The options parameters.
     */
    getUpdateDomain(resourceGroupName, cloudServiceName, updateDomain, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, updateDomain, options }, getUpdateDomainOperationSpec);
    }
    /**
     * Gets a list of all update domains in a cloud service.
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param options The options parameters.
     */
    _listUpdateDomains(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listUpdateDomainsOperationSpec);
    }
    /**
     * ListUpdateDomainsNext
     * @param resourceGroupName Name of the resource group.
     * @param cloudServiceName Name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the ListUpdateDomains method.
     * @param options The options parameters.
     */
    _listUpdateDomainsNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listUpdateDomainsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const walkUpdateDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/updateDomains/{updateDomain}",
    httpMethod: "PUT",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters34,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName,
        updateDomain
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getUpdateDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/updateDomains/{updateDomain}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UpdateDomain
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName,
        updateDomain
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listUpdateDomainsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/updateDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UpdateDomainListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listUpdateDomainsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UpdateDomainListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudServiceOperatingSystems operations. */
class CloudServiceOperatingSystemsImpl {
    /**
     * Initialize a new instance of the class CloudServiceOperatingSystems class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all guest operating system versions available to be specified in the XML service
     * configuration (.cscfg) for a cloud service. Use nextLink property in the response to get the next
     * page of OS versions. Do this till nextLink is null to fetch all the OS versions.
     * @param location Name of the location that the OS versions pertain to.
     * @param options The options parameters.
     */
    listOSVersions(location, options) {
        const iter = this.listOSVersionsPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOSVersionsPagingPage(location, options);
            }
        };
    }
    listOSVersionsPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOSVersionsPagingPage_1() {
            let result = yield tslib.__await(this._listOSVersions(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOSVersionsNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOSVersionsPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOSVersionsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOSVersionsPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all guest operating system families available to be specified in the XML service
     * configuration (.cscfg) for a cloud service. Use nextLink property in the response to get the next
     * page of OS Families. Do this till nextLink is null to fetch all the OS Families.
     * @param location Name of the location that the OS families pertain to.
     * @param options The options parameters.
     */
    listOSFamilies(location, options) {
        const iter = this.listOSFamiliesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listOSFamiliesPagingPage(location, options);
            }
        };
    }
    listOSFamiliesPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOSFamiliesPagingPage_1() {
            let result = yield tslib.__await(this._listOSFamilies(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listOSFamiliesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listOSFamiliesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOSFamiliesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listOSFamiliesPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets properties of a guest operating system version that can be specified in the XML service
     * configuration (.cscfg) for a cloud service.
     * @param location Name of the location that the OS version pertains to.
     * @param osVersionName Name of the OS version.
     * @param options The options parameters.
     */
    getOSVersion(location, osVersionName, options) {
        return this.client.sendOperationRequest({ location, osVersionName, options }, getOSVersionOperationSpec);
    }
    /**
     * Gets a list of all guest operating system versions available to be specified in the XML service
     * configuration (.cscfg) for a cloud service. Use nextLink property in the response to get the next
     * page of OS versions. Do this till nextLink is null to fetch all the OS versions.
     * @param location Name of the location that the OS versions pertain to.
     * @param options The options parameters.
     */
    _listOSVersions(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOSVersionsOperationSpec);
    }
    /**
     * Gets properties of a guest operating system family that can be specified in the XML service
     * configuration (.cscfg) for a cloud service.
     * @param location Name of the location that the OS family pertains to.
     * @param osFamilyName Name of the OS family.
     * @param options The options parameters.
     */
    getOSFamily(location, osFamilyName, options) {
        return this.client.sendOperationRequest({ location, osFamilyName, options }, getOSFamilyOperationSpec);
    }
    /**
     * Gets a list of all guest operating system families available to be specified in the XML service
     * configuration (.cscfg) for a cloud service. Use nextLink property in the response to get the next
     * page of OS Families. Do this till nextLink is null to fetch all the OS Families.
     * @param location Name of the location that the OS families pertain to.
     * @param options The options parameters.
     */
    _listOSFamilies(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOSFamiliesOperationSpec);
    }
    /**
     * ListOSVersionsNext
     * @param location Name of the location that the OS versions pertain to.
     * @param nextLink The nextLink from the previous successful call to the ListOSVersions method.
     * @param options The options parameters.
     */
    _listOSVersionsNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listOSVersionsNextOperationSpec);
    }
    /**
     * ListOSFamiliesNext
     * @param location Name of the location that the OS families pertain to.
     * @param nextLink The nextLink from the previous successful call to the ListOSFamilies method.
     * @param options The options parameters.
     */
    _listOSFamiliesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listOSFamiliesNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOSVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/cloudServiceOsVersions/{osVersionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSVersion
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        osVersionName
    ],
    headerParameters: [accept],
    serializer
};
const listOSVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/cloudServiceOsVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSVersionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer
};
const getOSFamilyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/cloudServiceOsFamilies/{osFamilyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSFamily
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        osFamilyName
    ],
    headerParameters: [accept],
    serializer
};
const listOSFamiliesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Compute/locations/{location}/cloudServiceOsFamilies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSFamilyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer
};
const listOSVersionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSVersionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer
};
const listOSFamiliesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSFamilyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ComputeManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ComputeManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials which uniquely identify Microsoft Azure subscription.
     *                       The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-compute/19.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: `${optionsWithDefaults.credentialScopes}`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.operations = new OperationsImpl(this);
        this.usageOperations = new UsageOperationsImpl(this);
        this.virtualMachineSizes = new VirtualMachineSizesImpl(this);
        this.virtualMachineScaleSets = new VirtualMachineScaleSetsImpl(this);
        this.virtualMachineScaleSetExtensions = new VirtualMachineScaleSetExtensionsImpl(this);
        this.virtualMachineScaleSetRollingUpgrades = new VirtualMachineScaleSetRollingUpgradesImpl(this);
        this.virtualMachineScaleSetVMExtensions = new VirtualMachineScaleSetVMExtensionsImpl(this);
        this.virtualMachineScaleSetVMs = new VirtualMachineScaleSetVMsImpl(this);
        this.virtualMachineExtensions = new VirtualMachineExtensionsImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.virtualMachineImages = new VirtualMachineImagesImpl(this);
        this.virtualMachineImagesEdgeZone = new VirtualMachineImagesEdgeZoneImpl(this);
        this.virtualMachineExtensionImages = new VirtualMachineExtensionImagesImpl(this);
        this.availabilitySets = new AvailabilitySetsImpl(this);
        this.proximityPlacementGroups = new ProximityPlacementGroupsImpl(this);
        this.dedicatedHostGroups = new DedicatedHostGroupsImpl(this);
        this.dedicatedHosts = new DedicatedHostsImpl(this);
        this.sshPublicKeys = new SshPublicKeysImpl(this);
        this.images = new ImagesImpl(this);
        this.restorePointCollections = new RestorePointCollectionsImpl(this);
        this.restorePoints = new RestorePointsImpl(this);
        this.capacityReservationGroups = new CapacityReservationGroupsImpl(this);
        this.capacityReservations = new CapacityReservationsImpl(this);
        this.logAnalytics = new LogAnalyticsImpl(this);
        this.virtualMachineRunCommands = new VirtualMachineRunCommandsImpl(this);
        this.virtualMachineScaleSetVMRunCommands = new VirtualMachineScaleSetVMRunCommandsImpl(this);
        this.disks = new DisksImpl(this);
        this.diskAccesses = new DiskAccessesImpl(this);
        this.diskEncryptionSets = new DiskEncryptionSetsImpl(this);
        this.diskRestorePointOperations = new DiskRestorePointOperationsImpl(this);
        this.snapshots = new SnapshotsImpl(this);
        this.resourceSkus = new ResourceSkusImpl(this);
        this.galleries = new GalleriesImpl(this);
        this.galleryImages = new GalleryImagesImpl(this);
        this.galleryImageVersions = new GalleryImageVersionsImpl(this);
        this.galleryApplications = new GalleryApplicationsImpl(this);
        this.galleryApplicationVersions = new GalleryApplicationVersionsImpl(this);
        this.gallerySharingProfile = new GallerySharingProfileImpl(this);
        this.sharedGalleries = new SharedGalleriesImpl(this);
        this.sharedGalleryImages = new SharedGalleryImagesImpl(this);
        this.sharedGalleryImageVersions = new SharedGalleryImageVersionsImpl(this);
        this.communityGalleries = new CommunityGalleriesImpl(this);
        this.communityGalleryImages = new CommunityGalleryImagesImpl(this);
        this.communityGalleryImageVersions = new CommunityGalleryImageVersionsImpl(this);
        this.cloudServiceRoleInstances = new CloudServiceRoleInstancesImpl(this);
        this.cloudServiceRoles = new CloudServiceRolesImpl(this);
        this.cloudServices = new CloudServicesImpl(this);
        this.cloudServicesUpdateDomain = new CloudServicesUpdateDomainImpl(this);
        this.cloudServiceOperatingSystems = new CloudServiceOperatingSystemsImpl(this);
    }
}

exports.ComputeManagementClient = ComputeManagementClient;
//# sourceMappingURL=index.js.map
